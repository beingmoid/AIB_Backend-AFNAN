(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["src-app-pages-dashboard-dashboard-module"],{

/***/ "+RkR":
/*!***********************************************!*\
  !*** ./node_modules/d3-collection/src/map.js ***!
  \***********************************************/
/*! exports provided: prefix, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "prefix", function() { return prefix; });
var prefix = "$";

function Map() {}

Map.prototype = map.prototype = {
  constructor: Map,
  has: function(key) {
    return (prefix + key) in this;
  },
  get: function(key) {
    return this[prefix + key];
  },
  set: function(key, value) {
    this[prefix + key] = value;
    return this;
  },
  remove: function(key) {
    var property = prefix + key;
    return property in this && delete this[property];
  },
  clear: function() {
    for (var property in this) if (property[0] === prefix) delete this[property];
  },
  keys: function() {
    var keys = [];
    for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));
    return keys;
  },
  values: function() {
    var values = [];
    for (var property in this) if (property[0] === prefix) values.push(this[property]);
    return values;
  },
  entries: function() {
    var entries = [];
    for (var property in this) if (property[0] === prefix) entries.push({key: property.slice(1), value: this[property]});
    return entries;
  },
  size: function() {
    var size = 0;
    for (var property in this) if (property[0] === prefix) ++size;
    return size;
  },
  empty: function() {
    for (var property in this) if (property[0] === prefix) return false;
    return true;
  },
  each: function(f) {
    for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);
  }
};

function map(object, f) {
  var map = new Map;

  // Copy constructor.
  if (object instanceof Map) object.each(function(value, key) { map.set(key, value); });

  // Index array by numeric index or specified key function.
  else if (Array.isArray(object)) {
    var i = -1,
        n = object.length,
        o;

    if (f == null) while (++i < n) map.set(i, object[i]);
    else while (++i < n) map.set(f(o = object[i], i, object), o);
  }

  // Convert object to map.
  else if (object) for (var key in object) map.set(key, object[key]);

  return map;
}

/* harmony default export */ __webpack_exports__["default"] = (map);


/***/ }),

/***/ "+WWN":
/*!**********************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/equalEarth.js ***!
  \**********************************************************/
/*! exports provided: equalEarthRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equalEarthRaw", function() { return equalEarthRaw; });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "1ibS");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math.js */ "R0y8");



var A1 = 1.340264,
    A2 = -0.081106,
    A3 = 0.000893,
    A4 = 0.003796,
    M = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(3) / 2,
    iterations = 12;

function equalEarthRaw(lambda, phi) {
  var l = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["asin"])(M * Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi)), l2 = l * l, l6 = l2 * l2 * l2;
  return [
    lambda * Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["cos"])(l) / (M * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2))),
    l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2))
  ];
}

equalEarthRaw.invert = function(x, y) {
  var l = y, l2 = l * l, l6 = l2 * l2 * l2;
  for (var i = 0, delta, fy, fpy; i < iterations; ++i) {
    fy = l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2)) - y;
    fpy = A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2);
    l -= delta = fy / fpy, l2 = l * l, l6 = l2 * l2 * l2;
    if (Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["abs"])(delta) < _math_js__WEBPACK_IMPORTED_MODULE_1__["epsilon2"]) break;
  }
  return [
    M * x * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2)) / Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["cos"])(l),
    Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["asin"])(Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["sin"])(l) / M)
  ];
};

/* harmony default export */ __webpack_exports__["default"] = (function() {
  return Object(_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(equalEarthRaw)
      .scale(177.158);
});


/***/ }),

/***/ "+s1I":
/*!*******************************************!*\
  !*** ./node_modules/d3-axis/src/array.js ***!
  \*******************************************/
/*! exports provided: slice */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slice", function() { return slice; });
var slice = Array.prototype.slice;


/***/ }),

/***/ "+u7/":
/*!********************************************!*\
  !*** ./node_modules/d3-chord/src/index.js ***!
  \********************************************/
/*! exports provided: chord, ribbon */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _chord__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chord */ "22Jt");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "chord", function() { return _chord__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _ribbon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ribbon */ "SKGk");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ribbon", function() { return _ribbon__WEBPACK_IMPORTED_MODULE_1__["default"]; });





/***/ }),

/***/ "//NX":
/*!***********************************************************!*\
  !*** ./node_modules/c3/node_modules/d3-scale/src/init.js ***!
  \***********************************************************/
/*! exports provided: initRange, initInterpolator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "initRange", function() { return initRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "initInterpolator", function() { return initInterpolator; });
function initRange(domain, range) {
  switch (arguments.length) {
    case 0: break;
    case 1: this.range(domain); break;
    default: this.range(range).domain(domain); break;
  }
  return this;
}

function initInterpolator(domain, interpolator) {
  switch (arguments.length) {
    case 0: break;
    case 1: this.interpolator(domain); break;
    default: this.interpolator(interpolator).domain(domain); break;
  }
  return this;
}


/***/ }),

/***/ "/2RN":
/*!*****************************************************!*\
  !*** ./src/app/pages/dashboard/dashboard.module.ts ***!
  \*****************************************************/
/*! exports provided: DashboardModule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DashboardModule", function() { return DashboardModule; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "8Y7J");
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/common */ "SVse");
/* harmony import */ var _dashboard_routing_module__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dashboard-routing.module */ "ea/W");
/* harmony import */ var _dashboard_dashboard_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dashboard/dashboard.component */ "XElW");
/* harmony import */ var src_app_shared_shared_module__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! src/app/shared/shared.module */ "PCNd");
/* harmony import */ var src_app_antd_antd_module__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! src/app/antd/antd.module */ "PaOY");







class DashboardModule {
}
DashboardModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({ type: DashboardModule });
DashboardModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({ factory: function DashboardModule_Factory(t) { return new (t || DashboardModule)(); }, imports: [[
            _angular_common__WEBPACK_IMPORTED_MODULE_1__["CommonModule"],
            _dashboard_routing_module__WEBPACK_IMPORTED_MODULE_2__["DashboardRoutingModule"],
            src_app_shared_shared_module__WEBPACK_IMPORTED_MODULE_4__["SharedModule"],
            src_app_antd_antd_module__WEBPACK_IMPORTED_MODULE_5__["AntdModule"]
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](DashboardModule, { declarations: [_dashboard_dashboard_component__WEBPACK_IMPORTED_MODULE_3__["DashboardComponent"]], imports: [_angular_common__WEBPACK_IMPORTED_MODULE_1__["CommonModule"],
        _dashboard_routing_module__WEBPACK_IMPORTED_MODULE_2__["DashboardRoutingModule"],
        src_app_shared_shared_module__WEBPACK_IMPORTED_MODULE_4__["SharedModule"],
        src_app_antd_antd_module__WEBPACK_IMPORTED_MODULE_5__["AntdModule"]] }); })();
/*@__PURE__*/ (function () { _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](DashboardModule, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"],
        args: [{
                declarations: [_dashboard_dashboard_component__WEBPACK_IMPORTED_MODULE_3__["DashboardComponent"]],
                imports: [
                    _angular_common__WEBPACK_IMPORTED_MODULE_1__["CommonModule"],
                    _dashboard_routing_module__WEBPACK_IMPORTED_MODULE_2__["DashboardRoutingModule"],
                    src_app_shared_shared_module__WEBPACK_IMPORTED_MODULE_4__["SharedModule"],
                    src_app_antd_antd_module__WEBPACK_IMPORTED_MODULE_5__["AntdModule"]
                ]
            }]
    }], null, null); })();


/***/ }),

/***/ "/Cr3":
/*!**********************************************************!*\
  !*** ./node_modules/c3/node_modules/d3-array/src/sum.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (value = +values[i]) sum += value; // Note: zero and null are equivalent.
    }
  }

  else {
    while (++i < n) {
      if (value = +valueof(values[i], i, values)) sum += value;
    }
  }

  return sum;
});


/***/ }),

/***/ "/IEk":
/*!*********************************************************!*\
  !*** ./node_modules/c3/node_modules/d3/dist/package.js ***!
  \*********************************************************/
/*! exports provided: name, version, description, keywords, homepage, license, author, main, unpkg, jsdelivr, module, repository, files, scripts, devDependencies, dependencies */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "name", function() { return name; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version", function() { return version; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "description", function() { return description; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "keywords", function() { return keywords; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "homepage", function() { return homepage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "license", function() { return license; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "author", function() { return author; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "main", function() { return main; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unpkg", function() { return unpkg; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "jsdelivr", function() { return jsdelivr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "module", function() { return module; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "repository", function() { return repository; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "files", function() { return files; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scripts", function() { return scripts; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "devDependencies", function() { return devDependencies; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dependencies", function() { return dependencies; });
var name = "d3";
var version = "5.16.0";
var description = "Data-Driven Documents";
var keywords = ["dom","visualization","svg","animation","canvas"];
var homepage = "https://d3js.org";
var license = "BSD-3-Clause";
var author = {"name":"Mike Bostock","url":"https://bost.ocks.org/mike"};
var main = "dist/d3.node.js";
var unpkg = "dist/d3.min.js";
var jsdelivr = "dist/d3.min.js";
var module = "index.js";
var repository = {"type":"git","url":"https://github.com/d3/d3.git"};
var files = ["dist/**/*.js","index.js"];
var scripts = {"pretest":"rimraf dist && mkdir dist && json2module package.json > dist/package.js && rollup -c","test":"tape 'test/**/*-test.js'","prepublishOnly":"yarn test","postpublish":"git push && git push --tags && cd ../d3.github.com && git pull && cp ../d3/dist/d3.js d3.v5.js && cp ../d3/dist/d3.min.js d3.v5.min.js && git add d3.v5.js d3.v5.min.js && git commit -m \"d3 ${npm_package_version}\" && git push && cd - && cd ../d3-bower && git pull && cp ../d3/LICENSE ../d3/README.md ../d3/dist/d3.js ../d3/dist/d3.min.js . && git add -- LICENSE README.md d3.js d3.min.js && git commit -m \"${npm_package_version}\" && git tag -am \"${npm_package_version}\" v${npm_package_version} && git push && git push --tags && cd - && zip -j dist/d3.zip -- LICENSE README.md API.md CHANGES.md dist/d3.js dist/d3.min.js"};
var devDependencies = {"json2module":"0.0","rimraf":"2","rollup":"1","rollup-plugin-ascii":"0.0","rollup-plugin-node-resolve":"3","rollup-plugin-terser":"5","tape":"4"};
var dependencies = {"d3-array":"1","d3-axis":"1","d3-brush":"1","d3-chord":"1","d3-collection":"1","d3-color":"1","d3-contour":"1","d3-dispatch":"1","d3-drag":"1","d3-dsv":"1","d3-ease":"1","d3-fetch":"1","d3-force":"1","d3-format":"1","d3-geo":"1","d3-hierarchy":"1","d3-interpolate":"1","d3-path":"1","d3-polygon":"1","d3-quadtree":"1","d3-random":"1","d3-scale":"2","d3-scale-chromatic":"1","d3-selection":"1","d3-shape":"1","d3-time":"1","d3-time-format":"2","d3-timer":"1","d3-transition":"1","d3-voronoi":"1","d3-zoom":"1"};


/***/ }),

/***/ "/yBm":
/*!**********************************************!*\
  !*** ./node_modules/d3-voronoi/src/point.js ***!
  \**********************************************/
/*! exports provided: x, y */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "x", function() { return x; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "y", function() { return y; });
function x(d) {
  return d[0];
}

function y(d) {
  return d[1];
}


/***/ }),

/***/ "0AbP":
/*!***********************************************!*\
  !*** ./src/app/services/dashboard.service.ts ***!
  \***********************************************/
/*! exports provided: DashboardService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DashboardService", function() { return DashboardService; });
/* harmony import */ var _angular_common_http__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/common/http */ "IheW");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "8Y7J");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs */ "qCKp");
/* harmony import */ var _Model_Global__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Model/Global */ "BQhZ");
/* harmony import */ var _base_api_handler_service__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./base-api-handler.service */ "91If");







class DashboardService extends _base_api_handler_service__WEBPACK_IMPORTED_MODULE_4__["BaseApiHandlerService"] {
    constructor(http) {
        super(http);
        this.http = http;
        this.dashboardSubject$ = new rxjs__WEBPACK_IMPORTED_MODULE_2__["BehaviorSubject"](undefined);
        this.overalllSubject$ = new rxjs__WEBPACK_IMPORTED_MODULE_2__["BehaviorSubject"](undefined);
        this.dashboardObserver$ = this.dashboardSubject$.asObservable();
        this.overallInfoObserver$ = this.overalllSubject$.asObservable();
    }
    GetAnalytics() {
        this.GetAll(_Model_Global__WEBPACK_IMPORTED_MODULE_3__["API_URL"] + _Model_Global__WEBPACK_IMPORTED_MODULE_3__["API_ENDPOINTS"].Transaction + "/GetAnalytics").subscribe(res => {
            this.dashboardSubject$.next(res.dynamicResult);
        });
    }
    GetOverAllInfo() {
        this.GetAll(_Model_Global__WEBPACK_IMPORTED_MODULE_3__["API_URL"] + _Model_Global__WEBPACK_IMPORTED_MODULE_3__["API_ENDPOINTS"].Transaction + "/OverallInfo").subscribe(res => {
            this.overalllSubject$.next(res.dynamicResult);
        });
    }
    getRevenuePerMonthData(date) {
        var url = _Model_Global__WEBPACK_IMPORTED_MODULE_3__["API_URL"] + _Model_Global__WEBPACK_IMPORTED_MODULE_3__["API_ENDPOINTS"].Transaction + `/GetRevenuePerMonthData?date=${date}`;
        return this.GetAll(url);
    }
}
DashboardService.ɵfac = function DashboardService_Factory(t) { return new (t || DashboardService)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_angular_common_http__WEBPACK_IMPORTED_MODULE_0__["HttpClient"])); };
DashboardService.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({ token: DashboardService, factory: DashboardService.ɵfac, providedIn: 'root' });
/*@__PURE__*/ (function () { _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵsetClassMetadata"](DashboardService, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"],
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: _angular_common_http__WEBPACK_IMPORTED_MODULE_0__["HttpClient"] }]; }, null); })();


/***/ }),

/***/ "0LFD":
/*!*********************************************!*\
  !*** ./node_modules/d3-force/src/center.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x, y) {
  var nodes;

  if (x == null) x = 0;
  if (y == null) y = 0;

  function force() {
    var i,
        n = nodes.length,
        node,
        sx = 0,
        sy = 0;

    for (i = 0; i < n; ++i) {
      node = nodes[i], sx += node.x, sy += node.y;
    }

    for (sx = sx / n - x, sy = sy / n - y, i = 0; i < n; ++i) {
      node = nodes[i], node.x -= sx, node.y -= sy;
    }
  }

  force.initialize = function(_) {
    nodes = _;
  };

  force.x = function(_) {
    return arguments.length ? (x = +_, force) : x;
  };

  force.y = function(_) {
    return arguments.length ? (y = +_, force) : y;
  };

  return force;
});


/***/ }),

/***/ "0RZX":
/*!*****************************************************!*\
  !*** ./node_modules/d3-random/src/defaultSource.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function() {
  return Math.random();
});


/***/ }),

/***/ "0VgA":
/*!************************************************************!*\
  !*** ./node_modules/c3/node_modules/d3-array/src/pairs.js ***!
  \************************************************************/
/*! exports provided: default, pair */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pair", function() { return pair; });
/* harmony default export */ __webpack_exports__["default"] = (function(array, f) {
  if (f == null) f = pair;
  var i = 0, n = array.length - 1, p = array[0], pairs = new Array(n < 0 ? 0 : n);
  while (i < n) pairs[i] = f(p, p = array[++i]);
  return pairs;
});

function pair(a, b) {
  return [a, b];
}


/***/ }),

/***/ "0rNn":
/*!****************************************!*\
  !*** ./node_modules/d3-force/src/y.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant */ "nXVj");


/* harmony default export */ __webpack_exports__["default"] = (function(y) {
  var strength = Object(_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(0.1),
      nodes,
      strengths,
      yz;

  if (typeof y !== "function") y = Object(_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(y == null ? 0 : +y);

  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    yz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), initialize(), force) : strength;
  };

  force.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), initialize(), force) : y;
  };

  return force;
});


/***/ }),

/***/ "1Fr+":
/*!*************************************************************!*\
  !*** ./node_modules/c3/node_modules/d3-array/src/number.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return x === null ? NaN : +x;
});


/***/ }),

/***/ "1ibS":
/*!*****************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/index.js ***!
  \*****************************************************/
/*! exports provided: default, projectionMutator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return projection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "projectionMutator", function() { return projectionMutator; });
/* harmony import */ var _clip_antimeridian_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../clip/antimeridian.js */ "9ZWv");
/* harmony import */ var _clip_circle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../clip/circle.js */ "PQSO");
/* harmony import */ var _clip_rectangle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../clip/rectangle.js */ "F2eR");
/* harmony import */ var _compose_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../compose.js */ "pbho");
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../identity.js */ "IYKK");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../math.js */ "R0y8");
/* harmony import */ var _rotation_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../rotation.js */ "cwsO");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../transform.js */ "t9E6");
/* harmony import */ var _fit_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./fit.js */ "XAaG");
/* harmony import */ var _resample_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./resample.js */ "TKDR");











var transformRadians = Object(_transform_js__WEBPACK_IMPORTED_MODULE_7__["transformer"])({
  point: function(x, y) {
    this.stream.point(x * _math_js__WEBPACK_IMPORTED_MODULE_5__["radians"], y * _math_js__WEBPACK_IMPORTED_MODULE_5__["radians"]);
  }
});

function transformRotate(rotate) {
  return Object(_transform_js__WEBPACK_IMPORTED_MODULE_7__["transformer"])({
    point: function(x, y) {
      var r = rotate(x, y);
      return this.stream.point(r[0], r[1]);
    }
  });
}

function scaleTranslate(k, dx, dy, sx, sy) {
  function transform(x, y) {
    x *= sx; y *= sy;
    return [dx + k * x, dy - k * y];
  }
  transform.invert = function(x, y) {
    return [(x - dx) / k * sx, (dy - y) / k * sy];
  };
  return transform;
}

function scaleTranslateRotate(k, dx, dy, sx, sy, alpha) {
  var cosAlpha = Object(_math_js__WEBPACK_IMPORTED_MODULE_5__["cos"])(alpha),
      sinAlpha = Object(_math_js__WEBPACK_IMPORTED_MODULE_5__["sin"])(alpha),
      a = cosAlpha * k,
      b = sinAlpha * k,
      ai = cosAlpha / k,
      bi = sinAlpha / k,
      ci = (sinAlpha * dy - cosAlpha * dx) / k,
      fi = (sinAlpha * dx + cosAlpha * dy) / k;
  function transform(x, y) {
    x *= sx; y *= sy;
    return [a * x - b * y + dx, dy - b * x - a * y];
  }
  transform.invert = function(x, y) {
    return [sx * (ai * x - bi * y + ci), sy * (fi - bi * x - ai * y)];
  };
  return transform;
}

function projection(project) {
  return projectionMutator(function() { return project; })();
}

function projectionMutator(projectAt) {
  var project,
      k = 150, // scale
      x = 480, y = 250, // translate
      lambda = 0, phi = 0, // center
      deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, // pre-rotate
      alpha = 0, // post-rotate angle
      sx = 1, // reflectX
      sy = 1, // reflectX
      theta = null, preclip = _clip_antimeridian_js__WEBPACK_IMPORTED_MODULE_0__["default"], // pre-clip angle
      x0 = null, y0, x1, y1, postclip = _identity_js__WEBPACK_IMPORTED_MODULE_4__["default"], // post-clip extent
      delta2 = 0.5, // precision
      projectResample,
      projectTransform,
      projectRotateTransform,
      cache,
      cacheStream;

  function projection(point) {
    return projectRotateTransform(point[0] * _math_js__WEBPACK_IMPORTED_MODULE_5__["radians"], point[1] * _math_js__WEBPACK_IMPORTED_MODULE_5__["radians"]);
  }

  function invert(point) {
    point = projectRotateTransform.invert(point[0], point[1]);
    return point && [point[0] * _math_js__WEBPACK_IMPORTED_MODULE_5__["degrees"], point[1] * _math_js__WEBPACK_IMPORTED_MODULE_5__["degrees"]];
  }

  projection.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
  };

  projection.preclip = function(_) {
    return arguments.length ? (preclip = _, theta = undefined, reset()) : preclip;
  };

  projection.postclip = function(_) {
    return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
  };

  projection.clipAngle = function(_) {
    return arguments.length ? (preclip = +_ ? Object(_clip_circle_js__WEBPACK_IMPORTED_MODULE_1__["default"])(theta = _ * _math_js__WEBPACK_IMPORTED_MODULE_5__["radians"]) : (theta = null, _clip_antimeridian_js__WEBPACK_IMPORTED_MODULE_0__["default"]), reset()) : theta * _math_js__WEBPACK_IMPORTED_MODULE_5__["degrees"];
  };

  projection.clipExtent = function(_) {
    return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, _identity_js__WEBPACK_IMPORTED_MODULE_4__["default"]) : Object(_clip_rectangle_js__WEBPACK_IMPORTED_MODULE_2__["default"])(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
  };

  projection.scale = function(_) {
    return arguments.length ? (k = +_, recenter()) : k;
  };

  projection.translate = function(_) {
    return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
  };

  projection.center = function(_) {
    return arguments.length ? (lambda = _[0] % 360 * _math_js__WEBPACK_IMPORTED_MODULE_5__["radians"], phi = _[1] % 360 * _math_js__WEBPACK_IMPORTED_MODULE_5__["radians"], recenter()) : [lambda * _math_js__WEBPACK_IMPORTED_MODULE_5__["degrees"], phi * _math_js__WEBPACK_IMPORTED_MODULE_5__["degrees"]];
  };

  projection.rotate = function(_) {
    return arguments.length ? (deltaLambda = _[0] % 360 * _math_js__WEBPACK_IMPORTED_MODULE_5__["radians"], deltaPhi = _[1] % 360 * _math_js__WEBPACK_IMPORTED_MODULE_5__["radians"], deltaGamma = _.length > 2 ? _[2] % 360 * _math_js__WEBPACK_IMPORTED_MODULE_5__["radians"] : 0, recenter()) : [deltaLambda * _math_js__WEBPACK_IMPORTED_MODULE_5__["degrees"], deltaPhi * _math_js__WEBPACK_IMPORTED_MODULE_5__["degrees"], deltaGamma * _math_js__WEBPACK_IMPORTED_MODULE_5__["degrees"]];
  };

  projection.angle = function(_) {
    return arguments.length ? (alpha = _ % 360 * _math_js__WEBPACK_IMPORTED_MODULE_5__["radians"], recenter()) : alpha * _math_js__WEBPACK_IMPORTED_MODULE_5__["degrees"];
  };

  projection.reflectX = function(_) {
    return arguments.length ? (sx = _ ? -1 : 1, recenter()) : sx < 0;
  };

  projection.reflectY = function(_) {
    return arguments.length ? (sy = _ ? -1 : 1, recenter()) : sy < 0;
  };

  projection.precision = function(_) {
    return arguments.length ? (projectResample = Object(_resample_js__WEBPACK_IMPORTED_MODULE_9__["default"])(projectTransform, delta2 = _ * _), reset()) : Object(_math_js__WEBPACK_IMPORTED_MODULE_5__["sqrt"])(delta2);
  };

  projection.fitExtent = function(extent, object) {
    return Object(_fit_js__WEBPACK_IMPORTED_MODULE_8__["fitExtent"])(projection, extent, object);
  };

  projection.fitSize = function(size, object) {
    return Object(_fit_js__WEBPACK_IMPORTED_MODULE_8__["fitSize"])(projection, size, object);
  };

  projection.fitWidth = function(width, object) {
    return Object(_fit_js__WEBPACK_IMPORTED_MODULE_8__["fitWidth"])(projection, width, object);
  };

  projection.fitHeight = function(height, object) {
    return Object(_fit_js__WEBPACK_IMPORTED_MODULE_8__["fitHeight"])(projection, height, object);
  };

  function recenter() {
    var center = scaleTranslateRotate(k, 0, 0, sx, sy, alpha).apply(null, project(lambda, phi)),
        transform = (alpha ? scaleTranslateRotate : scaleTranslate)(k, x - center[0], y - center[1], sx, sy, alpha);
    rotate = Object(_rotation_js__WEBPACK_IMPORTED_MODULE_6__["rotateRadians"])(deltaLambda, deltaPhi, deltaGamma);
    projectTransform = Object(_compose_js__WEBPACK_IMPORTED_MODULE_3__["default"])(project, transform);
    projectRotateTransform = Object(_compose_js__WEBPACK_IMPORTED_MODULE_3__["default"])(rotate, projectTransform);
    projectResample = Object(_resample_js__WEBPACK_IMPORTED_MODULE_9__["default"])(projectTransform, delta2);
    return reset();
  }

  function reset() {
    cache = cacheStream = null;
    return projection;
  }

  return function() {
    project = projectAt.apply(this, arguments);
    projection.invert = project.invert && invert;
    return recenter();
  };
}


/***/ }),

/***/ "1jur":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/categorical/Set1.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors.js */ "ZtE7");


/* harmony default export */ __webpack_exports__["default"] = (Object(_colors_js__WEBPACK_IMPORTED_MODULE_0__["default"])("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999"));


/***/ }),

/***/ "1oRR":
/*!**********************************************************!*\
  !*** ./node_modules/c3/node_modules/d3-array/src/zip.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _transpose__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transpose */ "TQ5W");


/* harmony default export */ __webpack_exports__["default"] = (function() {
  return Object(_transpose__WEBPACK_IMPORTED_MODULE_0__["default"])(arguments);
});


/***/ }),

/***/ "22Jt":
/*!********************************************!*\
  !*** ./node_modules/d3-chord/src/chord.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "sRF9");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "mJZf");



function compareValue(compare) {
  return function(a, b) {
    return compare(
      a.source.value + a.target.value,
      b.source.value + b.target.value
    );
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  var padAngle = 0,
      sortGroups = null,
      sortSubgroups = null,
      sortChords = null;

  function chord(matrix) {
    var n = matrix.length,
        groupSums = [],
        groupIndex = Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["range"])(n),
        subgroupIndex = [],
        chords = [],
        groups = chords.groups = new Array(n),
        subgroups = new Array(n * n),
        k,
        x,
        x0,
        dx,
        i,
        j;

    // Compute the sum.
    k = 0, i = -1; while (++i < n) {
      x = 0, j = -1; while (++j < n) {
        x += matrix[i][j];
      }
      groupSums.push(x);
      subgroupIndex.push(Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["range"])(n));
      k += x;
    }

    // Sort groups…
    if (sortGroups) groupIndex.sort(function(a, b) {
      return sortGroups(groupSums[a], groupSums[b]);
    });

    // Sort subgroups…
    if (sortSubgroups) subgroupIndex.forEach(function(d, i) {
      d.sort(function(a, b) {
        return sortSubgroups(matrix[i][a], matrix[i][b]);
      });
    });

    // Convert the sum to scaling factor for [0, 2pi].
    // TODO Allow start and end angle to be specified?
    // TODO Allow padding to be specified as percentage?
    k = Object(_math__WEBPACK_IMPORTED_MODULE_1__["max"])(0, _math__WEBPACK_IMPORTED_MODULE_1__["tau"] - padAngle * n) / k;
    dx = k ? padAngle : _math__WEBPACK_IMPORTED_MODULE_1__["tau"] / n;

    // Compute the start and end angle for each group and subgroup.
    // Note: Opera has a bug reordering object literal properties!
    x = 0, i = -1; while (++i < n) {
      x0 = x, j = -1; while (++j < n) {
        var di = groupIndex[i],
            dj = subgroupIndex[di][j],
            v = matrix[di][dj],
            a0 = x,
            a1 = x += v * k;
        subgroups[dj * n + di] = {
          index: di,
          subindex: dj,
          startAngle: a0,
          endAngle: a1,
          value: v
        };
      }
      groups[di] = {
        index: di,
        startAngle: x0,
        endAngle: x,
        value: groupSums[di]
      };
      x += dx;
    }

    // Generate chords for each (non-empty) subgroup-subgroup link.
    i = -1; while (++i < n) {
      j = i - 1; while (++j < n) {
        var source = subgroups[j * n + i],
            target = subgroups[i * n + j];
        if (source.value || target.value) {
          chords.push(source.value < target.value
              ? {source: target, target: source}
              : {source: source, target: target});
        }
      }
    }

    return sortChords ? chords.sort(sortChords) : chords;
  }

  chord.padAngle = function(_) {
    return arguments.length ? (padAngle = Object(_math__WEBPACK_IMPORTED_MODULE_1__["max"])(0, _), chord) : padAngle;
  };

  chord.sortGroups = function(_) {
    return arguments.length ? (sortGroups = _, chord) : sortGroups;
  };

  chord.sortSubgroups = function(_) {
    return arguments.length ? (sortSubgroups = _, chord) : sortSubgroups;
  };

  chord.sortChords = function(_) {
    return arguments.length ? (_ == null ? sortChords = null : (sortChords = compareValue(_))._ = _, chord) : sortChords && sortChords._;
  };

  return chord;
});


/***/ }),

/***/ "2TRZ":
/*!*******************************************!*\
  !*** ./node_modules/d3-zoom/src/index.js ***!
  \*******************************************/
/*! exports provided: zoom, zoomTransform, zoomIdentity */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _zoom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./zoom.js */ "hkWm");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zoom", function() { return _zoom_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transform.js */ "hjfa");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zoomTransform", function() { return _transform_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zoomIdentity", function() { return _transform_js__WEBPACK_IMPORTED_MODULE_1__["identity"]; });





/***/ }),

/***/ "2YwT":
/*!**********************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/sequential-multi/YlGn.js ***!
  \**********************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors.js */ "ZtE7");
/* harmony import */ var _ramp_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp.js */ "jQWc");



var scheme = new Array(3).concat(
  "f7fcb9addd8e31a354",
  "ffffccc2e69978c679238443",
  "ffffccc2e69978c67931a354006837",
  "ffffccd9f0a3addd8e78c67931a354006837",
  "ffffccd9f0a3addd8e78c67941ab5d238443005a32",
  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32",
  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529"
).map(_colors_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp_js__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "2kEi":
/*!************************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/sequential-multi/YlOrBr.js ***!
  \************************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors.js */ "ZtE7");
/* harmony import */ var _ramp_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp.js */ "jQWc");



var scheme = new Array(3).concat(
  "fff7bcfec44fd95f0e",
  "ffffd4fed98efe9929cc4c02",
  "ffffd4fed98efe9929d95f0e993404",
  "ffffd4fee391fec44ffe9929d95f0e993404",
  "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04",
  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04",
  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506"
).map(_colors_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp_js__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "2oOk":
/*!***********************************************************!*\
  !*** ./node_modules/c3/node_modules/d3-scale/src/nice.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(domain, interval) {
  domain = domain.slice();

  var i0 = 0,
      i1 = domain.length - 1,
      x0 = domain[i0],
      x1 = domain[i1],
      t;

  if (x1 < x0) {
    t = i0, i0 = i1, i1 = t;
    t = x0, x0 = x1, x1 = t;
  }

  domain[i0] = interval.floor(x0);
  domain[i1] = interval.ceil(x1);
  return domain;
});


/***/ }),

/***/ "4Oje":
/*!************************************************************!*\
  !*** ./node_modules/c3/node_modules/d3-scale/src/index.js ***!
  \************************************************************/
/*! exports provided: scaleBand, scalePoint, scaleIdentity, scaleLinear, scaleLog, scaleSymlog, scaleOrdinal, scaleImplicit, scalePow, scaleSqrt, scaleQuantile, scaleQuantize, scaleThreshold, scaleTime, scaleUtc, scaleSequential, scaleSequentialLog, scaleSequentialPow, scaleSequentialSqrt, scaleSequentialSymlog, scaleSequentialQuantile, scaleDiverging, scaleDivergingLog, scaleDivergingPow, scaleDivergingSqrt, scaleDivergingSymlog, tickFormat */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _band__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./band */ "JIJZ");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleBand", function() { return _band__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scalePoint", function() { return _band__WEBPACK_IMPORTED_MODULE_0__["point"]; });

/* harmony import */ var _identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./identity */ "X4w7");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleIdentity", function() { return _identity__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _linear__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./linear */ "hdEp");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleLinear", function() { return _linear__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./log */ "9pWx");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleLog", function() { return _log__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _symlog__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./symlog */ "kvQR");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleSymlog", function() { return _symlog__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _ordinal__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ordinal */ "h8aP");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleOrdinal", function() { return _ordinal__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleImplicit", function() { return _ordinal__WEBPACK_IMPORTED_MODULE_5__["implicit"]; });

/* harmony import */ var _pow__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./pow */ "AyrI");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scalePow", function() { return _pow__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleSqrt", function() { return _pow__WEBPACK_IMPORTED_MODULE_6__["sqrt"]; });

/* harmony import */ var _quantile__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./quantile */ "n/bd");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleQuantile", function() { return _quantile__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _quantize__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./quantize */ "Drdv");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleQuantize", function() { return _quantize__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _threshold__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./threshold */ "FRIb");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleThreshold", function() { return _threshold__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _time__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./time */ "DS9Q");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleTime", function() { return _time__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _utcTime__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./utcTime */ "VsNs");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleUtc", function() { return _utcTime__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony import */ var _sequential__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./sequential */ "4Ztk");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleSequential", function() { return _sequential__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleSequentialLog", function() { return _sequential__WEBPACK_IMPORTED_MODULE_12__["sequentialLog"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleSequentialPow", function() { return _sequential__WEBPACK_IMPORTED_MODULE_12__["sequentialPow"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleSequentialSqrt", function() { return _sequential__WEBPACK_IMPORTED_MODULE_12__["sequentialSqrt"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleSequentialSymlog", function() { return _sequential__WEBPACK_IMPORTED_MODULE_12__["sequentialSymlog"]; });

/* harmony import */ var _sequentialQuantile__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./sequentialQuantile */ "toJ+");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleSequentialQuantile", function() { return _sequentialQuantile__WEBPACK_IMPORTED_MODULE_13__["default"]; });

/* harmony import */ var _diverging__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./diverging */ "TcI5");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleDiverging", function() { return _diverging__WEBPACK_IMPORTED_MODULE_14__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleDivergingLog", function() { return _diverging__WEBPACK_IMPORTED_MODULE_14__["divergingLog"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleDivergingPow", function() { return _diverging__WEBPACK_IMPORTED_MODULE_14__["divergingPow"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleDivergingSqrt", function() { return _diverging__WEBPACK_IMPORTED_MODULE_14__["divergingSqrt"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleDivergingSymlog", function() { return _diverging__WEBPACK_IMPORTED_MODULE_14__["divergingSymlog"]; });

/* harmony import */ var _tickFormat__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./tickFormat */ "zCPI");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tickFormat", function() { return _tickFormat__WEBPACK_IMPORTED_MODULE_15__["default"]; });


































/***/ }),

/***/ "4Ztk":
/*!*****************************************************************!*\
  !*** ./node_modules/c3/node_modules/d3-scale/src/sequential.js ***!
  \*****************************************************************/
/*! exports provided: copy, default, sequentialLog, sequentialSymlog, sequentialPow, sequentialSqrt */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return sequential; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sequentialLog", function() { return sequentialLog; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sequentialSymlog", function() { return sequentialSymlog; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sequentialPow", function() { return sequentialPow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sequentialSqrt", function() { return sequentialSqrt; });
/* harmony import */ var _continuous__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./continuous */ "A24K");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./init */ "//NX");
/* harmony import */ var _linear__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./linear */ "hdEp");
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./log */ "9pWx");
/* harmony import */ var _symlog__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./symlog */ "kvQR");
/* harmony import */ var _pow__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./pow */ "AyrI");







function transformer() {
  var x0 = 0,
      x1 = 1,
      t0,
      t1,
      k10,
      transform,
      interpolator = _continuous__WEBPACK_IMPORTED_MODULE_0__["identity"],
      clamp = false,
      unknown;

  function scale(x) {
    return isNaN(x = +x) ? unknown : interpolator(k10 === 0 ? 0.5 : (x = (transform(x) - t0) * k10, clamp ? Math.max(0, Math.min(1, x)) : x));
  }

  scale.domain = function(_) {
    return arguments.length ? (t0 = transform(x0 = +_[0]), t1 = transform(x1 = +_[1]), k10 = t0 === t1 ? 0 : 1 / (t1 - t0), scale) : [x0, x1];
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = !!_, scale) : clamp;
  };

  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  return function(t) {
    transform = t, t0 = t(x0), t1 = t(x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0);
    return scale;
  };
}

function copy(source, target) {
  return target
      .domain(source.domain())
      .interpolator(source.interpolator())
      .clamp(source.clamp())
      .unknown(source.unknown());
}

function sequential() {
  var scale = Object(_linear__WEBPACK_IMPORTED_MODULE_2__["linearish"])(transformer()(_continuous__WEBPACK_IMPORTED_MODULE_0__["identity"]));

  scale.copy = function() {
    return copy(scale, sequential());
  };

  return _init__WEBPACK_IMPORTED_MODULE_1__["initInterpolator"].apply(scale, arguments);
}

function sequentialLog() {
  var scale = Object(_log__WEBPACK_IMPORTED_MODULE_3__["loggish"])(transformer()).domain([1, 10]);

  scale.copy = function() {
    return copy(scale, sequentialLog()).base(scale.base());
  };

  return _init__WEBPACK_IMPORTED_MODULE_1__["initInterpolator"].apply(scale, arguments);
}

function sequentialSymlog() {
  var scale = Object(_symlog__WEBPACK_IMPORTED_MODULE_4__["symlogish"])(transformer());

  scale.copy = function() {
    return copy(scale, sequentialSymlog()).constant(scale.constant());
  };

  return _init__WEBPACK_IMPORTED_MODULE_1__["initInterpolator"].apply(scale, arguments);
}

function sequentialPow() {
  var scale = Object(_pow__WEBPACK_IMPORTED_MODULE_5__["powish"])(transformer());

  scale.copy = function() {
    return copy(scale, sequentialPow()).exponent(scale.exponent());
  };

  return _init__WEBPACK_IMPORTED_MODULE_1__["initInterpolator"].apply(scale, arguments);
}

function sequentialSqrt() {
  return sequentialPow.apply(null, arguments).exponent(0.5);
}


/***/ }),

/***/ "4jfb":
/*!**************************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/conicConformal.js ***!
  \**************************************************************/
/*! exports provided: conicConformalRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conicConformalRaw", function() { return conicConformalRaw; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "R0y8");
/* harmony import */ var _conic_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./conic.js */ "bN2o");
/* harmony import */ var _mercator_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mercator.js */ "LZ5Q");




function tany(y) {
  return Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["tan"])((_math_js__WEBPACK_IMPORTED_MODULE_0__["halfPi"] + y) / 2);
}

function conicConformalRaw(y0, y1) {
  var cy0 = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["cos"])(y0),
      n = y0 === y1 ? Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sin"])(y0) : Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["log"])(cy0 / Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["cos"])(y1)) / Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["log"])(tany(y1) / tany(y0)),
      f = cy0 * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["pow"])(tany(y0), n) / n;

  if (!n) return _mercator_js__WEBPACK_IMPORTED_MODULE_2__["mercatorRaw"];

  function project(x, y) {
    if (f > 0) { if (y < -_math_js__WEBPACK_IMPORTED_MODULE_0__["halfPi"] + _math_js__WEBPACK_IMPORTED_MODULE_0__["epsilon"]) y = -_math_js__WEBPACK_IMPORTED_MODULE_0__["halfPi"] + _math_js__WEBPACK_IMPORTED_MODULE_0__["epsilon"]; }
    else { if (y > _math_js__WEBPACK_IMPORTED_MODULE_0__["halfPi"] - _math_js__WEBPACK_IMPORTED_MODULE_0__["epsilon"]) y = _math_js__WEBPACK_IMPORTED_MODULE_0__["halfPi"] - _math_js__WEBPACK_IMPORTED_MODULE_0__["epsilon"]; }
    var r = f / Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["pow"])(tany(y), n);
    return [r * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sin"])(n * x), f - r * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["cos"])(n * x)];
  }

  project.invert = function(x, y) {
    var fy = f - y, r = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sign"])(n) * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(x * x + fy * fy),
      l = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["atan2"])(x, Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["abs"])(fy)) * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sign"])(fy);
    if (fy * n < 0)
      l -= _math_js__WEBPACK_IMPORTED_MODULE_0__["pi"] * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sign"])(x) * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sign"])(fy);
    return [l / n, 2 * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["atan"])(Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["pow"])(f / r, 1 / n)) - _math_js__WEBPACK_IMPORTED_MODULE_0__["halfPi"]];
  };

  return project;
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  return Object(_conic_js__WEBPACK_IMPORTED_MODULE_1__["conicProjection"])(conicConformalRaw)
      .scale(109.5)
      .parallels([30, 30]);
});


/***/ }),

/***/ "5/wc":
/*!************************************************!*\
  !*** ./node_modules/d3-geo/src/clip/extent.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _rectangle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rectangle.js */ "F2eR");


/* harmony default export */ __webpack_exports__["default"] = (function() {
  var x0 = 0,
      y0 = 0,
      x1 = 960,
      y1 = 500,
      cache,
      cacheStream,
      clip;

  return clip = {
    stream: function(stream) {
      return cache && cacheStream === stream ? cache : cache = Object(_rectangle_js__WEBPACK_IMPORTED_MODULE_0__["default"])(x0, y0, x1, y1)(cacheStream = stream);
    },
    extent: function(_) {
      return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], cache = cacheStream = null, clip) : [[x0, y0], [x1, y1]];
    }
  };
});


/***/ }),

/***/ "50A1":
/*!***********************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/sequential-single/Reds.js ***!
  \***********************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors.js */ "ZtE7");
/* harmony import */ var _ramp_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp.js */ "jQWc");



var scheme = new Array(3).concat(
  "fee0d2fc9272de2d26",
  "fee5d9fcae91fb6a4acb181d",
  "fee5d9fcae91fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d"
).map(_colors_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp_js__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "5D8y":
/*!**************************************************!*\
  !*** ./node_modules/d3-geo/src/path/centroid.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "R0y8");


// TODO Enforce positive area for exterior, negative area for interior?

var X0 = 0,
    Y0 = 0,
    Z0 = 0,
    X1 = 0,
    Y1 = 0,
    Z1 = 0,
    X2 = 0,
    Y2 = 0,
    Z2 = 0,
    x00,
    y00,
    x0,
    y0;

var centroidStream = {
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function() {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function() {
    centroidStream.point = centroidPoint;
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  },
  result: function() {
    var centroid = Z2 ? [X2 / Z2, Y2 / Z2]
        : Z1 ? [X1 / Z1, Y1 / Z1]
        : Z0 ? [X0 / Z0, Y0 / Z0]
        : [NaN, NaN];
    X0 = Y0 = Z0 =
    X1 = Y1 = Z1 =
    X2 = Y2 = Z2 = 0;
    return centroid;
  }
};

function centroidPoint(x, y) {
  X0 += x;
  Y0 += y;
  ++Z0;
}

function centroidLineStart() {
  centroidStream.point = centroidPointFirstLine;
}

function centroidPointFirstLine(x, y) {
  centroidStream.point = centroidPointLine;
  centroidPoint(x0 = x, y0 = y);
}

function centroidPointLine(x, y) {
  var dx = x - x0, dy = y - y0, z = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(dx * dx + dy * dy);
  X1 += z * (x0 + x) / 2;
  Y1 += z * (y0 + y) / 2;
  Z1 += z;
  centroidPoint(x0 = x, y0 = y);
}

function centroidLineEnd() {
  centroidStream.point = centroidPoint;
}

function centroidRingStart() {
  centroidStream.point = centroidPointFirstRing;
}

function centroidRingEnd() {
  centroidPointRing(x00, y00);
}

function centroidPointFirstRing(x, y) {
  centroidStream.point = centroidPointRing;
  centroidPoint(x00 = x0 = x, y00 = y0 = y);
}

function centroidPointRing(x, y) {
  var dx = x - x0,
      dy = y - y0,
      z = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(dx * dx + dy * dy);

  X1 += z * (x0 + x) / 2;
  Y1 += z * (y0 + y) / 2;
  Z1 += z;

  z = y0 * x - x0 * y;
  X2 += z * (x0 + x);
  Y2 += z * (y0 + y);
  Z2 += z * 3;
  centroidPoint(x0 = x, y0 = y);
}

/* harmony default export */ __webpack_exports__["default"] = (centroidStream);


/***/ }),

/***/ "5bIW":
/*!************************************************************!*\
  !*** ./node_modules/c3/node_modules/d3-array/src/ticks.js ***!
  \************************************************************/
/*! exports provided: default, tickIncrement, tickStep */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tickIncrement", function() { return tickIncrement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tickStep", function() { return tickStep; });
var e10 = Math.sqrt(50),
    e5 = Math.sqrt(10),
    e2 = Math.sqrt(2);

/* harmony default export */ __webpack_exports__["default"] = (function(start, stop, count) {
  var reverse,
      i = -1,
      n,
      ticks,
      step;

  stop = +stop, start = +start, count = +count;
  if (start === stop && count > 0) return [start];
  if (reverse = stop < start) n = start, start = stop, stop = n;
  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

  if (step > 0) {
    start = Math.ceil(start / step);
    stop = Math.floor(stop / step);
    ticks = new Array(n = Math.ceil(stop - start + 1));
    while (++i < n) ticks[i] = (start + i) * step;
  } else {
    start = Math.floor(start * step);
    stop = Math.ceil(stop * step);
    ticks = new Array(n = Math.ceil(start - stop + 1));
    while (++i < n) ticks[i] = (start - i) / step;
  }

  if (reverse) ticks.reverse();

  return ticks;
});

function tickIncrement(start, stop, count) {
  var step = (stop - start) / Math.max(0, count),
      power = Math.floor(Math.log(step) / Math.LN10),
      error = step / Math.pow(10, power);
  return power >= 0
      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}

function tickStep(start, stop, count) {
  var step0 = Math.abs(stop - start) / Math.max(0, count),
      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
      error = step0 / step1;
  if (error >= e10) step1 *= 10;
  else if (error >= e5) step1 *= 5;
  else if (error >= e2) step1 *= 2;
  return stop < start ? -step1 : step1;
}


/***/ }),

/***/ "5xK/":
/*!************************************************!*\
  !*** ./node_modules/d3-geo/src/clip/rejoin.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _pointEqual_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../pointEqual.js */ "fnXD");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math.js */ "R0y8");



function Intersection(point, points, other, entry) {
  this.x = point;
  this.z = points;
  this.o = other; // another intersection
  this.e = entry; // is an entry?
  this.v = false; // visited
  this.n = this.p = null; // next & previous
}

// A generalized polygon clipping algorithm: given a polygon that has been cut
// into its visible line segments, and rejoins the segments by interpolating
// along the clip edge.
/* harmony default export */ __webpack_exports__["default"] = (function(segments, compareIntersection, startInside, interpolate, stream) {
  var subject = [],
      clip = [],
      i,
      n;

  segments.forEach(function(segment) {
    if ((n = segment.length - 1) <= 0) return;
    var n, p0 = segment[0], p1 = segment[n], x;

    if (Object(_pointEqual_js__WEBPACK_IMPORTED_MODULE_0__["default"])(p0, p1)) {
      if (!p0[2] && !p1[2]) {
        stream.lineStart();
        for (i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);
        stream.lineEnd();
        return;
      }
      // handle degenerate cases by moving the point
      p1[0] += 2 * _math_js__WEBPACK_IMPORTED_MODULE_1__["epsilon"];
    }

    subject.push(x = new Intersection(p0, segment, null, true));
    clip.push(x.o = new Intersection(p0, null, x, false));
    subject.push(x = new Intersection(p1, segment, null, false));
    clip.push(x.o = new Intersection(p1, null, x, true));
  });

  if (!subject.length) return;

  clip.sort(compareIntersection);
  link(subject);
  link(clip);

  for (i = 0, n = clip.length; i < n; ++i) {
    clip[i].e = startInside = !startInside;
  }

  var start = subject[0],
      points,
      point;

  while (1) {
    // Find first unvisited intersection.
    var current = start,
        isSubject = true;
    while (current.v) if ((current = current.n) === start) return;
    points = current.z;
    stream.lineStart();
    do {
      current.v = current.o.v = true;
      if (current.e) {
        if (isSubject) {
          for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);
        } else {
          interpolate(current.x, current.n.x, 1, stream);
        }
        current = current.n;
      } else {
        if (isSubject) {
          points = current.p.z;
          for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);
        } else {
          interpolate(current.x, current.p.x, -1, stream);
        }
        current = current.p;
      }
      current = current.o;
      points = current.z;
      isSubject = !isSubject;
    } while (!current.v);
    stream.lineEnd();
  }
});

function link(array) {
  if (!(n = array.length)) return;
  var n,
      i = 0,
      a = array[0],
      b;
  while (++i < n) {
    a.n = b = array[i];
    b.p = a;
    a = b;
  }
  a.n = b = array[0];
  b.p = a;
}


/***/ }),

/***/ "6yeX":
/*!**************************************************************************!*\
  !*** ./node_modules/c3/node_modules/d3/node_modules/d3-dsv/src/index.js ***!
  \**************************************************************************/
/*! exports provided: dsvFormat, csvParse, csvParseRows, csvFormat, csvFormatBody, csvFormatRows, csvFormatRow, csvFormatValue, tsvParse, tsvParseRows, tsvFormat, tsvFormatBody, tsvFormatRows, tsvFormatRow, tsvFormatValue, autoType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _dsv_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dsv.js */ "eha6");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dsvFormat", function() { return _dsv_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _csv_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./csv.js */ "kbsf");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "csvParse", function() { return _csv_js__WEBPACK_IMPORTED_MODULE_1__["csvParse"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "csvParseRows", function() { return _csv_js__WEBPACK_IMPORTED_MODULE_1__["csvParseRows"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "csvFormat", function() { return _csv_js__WEBPACK_IMPORTED_MODULE_1__["csvFormat"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "csvFormatBody", function() { return _csv_js__WEBPACK_IMPORTED_MODULE_1__["csvFormatBody"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "csvFormatRows", function() { return _csv_js__WEBPACK_IMPORTED_MODULE_1__["csvFormatRows"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "csvFormatRow", function() { return _csv_js__WEBPACK_IMPORTED_MODULE_1__["csvFormatRow"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "csvFormatValue", function() { return _csv_js__WEBPACK_IMPORTED_MODULE_1__["csvFormatValue"]; });

/* harmony import */ var _tsv_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tsv.js */ "AhOu");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tsvParse", function() { return _tsv_js__WEBPACK_IMPORTED_MODULE_2__["tsvParse"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tsvParseRows", function() { return _tsv_js__WEBPACK_IMPORTED_MODULE_2__["tsvParseRows"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tsvFormat", function() { return _tsv_js__WEBPACK_IMPORTED_MODULE_2__["tsvFormat"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tsvFormatBody", function() { return _tsv_js__WEBPACK_IMPORTED_MODULE_2__["tsvFormatBody"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tsvFormatRows", function() { return _tsv_js__WEBPACK_IMPORTED_MODULE_2__["tsvFormatRows"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tsvFormatRow", function() { return _tsv_js__WEBPACK_IMPORTED_MODULE_2__["tsvFormatRow"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tsvFormatValue", function() { return _tsv_js__WEBPACK_IMPORTED_MODULE_2__["tsvFormatValue"]; });

/* harmony import */ var _autoType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./autoType.js */ "s3OU");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "autoType", function() { return _autoType_js__WEBPACK_IMPORTED_MODULE_3__["default"]; });







/***/ }),

/***/ "7FHc":
/*!****************************************************!*\
  !*** ./node_modules/d3-geo/src/polygonContains.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _adder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./adder.js */ "uCr6");
/* harmony import */ var _cartesian_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cartesian.js */ "YzSS");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math.js */ "R0y8");




var sum = Object(_adder_js__WEBPACK_IMPORTED_MODULE_0__["default"])();

function longitude(point) {
  if (Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["abs"])(point[0]) <= _math_js__WEBPACK_IMPORTED_MODULE_2__["pi"])
    return point[0];
  else
    return Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["sign"])(point[0]) * ((Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["abs"])(point[0]) + _math_js__WEBPACK_IMPORTED_MODULE_2__["pi"]) % _math_js__WEBPACK_IMPORTED_MODULE_2__["tau"] - _math_js__WEBPACK_IMPORTED_MODULE_2__["pi"]);
}

/* harmony default export */ __webpack_exports__["default"] = (function(polygon, point) {
  var lambda = longitude(point),
      phi = point[1],
      sinPhi = Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["sin"])(phi),
      normal = [Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["sin"])(lambda), -Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["cos"])(lambda), 0],
      angle = 0,
      winding = 0;

  sum.reset();

  if (sinPhi === 1) phi = _math_js__WEBPACK_IMPORTED_MODULE_2__["halfPi"] + _math_js__WEBPACK_IMPORTED_MODULE_2__["epsilon"];
  else if (sinPhi === -1) phi = -_math_js__WEBPACK_IMPORTED_MODULE_2__["halfPi"] - _math_js__WEBPACK_IMPORTED_MODULE_2__["epsilon"];

  for (var i = 0, n = polygon.length; i < n; ++i) {
    if (!(m = (ring = polygon[i]).length)) continue;
    var ring,
        m,
        point0 = ring[m - 1],
        lambda0 = longitude(point0),
        phi0 = point0[1] / 2 + _math_js__WEBPACK_IMPORTED_MODULE_2__["quarterPi"],
        sinPhi0 = Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["sin"])(phi0),
        cosPhi0 = Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["cos"])(phi0);

    for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
      var point1 = ring[j],
          lambda1 = longitude(point1),
          phi1 = point1[1] / 2 + _math_js__WEBPACK_IMPORTED_MODULE_2__["quarterPi"],
          sinPhi1 = Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["sin"])(phi1),
          cosPhi1 = Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["cos"])(phi1),
          delta = lambda1 - lambda0,
          sign = delta >= 0 ? 1 : -1,
          absDelta = sign * delta,
          antimeridian = absDelta > _math_js__WEBPACK_IMPORTED_MODULE_2__["pi"],
          k = sinPhi0 * sinPhi1;

      sum.add(Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["atan2"])(k * sign * Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["sin"])(absDelta), cosPhi0 * cosPhi1 + k * Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["cos"])(absDelta)));
      angle += antimeridian ? delta + sign * _math_js__WEBPACK_IMPORTED_MODULE_2__["tau"] : delta;

      // Are the longitudes either side of the point’s meridian (lambda),
      // and are the latitudes smaller than the parallel (phi)?
      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
        var arc = Object(_cartesian_js__WEBPACK_IMPORTED_MODULE_1__["cartesianCross"])(Object(_cartesian_js__WEBPACK_IMPORTED_MODULE_1__["cartesian"])(point0), Object(_cartesian_js__WEBPACK_IMPORTED_MODULE_1__["cartesian"])(point1));
        Object(_cartesian_js__WEBPACK_IMPORTED_MODULE_1__["cartesianNormalizeInPlace"])(arc);
        var intersection = Object(_cartesian_js__WEBPACK_IMPORTED_MODULE_1__["cartesianCross"])(normal, arc);
        Object(_cartesian_js__WEBPACK_IMPORTED_MODULE_1__["cartesianNormalizeInPlace"])(intersection);
        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["asin"])(intersection[2]);
        if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
          winding += antimeridian ^ delta >= 0 ? 1 : -1;
        }
      }
    }
  }

  // First, determine whether the South pole is inside or outside:
  //
  // It is inside if:
  // * the polygon winds around it in a clockwise direction.
  // * the polygon does not (cumulatively) wind around it, but has a negative
  //   (counter-clockwise) area.
  //
  // Second, count the (signed) number of times a segment crosses a lambda
  // from the point to the South pole.  If it is zero, then the point is the
  // same side as the South pole.

  return (angle < -_math_js__WEBPACK_IMPORTED_MODULE_2__["epsilon"] || angle < _math_js__WEBPACK_IMPORTED_MODULE_2__["epsilon"] && sum < -_math_js__WEBPACK_IMPORTED_MODULE_2__["epsilon"]) ^ (winding & 1);
});


/***/ }),

/***/ "7MRl":
/*!*********************************************!*\
  !*** ./node_modules/d3-random/src/index.js ***!
  \*********************************************/
/*! exports provided: randomUniform, randomNormal, randomLogNormal, randomBates, randomIrwinHall, randomExponential */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _uniform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./uniform */ "NScU");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "randomUniform", function() { return _uniform__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _normal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./normal */ "ptze");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "randomNormal", function() { return _normal__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _logNormal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./logNormal */ "G4XB");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "randomLogNormal", function() { return _logNormal__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _bates__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./bates */ "XJJ9");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "randomBates", function() { return _bates__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _irwinHall__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./irwinHall */ "hSnb");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "randomIrwinHall", function() { return _irwinHall__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _exponential__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./exponential */ "eTLM");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "randomExponential", function() { return _exponential__WEBPACK_IMPORTED_MODULE_5__["default"]; });









/***/ }),

/***/ "7NYn":
/*!*******************************************!*\
  !*** ./node_modules/d3-fetch/src/text.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function responseText(response) {
  if (!response.ok) throw new Error(response.status + " " + response.statusText);
  return response.text();
}

/* harmony default export */ __webpack_exports__["default"] = (function(input, init) {
  return fetch(input, init).then(responseText);
});


/***/ }),

/***/ "8+1p":
/*!****************************************************************!*\
  !*** ./node_modules/c3/node_modules/d3-array/src/histogram.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array */ "yhNL");
/* harmony import */ var _bisect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bisect */ "otsO");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constant */ "XTLa");
/* harmony import */ var _extent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./extent */ "oORo");
/* harmony import */ var _identity__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./identity */ "WmoW");
/* harmony import */ var _range__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./range */ "qKBD");
/* harmony import */ var _ticks__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ticks */ "5bIW");
/* harmony import */ var _threshold_sturges__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./threshold/sturges */ "NvdV");









/* harmony default export */ __webpack_exports__["default"] = (function() {
  var value = _identity__WEBPACK_IMPORTED_MODULE_4__["default"],
      domain = _extent__WEBPACK_IMPORTED_MODULE_3__["default"],
      threshold = _threshold_sturges__WEBPACK_IMPORTED_MODULE_7__["default"];

  function histogram(data) {
    var i,
        n = data.length,
        x,
        values = new Array(n);

    for (i = 0; i < n; ++i) {
      values[i] = value(data[i], i, data);
    }

    var xz = domain(values),
        x0 = xz[0],
        x1 = xz[1],
        tz = threshold(values, x0, x1);

    // Convert number of thresholds into uniform thresholds.
    if (!Array.isArray(tz)) {
      tz = Object(_ticks__WEBPACK_IMPORTED_MODULE_6__["tickStep"])(x0, x1, tz);
      tz = Object(_range__WEBPACK_IMPORTED_MODULE_5__["default"])(Math.ceil(x0 / tz) * tz, x1, tz); // exclusive
    }

    // Remove any thresholds outside the domain.
    var m = tz.length;
    while (tz[0] <= x0) tz.shift(), --m;
    while (tz[m - 1] > x1) tz.pop(), --m;

    var bins = new Array(m + 1),
        bin;

    // Initialize bins.
    for (i = 0; i <= m; ++i) {
      bin = bins[i] = [];
      bin.x0 = i > 0 ? tz[i - 1] : x0;
      bin.x1 = i < m ? tz[i] : x1;
    }

    // Assign data to bins by value, ignoring any outside the domain.
    for (i = 0; i < n; ++i) {
      x = values[i];
      if (x0 <= x && x <= x1) {
        bins[Object(_bisect__WEBPACK_IMPORTED_MODULE_1__["default"])(tz, x, 0, m)].push(data[i]);
      }
    }

    return bins;
  }

  histogram.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_2__["default"])(_), histogram) : value;
  };

  histogram.domain = function(_) {
    return arguments.length ? (domain = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_2__["default"])([_[0], _[1]]), histogram) : domain;
  };

  histogram.thresholds = function(_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? Object(_constant__WEBPACK_IMPORTED_MODULE_2__["default"])(_array__WEBPACK_IMPORTED_MODULE_0__["slice"].call(_)) : Object(_constant__WEBPACK_IMPORTED_MODULE_2__["default"])(_), histogram) : threshold;
  };

  return histogram;
});


/***/ }),

/***/ "81I8":
/*!***************************************************************!*\
  !*** ./node_modules/c3/node_modules/d3-scale/src/constant.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return function() {
    return x;
  };
});


/***/ }),

/***/ "89eD":
/*!*******************************************!*\
  !*** ./node_modules/d3-force/src/link.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant */ "nXVj");
/* harmony import */ var _jiggle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./jiggle */ "QupR");
/* harmony import */ var d3_collection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-collection */ "bwSX");




function index(d) {
  return d.index;
}

function find(nodeById, nodeId) {
  var node = nodeById.get(nodeId);
  if (!node) throw new Error("missing: " + nodeId);
  return node;
}

/* harmony default export */ __webpack_exports__["default"] = (function(links) {
  var id = index,
      strength = defaultStrength,
      strengths,
      distance = Object(_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(30),
      distances,
      nodes,
      count,
      bias,
      iterations = 1;

  if (links == null) links = [];

  function defaultStrength(link) {
    return 1 / Math.min(count[link.source.index], count[link.target.index]);
  }

  function force(alpha) {
    for (var k = 0, n = links.length; k < iterations; ++k) {
      for (var i = 0, link, source, target, x, y, l, b; i < n; ++i) {
        link = links[i], source = link.source, target = link.target;
        x = target.x + target.vx - source.x - source.vx || Object(_jiggle__WEBPACK_IMPORTED_MODULE_1__["default"])();
        y = target.y + target.vy - source.y - source.vy || Object(_jiggle__WEBPACK_IMPORTED_MODULE_1__["default"])();
        l = Math.sqrt(x * x + y * y);
        l = (l - distances[i]) / l * alpha * strengths[i];
        x *= l, y *= l;
        target.vx -= x * (b = bias[i]);
        target.vy -= y * b;
        source.vx += x * (b = 1 - b);
        source.vy += y * b;
      }
    }
  }

  function initialize() {
    if (!nodes) return;

    var i,
        n = nodes.length,
        m = links.length,
        nodeById = Object(d3_collection__WEBPACK_IMPORTED_MODULE_2__["map"])(nodes, id),
        link;

    for (i = 0, count = new Array(n); i < m; ++i) {
      link = links[i], link.index = i;
      if (typeof link.source !== "object") link.source = find(nodeById, link.source);
      if (typeof link.target !== "object") link.target = find(nodeById, link.target);
      count[link.source.index] = (count[link.source.index] || 0) + 1;
      count[link.target.index] = (count[link.target.index] || 0) + 1;
    }

    for (i = 0, bias = new Array(m); i < m; ++i) {
      link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);
    }

    strengths = new Array(m), initializeStrength();
    distances = new Array(m), initializeDistance();
  }

  function initializeStrength() {
    if (!nodes) return;

    for (var i = 0, n = links.length; i < n; ++i) {
      strengths[i] = +strength(links[i], i, links);
    }
  }

  function initializeDistance() {
    if (!nodes) return;

    for (var i = 0, n = links.length; i < n; ++i) {
      distances[i] = +distance(links[i], i, links);
    }
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.links = function(_) {
    return arguments.length ? (links = _, initialize(), force) : links;
  };

  force.id = function(_) {
    return arguments.length ? (id = _, force) : id;
  };

  force.iterations = function(_) {
    return arguments.length ? (iterations = +_, force) : iterations;
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), initializeStrength(), force) : strength;
  };

  force.distance = function(_) {
    return arguments.length ? (distance = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), initializeDistance(), force) : distance;
  };

  return force;
});


/***/ }),

/***/ "8F7Y":
/*!**********************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/sequential-multi/GnBu.js ***!
  \**********************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors.js */ "ZtE7");
/* harmony import */ var _ramp_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp.js */ "jQWc");



var scheme = new Array(3).concat(
  "e0f3dba8ddb543a2ca",
  "f0f9e8bae4bc7bccc42b8cbe",
  "f0f9e8bae4bc7bccc443a2ca0868ac",
  "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac",
  "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e",
  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e",
  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081"
).map(_colors_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp_js__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "8cru":
/*!******************************************!*\
  !*** ./node_modules/d3-fetch/src/dsv.js ***!
  \******************************************/
/*! exports provided: default, csv, tsv */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return dsv; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "csv", function() { return csv; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tsv", function() { return tsv; });
/* harmony import */ var d3_dsv__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-dsv */ "6yeX");
/* harmony import */ var _text_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./text.js */ "7NYn");



function dsvParse(parse) {
  return function(input, init, row) {
    if (arguments.length === 2 && typeof init === "function") row = init, init = undefined;
    return Object(_text_js__WEBPACK_IMPORTED_MODULE_1__["default"])(input, init).then(function(response) {
      return parse(response, row);
    });
  };
}

function dsv(delimiter, input, init, row) {
  if (arguments.length === 3 && typeof init === "function") row = init, init = undefined;
  var format = Object(d3_dsv__WEBPACK_IMPORTED_MODULE_0__["dsvFormat"])(delimiter);
  return Object(_text_js__WEBPACK_IMPORTED_MODULE_1__["default"])(input, init).then(function(response) {
    return format.parse(response, row);
  });
}

var csv = dsvParse(d3_dsv__WEBPACK_IMPORTED_MODULE_0__["csvParse"]);
var tsv = dsvParse(d3_dsv__WEBPACK_IMPORTED_MODULE_0__["tsvParse"]);


/***/ }),

/***/ "8efb":
/*!********************************************!*\
  !*** ./node_modules/d3-chord/src/array.js ***!
  \********************************************/
/*! exports provided: slice */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slice", function() { return slice; });
var slice = Array.prototype.slice;


/***/ }),

/***/ "8moF":
/*!******************************************!*\
  !*** ./node_modules/d3-fetch/src/xml.js ***!
  \******************************************/
/*! exports provided: default, html, svg */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "html", function() { return html; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "svg", function() { return svg; });
/* harmony import */ var _text_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./text.js */ "7NYn");


function parser(type) {
  return function(input, init)  {
    return Object(_text_js__WEBPACK_IMPORTED_MODULE_0__["default"])(input, init).then(function(text) {
      return (new DOMParser).parseFromString(text, type);
    });
  };
}

/* harmony default export */ __webpack_exports__["default"] = (parser("application/xml"));

var html = parser("text/html");

var svg = parser("image/svg+xml");


/***/ }),

/***/ "8nOX":
/*!*************************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/naturalEarth1.js ***!
  \*************************************************************/
/*! exports provided: naturalEarth1Raw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "naturalEarth1Raw", function() { return naturalEarth1Raw; });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "1ibS");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math.js */ "R0y8");



function naturalEarth1Raw(lambda, phi) {
  var phi2 = phi * phi, phi4 = phi2 * phi2;
  return [
    lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (0.003971 * phi2 - 0.001529 * phi4))),
    phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4)))
  ];
}

naturalEarth1Raw.invert = function(x, y) {
  var phi = y, i = 25, delta;
  do {
    var phi2 = phi * phi, phi4 = phi2 * phi2;
    phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4))) - y) /
        (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 0.005916 * 11 * phi4)));
  } while (Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["abs"])(delta) > _math_js__WEBPACK_IMPORTED_MODULE_1__["epsilon"] && --i > 0);
  return [
    x / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (0.003971 - 0.001529 * phi2)))),
    phi
  ];
};

/* harmony default export */ __webpack_exports__["default"] = (function() {
  return Object(_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(naturalEarth1Raw)
      .scale(175.295);
});


/***/ }),

/***/ "96UZ":
/*!**********************************************************************!*\
  !*** ./node_modules/c3/node_modules/d3-array/src/threshold/scott.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _deviation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../deviation */ "amxm");


/* harmony default export */ __webpack_exports__["default"] = (function(values, min, max) {
  return Math.ceil((max - min) / (3.5 * Object(_deviation__WEBPACK_IMPORTED_MODULE_0__["default"])(values) * Math.pow(values.length, -1 / 3)));
});


/***/ }),

/***/ "9ABZ":
/*!***********************************************!*\
  !*** ./node_modules/d3-quadtree/src/cover.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x, y) {
  if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points

  var x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1;

  // If the quadtree has no extent, initialize them.
  // Integer extent are necessary so that if we later double the extent,
  // the existing quadrant boundaries don’t change due to floating point error!
  if (isNaN(x0)) {
    x1 = (x0 = Math.floor(x)) + 1;
    y1 = (y0 = Math.floor(y)) + 1;
  }

  // Otherwise, double repeatedly to cover.
  else {
    var z = x1 - x0,
        node = this._root,
        parent,
        i;

    while (x0 > x || x >= x1 || y0 > y || y >= y1) {
      i = (y < y0) << 1 | (x < x0);
      parent = new Array(4), parent[i] = node, node = parent, z *= 2;
      switch (i) {
        case 0: x1 = x0 + z, y1 = y0 + z; break;
        case 1: x0 = x1 - z, y1 = y0 + z; break;
        case 2: x1 = x0 + z, y0 = y1 - z; break;
        case 3: x0 = x1 - z, y0 = y1 - z; break;
      }
    }

    if (this._root && this._root.length) this._root = node;
  }

  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  return this;
});


/***/ }),

/***/ "9ZWv":
/*!******************************************************!*\
  !*** ./node_modules/d3-geo/src/clip/antimeridian.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "pb3N");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math.js */ "R0y8");



/* harmony default export */ __webpack_exports__["default"] = (Object(_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(
  function() { return true; },
  clipAntimeridianLine,
  clipAntimeridianInterpolate,
  [-_math_js__WEBPACK_IMPORTED_MODULE_1__["pi"], -_math_js__WEBPACK_IMPORTED_MODULE_1__["halfPi"]]
));

// Takes a line and cuts into visible segments. Return values: 0 - there were
// intersections or the line was empty; 1 - no intersections; 2 - there were
// intersections, and the first and last segments should be rejoined.
function clipAntimeridianLine(stream) {
  var lambda0 = NaN,
      phi0 = NaN,
      sign0 = NaN,
      clean; // no intersections

  return {
    lineStart: function() {
      stream.lineStart();
      clean = 1;
    },
    point: function(lambda1, phi1) {
      var sign1 = lambda1 > 0 ? _math_js__WEBPACK_IMPORTED_MODULE_1__["pi"] : -_math_js__WEBPACK_IMPORTED_MODULE_1__["pi"],
          delta = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["abs"])(lambda1 - lambda0);
      if (Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["abs"])(delta - _math_js__WEBPACK_IMPORTED_MODULE_1__["pi"]) < _math_js__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) { // line crosses a pole
        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? _math_js__WEBPACK_IMPORTED_MODULE_1__["halfPi"] : -_math_js__WEBPACK_IMPORTED_MODULE_1__["halfPi"]);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        stream.point(lambda1, phi0);
        clean = 0;
      } else if (sign0 !== sign1 && delta >= _math_js__WEBPACK_IMPORTED_MODULE_1__["pi"]) { // line crosses antimeridian
        if (Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["abs"])(lambda0 - sign0) < _math_js__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) lambda0 -= sign0 * _math_js__WEBPACK_IMPORTED_MODULE_1__["epsilon"]; // handle degeneracies
        if (Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["abs"])(lambda1 - sign1) < _math_js__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) lambda1 -= sign1 * _math_js__WEBPACK_IMPORTED_MODULE_1__["epsilon"];
        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        clean = 0;
      }
      stream.point(lambda0 = lambda1, phi0 = phi1);
      sign0 = sign1;
    },
    lineEnd: function() {
      stream.lineEnd();
      lambda0 = phi0 = NaN;
    },
    clean: function() {
      return 2 - clean; // if intersections, rejoin first and last segments
    }
  };
}

function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
  var cosPhi0,
      cosPhi1,
      sinLambda0Lambda1 = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["sin"])(lambda0 - lambda1);
  return Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["abs"])(sinLambda0Lambda1) > _math_js__WEBPACK_IMPORTED_MODULE_1__["epsilon"]
      ? Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["atan"])((Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi0) * (cosPhi1 = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi1)) * Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["sin"])(lambda1)
          - Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi1) * (cosPhi0 = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi0)) * Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["sin"])(lambda0))
          / (cosPhi0 * cosPhi1 * sinLambda0Lambda1))
      : (phi0 + phi1) / 2;
}

function clipAntimeridianInterpolate(from, to, direction, stream) {
  var phi;
  if (from == null) {
    phi = direction * _math_js__WEBPACK_IMPORTED_MODULE_1__["halfPi"];
    stream.point(-_math_js__WEBPACK_IMPORTED_MODULE_1__["pi"], phi);
    stream.point(0, phi);
    stream.point(_math_js__WEBPACK_IMPORTED_MODULE_1__["pi"], phi);
    stream.point(_math_js__WEBPACK_IMPORTED_MODULE_1__["pi"], 0);
    stream.point(_math_js__WEBPACK_IMPORTED_MODULE_1__["pi"], -phi);
    stream.point(0, -phi);
    stream.point(-_math_js__WEBPACK_IMPORTED_MODULE_1__["pi"], -phi);
    stream.point(-_math_js__WEBPACK_IMPORTED_MODULE_1__["pi"], 0);
    stream.point(-_math_js__WEBPACK_IMPORTED_MODULE_1__["pi"], phi);
  } else if (Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["abs"])(from[0] - to[0]) > _math_js__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) {
    var lambda = from[0] < to[0] ? _math_js__WEBPACK_IMPORTED_MODULE_1__["pi"] : -_math_js__WEBPACK_IMPORTED_MODULE_1__["pi"];
    phi = direction * lambda / 2;
    stream.point(-lambda, phi);
    stream.point(0, phi);
    stream.point(lambda, phi);
  } else {
    stream.point(to[0], to[1]);
  }
}


/***/ }),

/***/ "9l1u":
/*!*********************************************!*\
  !*** ./node_modules/d3-quadtree/src/add.js ***!
  \*********************************************/
/*! exports provided: default, addAll */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addAll", function() { return addAll; });
/* harmony default export */ __webpack_exports__["default"] = (function(d) {
  var x = +this._x.call(null, d),
      y = +this._y.call(null, d);
  return add(this.cover(x, y), x, y, d);
});

function add(tree, x, y, d) {
  if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points

  var parent,
      node = tree._root,
      leaf = {data: d},
      x0 = tree._x0,
      y0 = tree._y0,
      x1 = tree._x1,
      y1 = tree._y1,
      xm,
      ym,
      xp,
      yp,
      right,
      bottom,
      i,
      j;

  // If the tree is empty, initialize the root as a leaf.
  if (!node) return tree._root = leaf, tree;

  // Find the existing leaf for the new point, or add it.
  while (node.length) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
    if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;
  }

  // Is the new point is exactly coincident with the existing point?
  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;

  // Otherwise, split the leaf node until the old and new point are separated.
  do {
    parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
  } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));
  return parent[j] = node, parent[i] = leaf, tree;
}

function addAll(data) {
  var d, i, n = data.length,
      x,
      y,
      xz = new Array(n),
      yz = new Array(n),
      x0 = Infinity,
      y0 = Infinity,
      x1 = -Infinity,
      y1 = -Infinity;

  // Compute the points and their extent.
  for (i = 0; i < n; ++i) {
    if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;
    xz[i] = x;
    yz[i] = y;
    if (x < x0) x0 = x;
    if (x > x1) x1 = x;
    if (y < y0) y0 = y;
    if (y > y1) y1 = y;
  }

  // If there were no (valid) points, abort.
  if (x0 > x1 || y0 > y1) return this;

  // Expand the tree to cover the new points.
  this.cover(x0, y0).cover(x1, y1);

  // Add the new points.
  for (i = 0; i < n; ++i) {
    add(this, xz[i], yz[i], data[i]);
  }

  return this;
}


/***/ }),

/***/ "9pWx":
/*!**********************************************************!*\
  !*** ./node_modules/c3/node_modules/d3-scale/src/log.js ***!
  \**********************************************************/
/*! exports provided: loggish, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loggish", function() { return loggish; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return log; });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "sRF9");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-format */ "rWgG");
/* harmony import */ var _nice__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./nice */ "2oOk");
/* harmony import */ var _continuous__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./continuous */ "A24K");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./init */ "//NX");






function transformLog(x) {
  return Math.log(x);
}

function transformExp(x) {
  return Math.exp(x);
}

function transformLogn(x) {
  return -Math.log(-x);
}

function transformExpn(x) {
  return -Math.exp(-x);
}

function pow10(x) {
  return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
}

function powp(base) {
  return base === 10 ? pow10
      : base === Math.E ? Math.exp
      : function(x) { return Math.pow(base, x); };
}

function logp(base) {
  return base === Math.E ? Math.log
      : base === 10 && Math.log10
      || base === 2 && Math.log2
      || (base = Math.log(base), function(x) { return Math.log(x) / base; });
}

function reflect(f) {
  return function(x) {
    return -f(-x);
  };
}

function loggish(transform) {
  var scale = transform(transformLog, transformExp),
      domain = scale.domain,
      base = 10,
      logs,
      pows;

  function rescale() {
    logs = logp(base), pows = powp(base);
    if (domain()[0] < 0) {
      logs = reflect(logs), pows = reflect(pows);
      transform(transformLogn, transformExpn);
    } else {
      transform(transformLog, transformExp);
    }
    return scale;
  }

  scale.base = function(_) {
    return arguments.length ? (base = +_, rescale()) : base;
  };

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.ticks = function(count) {
    var d = domain(),
        u = d[0],
        v = d[d.length - 1],
        r;

    if (r = v < u) i = u, u = v, v = i;

    var i = logs(u),
        j = logs(v),
        p,
        k,
        t,
        n = count == null ? 10 : +count,
        z = [];

    if (!(base % 1) && j - i < n) {
      i = Math.round(i) - 1, j = Math.round(j) + 1;
      if (u > 0) for (; i < j; ++i) {
        for (k = 1, p = pows(i); k < base; ++k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      } else for (; i < j; ++i) {
        for (k = base - 1, p = pows(i); k >= 1; --k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      }
    } else {
      z = Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["ticks"])(i, j, Math.min(j - i, n)).map(pows);
    }

    return r ? z.reverse() : z;
  };

  scale.tickFormat = function(count, specifier) {
    if (specifier == null) specifier = base === 10 ? ".0e" : ",";
    if (typeof specifier !== "function") specifier = Object(d3_format__WEBPACK_IMPORTED_MODULE_1__["format"])(specifier);
    if (count === Infinity) return specifier;
    if (count == null) count = 10;
    var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
    return function(d) {
      var i = d / pows(Math.round(logs(d)));
      if (i * base < base - 0.5) i *= base;
      return i <= k ? specifier(d) : "";
    };
  };

  scale.nice = function() {
    return domain(Object(_nice__WEBPACK_IMPORTED_MODULE_2__["default"])(domain(), {
      floor: function(x) { return pows(Math.floor(logs(x))); },
      ceil: function(x) { return pows(Math.ceil(logs(x))); }
    }));
  };

  return scale;
}

function log() {
  var scale = loggish(Object(_continuous__WEBPACK_IMPORTED_MODULE_3__["transformer"])()).domain([1, 10]);

  scale.copy = function() {
    return Object(_continuous__WEBPACK_IMPORTED_MODULE_3__["copy"])(scale, log()).base(scale.base());
  };

  _init__WEBPACK_IMPORTED_MODULE_4__["initRange"].apply(scale, arguments);

  return scale;
}


/***/ }),

/***/ "A24K":
/*!*****************************************************************!*\
  !*** ./node_modules/c3/node_modules/d3-scale/src/continuous.js ***!
  \*****************************************************************/
/*! exports provided: identity, copy, transformer, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformer", function() { return transformer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return continuous; });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "sRF9");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-interpolate */ "pD2Y");
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./array */ "d/QP");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constant */ "81I8");
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./number */ "SMHy");






var unit = [0, 1];

function identity(x) {
  return x;
}

function normalize(a, b) {
  return (b -= (a = +a))
      ? function(x) { return (x - a) / b; }
      : Object(_constant__WEBPACK_IMPORTED_MODULE_3__["default"])(isNaN(b) ? NaN : 0.5);
}

function clamper(domain) {
  var a = domain[0], b = domain[domain.length - 1], t;
  if (a > b) t = a, a = b, b = t;
  return function(x) { return Math.max(a, Math.min(b, x)); };
}

// normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
// interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].
function bimap(domain, range, interpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
  if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
  else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
  return function(x) { return r0(d0(x)); };
}

function polymap(domain, range, interpolate) {
  var j = Math.min(domain.length, range.length) - 1,
      d = new Array(j),
      r = new Array(j),
      i = -1;

  // Reverse descending domains.
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range = range.slice().reverse();
  }

  while (++i < j) {
    d[i] = normalize(domain[i], domain[i + 1]);
    r[i] = interpolate(range[i], range[i + 1]);
  }

  return function(x) {
    var i = Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["bisect"])(domain, x, 1, j) - 1;
    return r[i](d[i](x));
  };
}

function copy(source, target) {
  return target
      .domain(source.domain())
      .range(source.range())
      .interpolate(source.interpolate())
      .clamp(source.clamp())
      .unknown(source.unknown());
}

function transformer() {
  var domain = unit,
      range = unit,
      interpolate = d3_interpolate__WEBPACK_IMPORTED_MODULE_1__["interpolate"],
      transform,
      untransform,
      unknown,
      clamp = identity,
      piecewise,
      output,
      input;

  function rescale() {
    piecewise = Math.min(domain.length, range.length) > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }

  function scale(x) {
    return isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));
  }

  scale.invert = function(y) {
    return clamp(untransform((input || (input = piecewise(range, domain.map(transform), d3_interpolate__WEBPACK_IMPORTED_MODULE_1__["interpolateNumber"])))(y)));
  };

  scale.domain = function(_) {
    return arguments.length ? (domain = _array__WEBPACK_IMPORTED_MODULE_2__["map"].call(_, _number__WEBPACK_IMPORTED_MODULE_4__["default"]), clamp === identity || (clamp = clamper(domain)), rescale()) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range = _array__WEBPACK_IMPORTED_MODULE_2__["slice"].call(_), rescale()) : range.slice();
  };

  scale.rangeRound = function(_) {
    return range = _array__WEBPACK_IMPORTED_MODULE_2__["slice"].call(_), interpolate = d3_interpolate__WEBPACK_IMPORTED_MODULE_1__["interpolateRound"], rescale();
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = _ ? clamper(domain) : identity, scale) : clamp !== identity;
  };

  scale.interpolate = function(_) {
    return arguments.length ? (interpolate = _, rescale()) : interpolate;
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  return function(t, u) {
    transform = t, untransform = u;
    return rescale();
  };
}

function continuous(transform, untransform) {
  return transformer()(transform, untransform);
}


/***/ }),

/***/ "AHz+":
/*!***************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/diverging/PuOr.js ***!
  \***************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors.js */ "ZtE7");
/* harmony import */ var _ramp_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp.js */ "jQWc");



var scheme = new Array(3).concat(
  "998ec3f7f7f7f1a340",
  "5e3c99b2abd2fdb863e66101",
  "5e3c99b2abd2f7f7f7fdb863e66101",
  "542788998ec3d8daebfee0b6f1a340b35806",
  "542788998ec3d8daebf7f7f7fee0b6f1a340b35806",
  "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806",
  "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806",
  "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08",
  "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08"
).map(_colors_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp_js__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "AhOu":
/*!************************************************************************!*\
  !*** ./node_modules/c3/node_modules/d3/node_modules/d3-dsv/src/tsv.js ***!
  \************************************************************************/
/*! exports provided: tsvParse, tsvParseRows, tsvFormat, tsvFormatBody, tsvFormatRows, tsvFormatRow, tsvFormatValue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tsvParse", function() { return tsvParse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tsvParseRows", function() { return tsvParseRows; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tsvFormat", function() { return tsvFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tsvFormatBody", function() { return tsvFormatBody; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tsvFormatRows", function() { return tsvFormatRows; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tsvFormatRow", function() { return tsvFormatRow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tsvFormatValue", function() { return tsvFormatValue; });
/* harmony import */ var _dsv_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dsv.js */ "eha6");


var tsv = Object(_dsv_js__WEBPACK_IMPORTED_MODULE_0__["default"])("\t");

var tsvParse = tsv.parse;
var tsvParseRows = tsv.parseRows;
var tsvFormat = tsv.format;
var tsvFormatBody = tsv.formatBody;
var tsvFormatRows = tsv.formatRows;
var tsvFormatRow = tsv.formatRow;
var tsvFormatValue = tsv.formatValue;


/***/ }),

/***/ "AyFX":
/*!*****************************************************!*\
  !*** ./node_modules/d3-voronoi/src/RedBlackTree.js ***!
  \*****************************************************/
/*! exports provided: RedBlackNode, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RedBlackNode", function() { return RedBlackNode; });
function RedBlackTree() {
  this._ = null; // root node
}

function RedBlackNode(node) {
  node.U = // parent node
  node.C = // color - true for red, false for black
  node.L = // left node
  node.R = // right node
  node.P = // previous node
  node.N = null; // next node
}

RedBlackTree.prototype = {
  constructor: RedBlackTree,

  insert: function(after, node) {
    var parent, grandpa, uncle;

    if (after) {
      node.P = after;
      node.N = after.N;
      if (after.N) after.N.P = node;
      after.N = node;
      if (after.R) {
        after = after.R;
        while (after.L) after = after.L;
        after.L = node;
      } else {
        after.R = node;
      }
      parent = after;
    } else if (this._) {
      after = RedBlackFirst(this._);
      node.P = null;
      node.N = after;
      after.P = after.L = node;
      parent = after;
    } else {
      node.P = node.N = null;
      this._ = node;
      parent = null;
    }
    node.L = node.R = null;
    node.U = parent;
    node.C = true;

    after = node;
    while (parent && parent.C) {
      grandpa = parent.U;
      if (parent === grandpa.L) {
        uncle = grandpa.R;
        if (uncle && uncle.C) {
          parent.C = uncle.C = false;
          grandpa.C = true;
          after = grandpa;
        } else {
          if (after === parent.R) {
            RedBlackRotateLeft(this, parent);
            after = parent;
            parent = after.U;
          }
          parent.C = false;
          grandpa.C = true;
          RedBlackRotateRight(this, grandpa);
        }
      } else {
        uncle = grandpa.L;
        if (uncle && uncle.C) {
          parent.C = uncle.C = false;
          grandpa.C = true;
          after = grandpa;
        } else {
          if (after === parent.L) {
            RedBlackRotateRight(this, parent);
            after = parent;
            parent = after.U;
          }
          parent.C = false;
          grandpa.C = true;
          RedBlackRotateLeft(this, grandpa);
        }
      }
      parent = after.U;
    }
    this._.C = false;
  },

  remove: function(node) {
    if (node.N) node.N.P = node.P;
    if (node.P) node.P.N = node.N;
    node.N = node.P = null;

    var parent = node.U,
        sibling,
        left = node.L,
        right = node.R,
        next,
        red;

    if (!left) next = right;
    else if (!right) next = left;
    else next = RedBlackFirst(right);

    if (parent) {
      if (parent.L === node) parent.L = next;
      else parent.R = next;
    } else {
      this._ = next;
    }

    if (left && right) {
      red = next.C;
      next.C = node.C;
      next.L = left;
      left.U = next;
      if (next !== right) {
        parent = next.U;
        next.U = node.U;
        node = next.R;
        parent.L = node;
        next.R = right;
        right.U = next;
      } else {
        next.U = parent;
        parent = next;
        node = next.R;
      }
    } else {
      red = node.C;
      node = next;
    }

    if (node) node.U = parent;
    if (red) return;
    if (node && node.C) { node.C = false; return; }

    do {
      if (node === this._) break;
      if (node === parent.L) {
        sibling = parent.R;
        if (sibling.C) {
          sibling.C = false;
          parent.C = true;
          RedBlackRotateLeft(this, parent);
          sibling = parent.R;
        }
        if ((sibling.L && sibling.L.C)
            || (sibling.R && sibling.R.C)) {
          if (!sibling.R || !sibling.R.C) {
            sibling.L.C = false;
            sibling.C = true;
            RedBlackRotateRight(this, sibling);
            sibling = parent.R;
          }
          sibling.C = parent.C;
          parent.C = sibling.R.C = false;
          RedBlackRotateLeft(this, parent);
          node = this._;
          break;
        }
      } else {
        sibling = parent.L;
        if (sibling.C) {
          sibling.C = false;
          parent.C = true;
          RedBlackRotateRight(this, parent);
          sibling = parent.L;
        }
        if ((sibling.L && sibling.L.C)
          || (sibling.R && sibling.R.C)) {
          if (!sibling.L || !sibling.L.C) {
            sibling.R.C = false;
            sibling.C = true;
            RedBlackRotateLeft(this, sibling);
            sibling = parent.L;
          }
          sibling.C = parent.C;
          parent.C = sibling.L.C = false;
          RedBlackRotateRight(this, parent);
          node = this._;
          break;
        }
      }
      sibling.C = true;
      node = parent;
      parent = parent.U;
    } while (!node.C);

    if (node) node.C = false;
  }
};

function RedBlackRotateLeft(tree, node) {
  var p = node,
      q = node.R,
      parent = p.U;

  if (parent) {
    if (parent.L === p) parent.L = q;
    else parent.R = q;
  } else {
    tree._ = q;
  }

  q.U = parent;
  p.U = q;
  p.R = q.L;
  if (p.R) p.R.U = p;
  q.L = p;
}

function RedBlackRotateRight(tree, node) {
  var p = node,
      q = node.L,
      parent = p.U;

  if (parent) {
    if (parent.L === p) parent.L = q;
    else parent.R = q;
  } else {
    tree._ = q;
  }

  q.U = parent;
  p.U = q;
  p.L = q.R;
  if (p.L) p.L.U = p;
  q.R = p;
}

function RedBlackFirst(node) {
  while (node.L) node = node.L;
  return node;
}

/* harmony default export */ __webpack_exports__["default"] = (RedBlackTree);


/***/ }),

/***/ "AyrI":
/*!**********************************************************!*\
  !*** ./node_modules/c3/node_modules/d3-scale/src/pow.js ***!
  \**********************************************************/
/*! exports provided: powish, default, sqrt */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "powish", function() { return powish; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return pow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrt", function() { return sqrt; });
/* harmony import */ var _linear__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./linear */ "hdEp");
/* harmony import */ var _continuous__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./continuous */ "A24K");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./init */ "//NX");




function transformPow(exponent) {
  return function(x) {
    return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
  };
}

function transformSqrt(x) {
  return x < 0 ? -Math.sqrt(-x) : Math.sqrt(x);
}

function transformSquare(x) {
  return x < 0 ? -x * x : x * x;
}

function powish(transform) {
  var scale = transform(_continuous__WEBPACK_IMPORTED_MODULE_1__["identity"], _continuous__WEBPACK_IMPORTED_MODULE_1__["identity"]),
      exponent = 1;

  function rescale() {
    return exponent === 1 ? transform(_continuous__WEBPACK_IMPORTED_MODULE_1__["identity"], _continuous__WEBPACK_IMPORTED_MODULE_1__["identity"])
        : exponent === 0.5 ? transform(transformSqrt, transformSquare)
        : transform(transformPow(exponent), transformPow(1 / exponent));
  }

  scale.exponent = function(_) {
    return arguments.length ? (exponent = +_, rescale()) : exponent;
  };

  return Object(_linear__WEBPACK_IMPORTED_MODULE_0__["linearish"])(scale);
}

function pow() {
  var scale = powish(Object(_continuous__WEBPACK_IMPORTED_MODULE_1__["transformer"])());

  scale.copy = function() {
    return Object(_continuous__WEBPACK_IMPORTED_MODULE_1__["copy"])(scale, pow()).exponent(scale.exponent());
  };

  _init__WEBPACK_IMPORTED_MODULE_2__["initRange"].apply(scale, arguments);

  return scale;
}

function sqrt() {
  return pow.apply(null, arguments).exponent(0.5);
}


/***/ }),

/***/ "BuHV":
/*!**********************************************************!*\
  !*** ./node_modules/c3/node_modules/d3-array/src/min.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null && min > value) {
            min = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && min > value) {
            min = value;
          }
        }
      }
    }
  }

  return min;
});


/***/ }),

/***/ "BvdE":
/*!*************************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/sequential-multi/sinebow.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "SC+/");


var c = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["rgb"])(),
    pi_1_3 = Math.PI / 3,
    pi_2_3 = Math.PI * 2 / 3;

/* harmony default export */ __webpack_exports__["default"] = (function(t) {
  var x;
  t = (0.5 - t) * Math.PI;
  c.r = 255 * (x = Math.sin(t)) * x;
  c.g = 255 * (x = Math.sin(t + pi_1_3)) * x;
  c.b = 255 * (x = Math.sin(t + pi_2_3)) * x;
  return c + "";
});


/***/ }),

/***/ "C33F":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/categorical/Set3.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors.js */ "ZtE7");


/* harmony default export */ __webpack_exports__["default"] = (Object(_colors_js__WEBPACK_IMPORTED_MODULE_0__["default"])("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f"));


/***/ }),

/***/ "C9Ig":
/*!************************************************************!*\
  !*** ./node_modules/c3/node_modules/d3-array/src/cross.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _pairs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pairs */ "0VgA");


/* harmony default export */ __webpack_exports__["default"] = (function(values0, values1, reduce) {
  var n0 = values0.length,
      n1 = values1.length,
      values = new Array(n0 * n1),
      i0,
      i1,
      i,
      value0;

  if (reduce == null) reduce = _pairs__WEBPACK_IMPORTED_MODULE_0__["pair"];

  for (i0 = i = 0; i0 < n0; ++i0) {
    for (value0 = values0[i0], i1 = 0; i1 < n1; ++i1, ++i) {
      values[i] = reduce(value0, values1[i1]);
    }
  }

  return values;
});


/***/ }),

/***/ "CIwN":
/*!**************************************************!*\
  !*** ./node_modules/d3-collection/src/values.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(map) {
  var values = [];
  for (var key in map) values.push(map[key]);
  return values;
});


/***/ }),

/***/ "CKiT":
/*!*******************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/diverging/Spectral.js ***!
  \*******************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors.js */ "ZtE7");
/* harmony import */ var _ramp_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp.js */ "jQWc");



var scheme = new Array(3).concat(
  "fc8d59ffffbf99d594",
  "d7191cfdae61abdda42b83ba",
  "d7191cfdae61ffffbfabdda42b83ba",
  "d53e4ffc8d59fee08be6f59899d5943288bd",
  "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd",
  "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd",
  "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd",
  "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2",
  "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2"
).map(_colors_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp_js__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "Ckr6":
/*!********************************************!*\
  !*** ./node_modules/d3-force/src/index.js ***!
  \********************************************/
/*! exports provided: forceCenter, forceCollide, forceLink, forceManyBody, forceRadial, forceSimulation, forceX, forceY */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _center__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./center */ "0LFD");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "forceCenter", function() { return _center__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _collide__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./collide */ "iQ9W");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "forceCollide", function() { return _collide__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _link__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./link */ "89eD");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "forceLink", function() { return _link__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _manyBody__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./manyBody */ "Z9Ww");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "forceManyBody", function() { return _manyBody__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _radial__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./radial */ "Wtxg");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "forceRadial", function() { return _radial__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _simulation__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./simulation */ "VIHS");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "forceSimulation", function() { return _simulation__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _x__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./x */ "cnUW");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "forceX", function() { return _x__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _y__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./y */ "0rNn");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "forceY", function() { return _y__WEBPACK_IMPORTED_MODULE_7__["default"]; });











/***/ }),

/***/ "Cuxv":
/*!********************************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/azimuthalEquidistant.js ***!
  \********************************************************************/
/*! exports provided: azimuthalEquidistantRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "azimuthalEquidistantRaw", function() { return azimuthalEquidistantRaw; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "R0y8");
/* harmony import */ var _azimuthal_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./azimuthal.js */ "dg0l");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.js */ "1ibS");




var azimuthalEquidistantRaw = Object(_azimuthal_js__WEBPACK_IMPORTED_MODULE_1__["azimuthalRaw"])(function(c) {
  return (c = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["acos"])(c)) && c / Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sin"])(c);
});

azimuthalEquidistantRaw.invert = Object(_azimuthal_js__WEBPACK_IMPORTED_MODULE_1__["azimuthalInvert"])(function(z) {
  return z;
});

/* harmony default export */ __webpack_exports__["default"] = (function() {
  return Object(_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(azimuthalEquidistantRaw)
      .scale(79.4188)
      .clipAngle(180 - 1e-3);
});


/***/ }),

/***/ "DHg+":
/*!************************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/sequential-multi/PuBuGn.js ***!
  \************************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors.js */ "ZtE7");
/* harmony import */ var _ramp_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp.js */ "jQWc");



var scheme = new Array(3).concat(
  "ece2f0a6bddb1c9099",
  "f6eff7bdc9e167a9cf02818a",
  "f6eff7bdc9e167a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636"
).map(_colors_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp_js__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "DS9Q":
/*!***********************************************************!*\
  !*** ./node_modules/c3/node_modules/d3-scale/src/time.js ***!
  \***********************************************************/
/*! exports provided: calendar, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "calendar", function() { return calendar; });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "sRF9");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-time */ "eIOW");
/* harmony import */ var d3_time_format__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-time-format */ "cOGN");
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./array */ "d/QP");
/* harmony import */ var _continuous__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./continuous */ "A24K");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./init */ "//NX");
/* harmony import */ var _nice__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./nice */ "2oOk");








var durationSecond = 1000,
    durationMinute = durationSecond * 60,
    durationHour = durationMinute * 60,
    durationDay = durationHour * 24,
    durationWeek = durationDay * 7,
    durationMonth = durationDay * 30,
    durationYear = durationDay * 365;

function date(t) {
  return new Date(t);
}

function number(t) {
  return t instanceof Date ? +t : +new Date(+t);
}

function calendar(year, month, week, day, hour, minute, second, millisecond, format) {
  var scale = Object(_continuous__WEBPACK_IMPORTED_MODULE_4__["default"])(_continuous__WEBPACK_IMPORTED_MODULE_4__["identity"], _continuous__WEBPACK_IMPORTED_MODULE_4__["identity"]),
      invert = scale.invert,
      domain = scale.domain;

  var formatMillisecond = format(".%L"),
      formatSecond = format(":%S"),
      formatMinute = format("%I:%M"),
      formatHour = format("%I %p"),
      formatDay = format("%a %d"),
      formatWeek = format("%b %d"),
      formatMonth = format("%B"),
      formatYear = format("%Y");

  var tickIntervals = [
    [second,  1,      durationSecond],
    [second,  5,  5 * durationSecond],
    [second, 15, 15 * durationSecond],
    [second, 30, 30 * durationSecond],
    [minute,  1,      durationMinute],
    [minute,  5,  5 * durationMinute],
    [minute, 15, 15 * durationMinute],
    [minute, 30, 30 * durationMinute],
    [  hour,  1,      durationHour  ],
    [  hour,  3,  3 * durationHour  ],
    [  hour,  6,  6 * durationHour  ],
    [  hour, 12, 12 * durationHour  ],
    [   day,  1,      durationDay   ],
    [   day,  2,  2 * durationDay   ],
    [  week,  1,      durationWeek  ],
    [ month,  1,      durationMonth ],
    [ month,  3,  3 * durationMonth ],
    [  year,  1,      durationYear  ]
  ];

  function tickFormat(date) {
    return (second(date) < date ? formatMillisecond
        : minute(date) < date ? formatSecond
        : hour(date) < date ? formatMinute
        : day(date) < date ? formatHour
        : month(date) < date ? (week(date) < date ? formatDay : formatWeek)
        : year(date) < date ? formatMonth
        : formatYear)(date);
  }

  function tickInterval(interval, start, stop, step) {
    if (interval == null) interval = 10;

    // If a desired tick count is specified, pick a reasonable tick interval
    // based on the extent of the domain and a rough estimate of tick size.
    // Otherwise, assume interval is already a time interval and use it.
    if (typeof interval === "number") {
      var target = Math.abs(stop - start) / interval,
          i = Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["bisector"])(function(i) { return i[2]; }).right(tickIntervals, target);
      if (i === tickIntervals.length) {
        step = Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["tickStep"])(start / durationYear, stop / durationYear, interval);
        interval = year;
      } else if (i) {
        i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
        step = i[1];
        interval = i[0];
      } else {
        step = Math.max(Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["tickStep"])(start, stop, interval), 1);
        interval = millisecond;
      }
    }

    return step == null ? interval : interval.every(step);
  }

  scale.invert = function(y) {
    return new Date(invert(y));
  };

  scale.domain = function(_) {
    return arguments.length ? domain(_array__WEBPACK_IMPORTED_MODULE_3__["map"].call(_, number)) : domain().map(date);
  };

  scale.ticks = function(interval, step) {
    var d = domain(),
        t0 = d[0],
        t1 = d[d.length - 1],
        r = t1 < t0,
        t;
    if (r) t = t0, t0 = t1, t1 = t;
    t = tickInterval(interval, t0, t1, step);
    t = t ? t.range(t0, t1 + 1) : []; // inclusive stop
    return r ? t.reverse() : t;
  };

  scale.tickFormat = function(count, specifier) {
    return specifier == null ? tickFormat : format(specifier);
  };

  scale.nice = function(interval, step) {
    var d = domain();
    return (interval = tickInterval(interval, d[0], d[d.length - 1], step))
        ? domain(Object(_nice__WEBPACK_IMPORTED_MODULE_6__["default"])(d, interval))
        : scale;
  };

  scale.copy = function() {
    return Object(_continuous__WEBPACK_IMPORTED_MODULE_4__["copy"])(scale, calendar(year, month, week, day, hour, minute, second, millisecond, format));
  };

  return scale;
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  return _init__WEBPACK_IMPORTED_MODULE_5__["initRange"].apply(calendar(d3_time__WEBPACK_IMPORTED_MODULE_1__["timeYear"], d3_time__WEBPACK_IMPORTED_MODULE_1__["timeMonth"], d3_time__WEBPACK_IMPORTED_MODULE_1__["timeWeek"], d3_time__WEBPACK_IMPORTED_MODULE_1__["timeDay"], d3_time__WEBPACK_IMPORTED_MODULE_1__["timeHour"], d3_time__WEBPACK_IMPORTED_MODULE_1__["timeMinute"], d3_time__WEBPACK_IMPORTED_MODULE_1__["timeSecond"], d3_time__WEBPACK_IMPORTED_MODULE_1__["timeMillisecond"], d3_time_format__WEBPACK_IMPORTED_MODULE_2__["timeFormat"]).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]), arguments);
});


/***/ }),

/***/ "DiG6":
/*!*************************************************!*\
  !*** ./node_modules/d3-contour/src/constant.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return function() {
    return x;
  };
});


/***/ }),

/***/ "Drdv":
/*!***************************************************************!*\
  !*** ./node_modules/c3/node_modules/d3-scale/src/quantize.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return quantize; });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "sRF9");
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./array */ "d/QP");
/* harmony import */ var _linear__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./linear */ "hdEp");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./init */ "//NX");





function quantize() {
  var x0 = 0,
      x1 = 1,
      n = 1,
      domain = [0.5],
      range = [0, 1],
      unknown;

  function scale(x) {
    return x <= x ? range[Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["bisect"])(domain, x, 0, n)] : unknown;
  }

  function rescale() {
    var i = -1;
    domain = new Array(n);
    while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
    return scale;
  }

  scale.domain = function(_) {
    return arguments.length ? (x0 = +_[0], x1 = +_[1], rescale()) : [x0, x1];
  };

  scale.range = function(_) {
    return arguments.length ? (n = (range = _array__WEBPACK_IMPORTED_MODULE_1__["slice"].call(_)).length - 1, rescale()) : range.slice();
  };

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN]
        : i < 1 ? [x0, domain[0]]
        : i >= n ? [domain[n - 1], x1]
        : [domain[i - 1], domain[i]];
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : scale;
  };

  scale.thresholds = function() {
    return domain.slice();
  };

  scale.copy = function() {
    return quantize()
        .domain([x0, x1])
        .range(range)
        .unknown(unknown);
  };

  return _init__WEBPACK_IMPORTED_MODULE_3__["initRange"].apply(Object(_linear__WEBPACK_IMPORTED_MODULE_2__["linearish"])(scale), arguments);
}


/***/ }),

/***/ "E//B":
/*!************************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/sequential-multi/YlGnBu.js ***!
  \************************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors.js */ "ZtE7");
/* harmony import */ var _ramp_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp.js */ "jQWc");



var scheme = new Array(3).concat(
  "edf8b17fcdbb2c7fb8",
  "ffffcca1dab441b6c4225ea8",
  "ffffcca1dab441b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
).map(_colors_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp_js__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "EGnP":
/*!************************************************!*\
  !*** ./node_modules/d3-voronoi/src/voronoi.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant */ "l9nW");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./point */ "/yBm");
/* harmony import */ var _Diagram__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Diagram */ "Go7+");




/* harmony default export */ __webpack_exports__["default"] = (function() {
  var x = _point__WEBPACK_IMPORTED_MODULE_1__["x"],
      y = _point__WEBPACK_IMPORTED_MODULE_1__["y"],
      extent = null;

  function voronoi(data) {
    return new _Diagram__WEBPACK_IMPORTED_MODULE_2__["default"](data.map(function(d, i) {
      var s = [Math.round(x(d, i, data) / _Diagram__WEBPACK_IMPORTED_MODULE_2__["epsilon"]) * _Diagram__WEBPACK_IMPORTED_MODULE_2__["epsilon"], Math.round(y(d, i, data) / _Diagram__WEBPACK_IMPORTED_MODULE_2__["epsilon"]) * _Diagram__WEBPACK_IMPORTED_MODULE_2__["epsilon"]];
      s.index = i;
      s.data = d;
      return s;
    }), extent);
  }

  voronoi.polygons = function(data) {
    return voronoi(data).polygons();
  };

  voronoi.links = function(data) {
    return voronoi(data).links();
  };

  voronoi.triangles = function(data) {
    return voronoi(data).triangles();
  };

  voronoi.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), voronoi) : x;
  };

  voronoi.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), voronoi) : y;
  };

  voronoi.extent = function(_) {
    return arguments.length ? (extent = _ == null ? null : [[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]], voronoi) : extent && [[extent[0][0], extent[0][1]], [extent[1][0], extent[1][1]]];
  };

  voronoi.size = function(_) {
    return arguments.length ? (extent = _ == null ? null : [[0, 0], [+_[0], +_[1]]], voronoi) : extent && [extent[1][0] - extent[0][0], extent[1][1] - extent[0][1]];
  };

  return voronoi;
});


/***/ }),

/***/ "EVP4":
/*!***********************************************!*\
  !*** ./node_modules/d3-quadtree/src/visit.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _quad_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./quad.js */ "p/7N");


/* harmony default export */ __webpack_exports__["default"] = (function(callback) {
  var quads = [], q, node = this._root, child, x0, y0, x1, y1;
  if (node) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](node, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
      var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[3]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, xm, ym, x1, y1));
      if (child = node[2]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, x0, ym, xm, y1));
      if (child = node[1]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, xm, y0, x1, ym));
      if (child = node[0]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, x0, y0, xm, ym));
    }
  }
  return this;
});


/***/ }),

/***/ "EyUX":
/*!*************************************************!*\
  !*** ./node_modules/d3-geo/src/path/measure.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _adder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../adder.js */ "uCr6");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math.js */ "R0y8");
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../noop.js */ "mPOO");




var lengthSum = Object(_adder_js__WEBPACK_IMPORTED_MODULE_0__["default"])(),
    lengthRing,
    x00,
    y00,
    x0,
    y0;

var lengthStream = {
  point: _noop_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  lineStart: function() {
    lengthStream.point = lengthPointFirst;
  },
  lineEnd: function() {
    if (lengthRing) lengthPoint(x00, y00);
    lengthStream.point = _noop_js__WEBPACK_IMPORTED_MODULE_2__["default"];
  },
  polygonStart: function() {
    lengthRing = true;
  },
  polygonEnd: function() {
    lengthRing = null;
  },
  result: function() {
    var length = +lengthSum;
    lengthSum.reset();
    return length;
  }
};

function lengthPointFirst(x, y) {
  lengthStream.point = lengthPoint;
  x00 = x0 = x, y00 = y0 = y;
}

function lengthPoint(x, y) {
  x0 -= x, y0 -= y;
  lengthSum.add(Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(x0 * x0 + y0 * y0));
  x0 = x, y0 = y;
}

/* harmony default export */ __webpack_exports__["default"] = (lengthStream);


/***/ }),

/***/ "F2eR":
/*!***************************************************!*\
  !*** ./node_modules/d3-geo/src/clip/rectangle.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return clipRectangle; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "R0y8");
/* harmony import */ var _buffer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./buffer.js */ "ODVu");
/* harmony import */ var _line_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./line.js */ "SGTC");
/* harmony import */ var _rejoin_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rejoin.js */ "5xK/");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-array */ "sRF9");






var clipMax = 1e9, clipMin = -clipMax;

// TODO Use d3-polygon’s polygonContains here for the ring check?
// TODO Eliminate duplicate buffering in clipBuffer and polygon.push?

function clipRectangle(x0, y0, x1, y1) {

  function visible(x, y) {
    return x0 <= x && x <= x1 && y0 <= y && y <= y1;
  }

  function interpolate(from, to, direction, stream) {
    var a = 0, a1 = 0;
    if (from == null
        || (a = corner(from, direction)) !== (a1 = corner(to, direction))
        || comparePoint(from, to) < 0 ^ direction > 0) {
      do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
      while ((a = (a + direction + 4) % 4) !== a1);
    } else {
      stream.point(to[0], to[1]);
    }
  }

  function corner(p, direction) {
    return Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["abs"])(p[0] - x0) < _math_js__WEBPACK_IMPORTED_MODULE_0__["epsilon"] ? direction > 0 ? 0 : 3
        : Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["abs"])(p[0] - x1) < _math_js__WEBPACK_IMPORTED_MODULE_0__["epsilon"] ? direction > 0 ? 2 : 1
        : Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["abs"])(p[1] - y0) < _math_js__WEBPACK_IMPORTED_MODULE_0__["epsilon"] ? direction > 0 ? 1 : 0
        : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon
  }

  function compareIntersection(a, b) {
    return comparePoint(a.x, b.x);
  }

  function comparePoint(a, b) {
    var ca = corner(a, 1),
        cb = corner(b, 1);
    return ca !== cb ? ca - cb
        : ca === 0 ? b[1] - a[1]
        : ca === 1 ? a[0] - b[0]
        : ca === 2 ? a[1] - b[1]
        : b[0] - a[0];
  }

  return function(stream) {
    var activeStream = stream,
        bufferStream = Object(_buffer_js__WEBPACK_IMPORTED_MODULE_1__["default"])(),
        segments,
        polygon,
        ring,
        x__, y__, v__, // first point
        x_, y_, v_, // previous point
        first,
        clean;

    var clipStream = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: polygonStart,
      polygonEnd: polygonEnd
    };

    function point(x, y) {
      if (visible(x, y)) activeStream.point(x, y);
    }

    function polygonInside() {
      var winding = 0;

      for (var i = 0, n = polygon.length; i < n; ++i) {
        for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {
          a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];
          if (a1 <= y1) { if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding; }
          else { if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding; }
        }
      }

      return winding;
    }

    // Buffer geometry within a polygon and then clip it en masse.
    function polygonStart() {
      activeStream = bufferStream, segments = [], polygon = [], clean = true;
    }

    function polygonEnd() {
      var startInside = polygonInside(),
          cleanInside = clean && startInside,
          visible = (segments = Object(d3_array__WEBPACK_IMPORTED_MODULE_4__["merge"])(segments)).length;
      if (cleanInside || visible) {
        stream.polygonStart();
        if (cleanInside) {
          stream.lineStart();
          interpolate(null, null, 1, stream);
          stream.lineEnd();
        }
        if (visible) {
          Object(_rejoin_js__WEBPACK_IMPORTED_MODULE_3__["default"])(segments, compareIntersection, startInside, interpolate, stream);
        }
        stream.polygonEnd();
      }
      activeStream = stream, segments = polygon = ring = null;
    }

    function lineStart() {
      clipStream.point = linePoint;
      if (polygon) polygon.push(ring = []);
      first = true;
      v_ = false;
      x_ = y_ = NaN;
    }

    // TODO rather than special-case polygons, simply handle them separately.
    // Ideally, coincident intersection points should be jittered to avoid
    // clipping issues.
    function lineEnd() {
      if (segments) {
        linePoint(x__, y__);
        if (v__ && v_) bufferStream.rejoin();
        segments.push(bufferStream.result());
      }
      clipStream.point = point;
      if (v_) activeStream.lineEnd();
    }

    function linePoint(x, y) {
      var v = visible(x, y);
      if (polygon) ring.push([x, y]);
      if (first) {
        x__ = x, y__ = y, v__ = v;
        first = false;
        if (v) {
          activeStream.lineStart();
          activeStream.point(x, y);
        }
      } else {
        if (v && v_) activeStream.point(x, y);
        else {
          var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],
              b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];
          if (Object(_line_js__WEBPACK_IMPORTED_MODULE_2__["default"])(a, b, x0, y0, x1, y1)) {
            if (!v_) {
              activeStream.lineStart();
              activeStream.point(a[0], a[1]);
            }
            activeStream.point(b[0], b[1]);
            if (!v) activeStream.lineEnd();
            clean = false;
          } else if (v) {
            activeStream.lineStart();
            activeStream.point(x, y);
            clean = false;
          }
        }
      }
      x_ = x, y_ = y, v_ = v;
    }

    return clipStream;
  };
}


/***/ }),

/***/ "FRIb":
/*!****************************************************************!*\
  !*** ./node_modules/c3/node_modules/d3-scale/src/threshold.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return threshold; });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "sRF9");
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./array */ "d/QP");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./init */ "//NX");




function threshold() {
  var domain = [0.5],
      range = [0, 1],
      unknown,
      n = 1;

  function scale(x) {
    return x <= x ? range[Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["bisect"])(domain, x, 0, n)] : unknown;
  }

  scale.domain = function(_) {
    return arguments.length ? (domain = _array__WEBPACK_IMPORTED_MODULE_1__["slice"].call(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range = _array__WEBPACK_IMPORTED_MODULE_1__["slice"].call(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();
  };

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return [domain[i - 1], domain[i]];
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return threshold()
        .domain(domain)
        .range(range)
        .unknown(unknown);
  };

  return _init__WEBPACK_IMPORTED_MODULE_2__["initRange"].apply(scale, arguments);
}


/***/ }),

/***/ "FbTJ":
/*!*********************************************!*\
  !*** ./node_modules/d3-voronoi/src/Edge.js ***!
  \*********************************************/
/*! exports provided: createEdge, createBorderEdge, setEdgeEnd, clipEdges */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createEdge", function() { return createEdge; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createBorderEdge", function() { return createBorderEdge; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setEdgeEnd", function() { return setEdgeEnd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clipEdges", function() { return clipEdges; });
/* harmony import */ var _Diagram__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Diagram */ "Go7+");


function createEdge(left, right, v0, v1) {
  var edge = [null, null],
      index = _Diagram__WEBPACK_IMPORTED_MODULE_0__["edges"].push(edge) - 1;
  edge.left = left;
  edge.right = right;
  if (v0) setEdgeEnd(edge, left, right, v0);
  if (v1) setEdgeEnd(edge, right, left, v1);
  _Diagram__WEBPACK_IMPORTED_MODULE_0__["cells"][left.index].halfedges.push(index);
  _Diagram__WEBPACK_IMPORTED_MODULE_0__["cells"][right.index].halfedges.push(index);
  return edge;
}

function createBorderEdge(left, v0, v1) {
  var edge = [v0, v1];
  edge.left = left;
  return edge;
}

function setEdgeEnd(edge, left, right, vertex) {
  if (!edge[0] && !edge[1]) {
    edge[0] = vertex;
    edge.left = left;
    edge.right = right;
  } else if (edge.left === right) {
    edge[1] = vertex;
  } else {
    edge[0] = vertex;
  }
}

// Liang–Barsky line clipping.
function clipEdge(edge, x0, y0, x1, y1) {
  var a = edge[0],
      b = edge[1],
      ax = a[0],
      ay = a[1],
      bx = b[0],
      by = b[1],
      t0 = 0,
      t1 = 1,
      dx = bx - ax,
      dy = by - ay,
      r;

  r = x0 - ax;
  if (!dx && r > 0) return;
  r /= dx;
  if (dx < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dx > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = x1 - ax;
  if (!dx && r < 0) return;
  r /= dx;
  if (dx < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dx > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  r = y0 - ay;
  if (!dy && r > 0) return;
  r /= dy;
  if (dy < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dy > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = y1 - ay;
  if (!dy && r < 0) return;
  r /= dy;
  if (dy < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dy > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  if (!(t0 > 0) && !(t1 < 1)) return true; // TODO Better check?

  if (t0 > 0) edge[0] = [ax + t0 * dx, ay + t0 * dy];
  if (t1 < 1) edge[1] = [ax + t1 * dx, ay + t1 * dy];
  return true;
}

function connectEdge(edge, x0, y0, x1, y1) {
  var v1 = edge[1];
  if (v1) return true;

  var v0 = edge[0],
      left = edge.left,
      right = edge.right,
      lx = left[0],
      ly = left[1],
      rx = right[0],
      ry = right[1],
      fx = (lx + rx) / 2,
      fy = (ly + ry) / 2,
      fm,
      fb;

  if (ry === ly) {
    if (fx < x0 || fx >= x1) return;
    if (lx > rx) {
      if (!v0) v0 = [fx, y0];
      else if (v0[1] >= y1) return;
      v1 = [fx, y1];
    } else {
      if (!v0) v0 = [fx, y1];
      else if (v0[1] < y0) return;
      v1 = [fx, y0];
    }
  } else {
    fm = (lx - rx) / (ry - ly);
    fb = fy - fm * fx;
    if (fm < -1 || fm > 1) {
      if (lx > rx) {
        if (!v0) v0 = [(y0 - fb) / fm, y0];
        else if (v0[1] >= y1) return;
        v1 = [(y1 - fb) / fm, y1];
      } else {
        if (!v0) v0 = [(y1 - fb) / fm, y1];
        else if (v0[1] < y0) return;
        v1 = [(y0 - fb) / fm, y0];
      }
    } else {
      if (ly < ry) {
        if (!v0) v0 = [x0, fm * x0 + fb];
        else if (v0[0] >= x1) return;
        v1 = [x1, fm * x1 + fb];
      } else {
        if (!v0) v0 = [x1, fm * x1 + fb];
        else if (v0[0] < x0) return;
        v1 = [x0, fm * x0 + fb];
      }
    }
  }

  edge[0] = v0;
  edge[1] = v1;
  return true;
}

function clipEdges(x0, y0, x1, y1) {
  var i = _Diagram__WEBPACK_IMPORTED_MODULE_0__["edges"].length,
      edge;

  while (i--) {
    if (!connectEdge(edge = _Diagram__WEBPACK_IMPORTED_MODULE_0__["edges"][i], x0, y0, x1, y1)
        || !clipEdge(edge, x0, y0, x1, y1)
        || !(Math.abs(edge[0][0] - edge[1][0]) > _Diagram__WEBPACK_IMPORTED_MODULE_0__["epsilon"]
            || Math.abs(edge[0][1] - edge[1][1]) > _Diagram__WEBPACK_IMPORTED_MODULE_0__["epsilon"])) {
      delete _Diagram__WEBPACK_IMPORTED_MODULE_0__["edges"][i];
    }
  }
}


/***/ }),

/***/ "G0FW":
/*!************************************************!*\
  !*** ./node_modules/d3-quadtree/src/remove.js ***!
  \************************************************/
/*! exports provided: default, removeAll */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeAll", function() { return removeAll; });
/* harmony default export */ __webpack_exports__["default"] = (function(d) {
  if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points

  var parent,
      node = this._root,
      retainer,
      previous,
      next,
      x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1,
      x,
      y,
      xm,
      ym,
      right,
      bottom,
      i,
      j;

  // If the tree is empty, initialize the root as a leaf.
  if (!node) return this;

  // Find the leaf node for the point.
  // While descending, also retain the deepest parent with a non-removed sibling.
  if (node.length) while (true) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
    if (!(parent = node, node = node[i = bottom << 1 | right])) return this;
    if (!node.length) break;
    if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3]) retainer = parent, j = i;
  }

  // Find the point to remove.
  while (node.data !== d) if (!(previous = node, node = node.next)) return this;
  if (next = node.next) delete node.next;

  // If there are multiple coincident points, remove just the point.
  if (previous) return (next ? previous.next = next : delete previous.next), this;

  // If this is the root point, remove it.
  if (!parent) return this._root = next, this;

  // Remove this leaf.
  next ? parent[i] = next : delete parent[i];

  // If the parent now contains exactly one leaf, collapse superfluous parents.
  if ((node = parent[0] || parent[1] || parent[2] || parent[3])
      && node === (parent[3] || parent[2] || parent[1] || parent[0])
      && !node.length) {
    if (retainer) retainer[j] = node;
    else this._root = node;
  }

  return this;
});

function removeAll(data) {
  for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);
  return this;
}


/***/ }),

/***/ "G4XB":
/*!*************************************************!*\
  !*** ./node_modules/d3-random/src/logNormal.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _defaultSource__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./defaultSource */ "0RZX");
/* harmony import */ var _normal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./normal */ "ptze");



/* harmony default export */ __webpack_exports__["default"] = ((function sourceRandomLogNormal(source) {
  function randomLogNormal() {
    var randomNormal = _normal__WEBPACK_IMPORTED_MODULE_1__["default"].source(source).apply(this, arguments);
    return function() {
      return Math.exp(randomNormal());
    };
  }

  randomLogNormal.source = sourceRandomLogNormal;

  return randomLogNormal;
})(_defaultSource__WEBPACK_IMPORTED_MODULE_0__["default"]));


/***/ }),

/***/ "GlnO":
/*!************************************************!*\
  !*** ./node_modules/d3-collection/src/keys.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(map) {
  var keys = [];
  for (var key in map) keys.push(key);
  return keys;
});


/***/ }),

/***/ "Go7+":
/*!************************************************!*\
  !*** ./node_modules/d3-voronoi/src/Diagram.js ***!
  \************************************************/
/*! exports provided: epsilon, epsilon2, beaches, cells, circles, edges, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "epsilon", function() { return epsilon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "epsilon2", function() { return epsilon2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "beaches", function() { return beaches; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cells", function() { return cells; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "circles", function() { return circles; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "edges", function() { return edges; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Diagram; });
/* harmony import */ var _Beach__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Beach */ "dC/H");
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Cell */ "Ke4m");
/* harmony import */ var _Circle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Circle */ "Kljt");
/* harmony import */ var _Edge__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Edge */ "FbTJ");
/* harmony import */ var _RedBlackTree__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./RedBlackTree */ "AyFX");






var epsilon = 1e-6;
var epsilon2 = 1e-12;
var beaches;
var cells;
var circles;
var edges;

function triangleArea(a, b, c) {
  return (a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]);
}

function lexicographic(a, b) {
  return b[1] - a[1]
      || b[0] - a[0];
}

function Diagram(sites, extent) {
  var site = sites.sort(lexicographic).pop(),
      x,
      y,
      circle;

  edges = [];
  cells = new Array(sites.length);
  beaches = new _RedBlackTree__WEBPACK_IMPORTED_MODULE_4__["default"];
  circles = new _RedBlackTree__WEBPACK_IMPORTED_MODULE_4__["default"];

  while (true) {
    circle = _Circle__WEBPACK_IMPORTED_MODULE_2__["firstCircle"];
    if (site && (!circle || site[1] < circle.y || (site[1] === circle.y && site[0] < circle.x))) {
      if (site[0] !== x || site[1] !== y) {
        Object(_Beach__WEBPACK_IMPORTED_MODULE_0__["addBeach"])(site);
        x = site[0], y = site[1];
      }
      site = sites.pop();
    } else if (circle) {
      Object(_Beach__WEBPACK_IMPORTED_MODULE_0__["removeBeach"])(circle.arc);
    } else {
      break;
    }
  }

  Object(_Cell__WEBPACK_IMPORTED_MODULE_1__["sortCellHalfedges"])();

  if (extent) {
    var x0 = +extent[0][0],
        y0 = +extent[0][1],
        x1 = +extent[1][0],
        y1 = +extent[1][1];
    Object(_Edge__WEBPACK_IMPORTED_MODULE_3__["clipEdges"])(x0, y0, x1, y1);
    Object(_Cell__WEBPACK_IMPORTED_MODULE_1__["clipCells"])(x0, y0, x1, y1);
  }

  this.edges = edges;
  this.cells = cells;

  beaches =
  circles =
  edges =
  cells = null;
}

Diagram.prototype = {
  constructor: Diagram,

  polygons: function() {
    var edges = this.edges;

    return this.cells.map(function(cell) {
      var polygon = cell.halfedges.map(function(i) { return Object(_Cell__WEBPACK_IMPORTED_MODULE_1__["cellHalfedgeStart"])(cell, edges[i]); });
      polygon.data = cell.site.data;
      return polygon;
    });
  },

  triangles: function() {
    var triangles = [],
        edges = this.edges;

    this.cells.forEach(function(cell, i) {
      if (!(m = (halfedges = cell.halfedges).length)) return;
      var site = cell.site,
          halfedges,
          j = -1,
          m,
          s0,
          e1 = edges[halfedges[m - 1]],
          s1 = e1.left === site ? e1.right : e1.left;

      while (++j < m) {
        s0 = s1;
        e1 = edges[halfedges[j]];
        s1 = e1.left === site ? e1.right : e1.left;
        if (s0 && s1 && i < s0.index && i < s1.index && triangleArea(site, s0, s1) < 0) {
          triangles.push([site.data, s0.data, s1.data]);
        }
      }
    });

    return triangles;
  },

  links: function() {
    return this.edges.filter(function(edge) {
      return edge.right;
    }).map(function(edge) {
      return {
        source: edge.left.data,
        target: edge.right.data
      };
    });
  },

  find: function(x, y, radius) {
    var that = this, i0, i1 = that._found || 0, n = that.cells.length, cell;

    // Use the previously-found cell, or start with an arbitrary one.
    while (!(cell = that.cells[i1])) if (++i1 >= n) return null;
    var dx = x - cell.site[0], dy = y - cell.site[1], d2 = dx * dx + dy * dy;

    // Traverse the half-edges to find a closer cell, if any.
    do {
      cell = that.cells[i0 = i1], i1 = null;
      cell.halfedges.forEach(function(e) {
        var edge = that.edges[e], v = edge.left;
        if ((v === cell.site || !v) && !(v = edge.right)) return;
        var vx = x - v[0], vy = y - v[1], v2 = vx * vx + vy * vy;
        if (v2 < d2) d2 = v2, i1 = v.index;
      });
    } while (i1 !== null);

    that._found = i0;

    return radius == null || d2 <= radius * radius ? cell.site : null;
  }
}


/***/ }),

/***/ "H39o":
/*!*************************************************!*\
  !*** ./node_modules/d3-polygon/src/centroid.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(polygon) {
  var i = -1,
      n = polygon.length,
      x = 0,
      y = 0,
      a,
      b = polygon[n - 1],
      c,
      k = 0;

  while (++i < n) {
    a = b;
    b = polygon[i];
    k += c = a[0] * b[1] - b[0] * a[1];
    x += (a[0] + b[0]) * c;
    y += (a[1] + b[1]) * c;
  }

  return k *= 3, [x / k, y / k];
});


/***/ }),

/***/ "H7P7":
/*!************************************************!*\
  !*** ./node_modules/d3-quadtree/src/extent.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(_) {
  return arguments.length
      ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])
      : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];
});


/***/ }),

/***/ "HN8k":
/*!********************************************!*\
  !*** ./node_modules/d3-fetch/src/image.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(input, init) {
  return new Promise(function(resolve, reject) {
    var image = new Image;
    for (var key in init) image[key] = init[key];
    image.onerror = reject;
    image.onload = function() { resolve(image); };
    image.src = input;
  });
});


/***/ }),

/***/ "HZff":
/*!**********************************************!*\
  !*** ./node_modules/d3-quadtree/src/find.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _quad_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./quad.js */ "p/7N");


/* harmony default export */ __webpack_exports__["default"] = (function(x, y, radius) {
  var data,
      x0 = this._x0,
      y0 = this._y0,
      x1,
      y1,
      x2,
      y2,
      x3 = this._x1,
      y3 = this._y1,
      quads = [],
      node = this._root,
      q,
      i;

  if (node) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](node, x0, y0, x3, y3));
  if (radius == null) radius = Infinity;
  else {
    x0 = x - radius, y0 = y - radius;
    x3 = x + radius, y3 = y + radius;
    radius *= radius;
  }

  while (q = quads.pop()) {

    // Stop searching if this quadrant can’t contain a closer node.
    if (!(node = q.node)
        || (x1 = q.x0) > x3
        || (y1 = q.y0) > y3
        || (x2 = q.x1) < x0
        || (y2 = q.y1) < y0) continue;

    // Bisect the current quadrant.
    if (node.length) {
      var xm = (x1 + x2) / 2,
          ym = (y1 + y2) / 2;

      quads.push(
        new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](node[3], xm, ym, x2, y2),
        new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](node[2], x1, ym, xm, y2),
        new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](node[1], xm, y1, x2, ym),
        new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](node[0], x1, y1, xm, ym)
      );

      // Visit the closest quadrant first.
      if (i = (y >= ym) << 1 | (x >= xm)) {
        q = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i];
        quads[quads.length - 1 - i] = q;
      }
    }

    // Visit this point. (Visiting coincident points isn’t necessary!)
    else {
      var dx = x - +this._x.call(null, node.data),
          dy = y - +this._y.call(null, node.data),
          d2 = dx * dx + dy * dy;
      if (d2 < radius) {
        var d = Math.sqrt(radius = d2);
        x0 = x - d, y0 = y - d;
        x3 = x + d, y3 = y + d;
        data = node.data;
      }
    }
  }

  return data;
});


/***/ }),

/***/ "Hd9g":
/*!*********************************************!*\
  !*** ./node_modules/d3-geo/src/contains.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _polygonContains_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./polygonContains.js */ "7FHc");
/* harmony import */ var _distance_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./distance.js */ "rgrl");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math.js */ "R0y8");




var containsObjectType = {
  Feature: function(object, point) {
    return containsGeometry(object.geometry, point);
  },
  FeatureCollection: function(object, point) {
    var features = object.features, i = -1, n = features.length;
    while (++i < n) if (containsGeometry(features[i].geometry, point)) return true;
    return false;
  }
};

var containsGeometryType = {
  Sphere: function() {
    return true;
  },
  Point: function(object, point) {
    return containsPoint(object.coordinates, point);
  },
  MultiPoint: function(object, point) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) if (containsPoint(coordinates[i], point)) return true;
    return false;
  },
  LineString: function(object, point) {
    return containsLine(object.coordinates, point);
  },
  MultiLineString: function(object, point) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) if (containsLine(coordinates[i], point)) return true;
    return false;
  },
  Polygon: function(object, point) {
    return containsPolygon(object.coordinates, point);
  },
  MultiPolygon: function(object, point) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) if (containsPolygon(coordinates[i], point)) return true;
    return false;
  },
  GeometryCollection: function(object, point) {
    var geometries = object.geometries, i = -1, n = geometries.length;
    while (++i < n) if (containsGeometry(geometries[i], point)) return true;
    return false;
  }
};

function containsGeometry(geometry, point) {
  return geometry && containsGeometryType.hasOwnProperty(geometry.type)
      ? containsGeometryType[geometry.type](geometry, point)
      : false;
}

function containsPoint(coordinates, point) {
  return Object(_distance_js__WEBPACK_IMPORTED_MODULE_1__["default"])(coordinates, point) === 0;
}

function containsLine(coordinates, point) {
  var ao, bo, ab;
  for (var i = 0, n = coordinates.length; i < n; i++) {
    bo = Object(_distance_js__WEBPACK_IMPORTED_MODULE_1__["default"])(coordinates[i], point);
    if (bo === 0) return true;
    if (i > 0) {
      ab = Object(_distance_js__WEBPACK_IMPORTED_MODULE_1__["default"])(coordinates[i], coordinates[i - 1]);
      if (
        ab > 0 &&
        ao <= ab &&
        bo <= ab &&
        (ao + bo - ab) * (1 - Math.pow((ao - bo) / ab, 2)) < _math_js__WEBPACK_IMPORTED_MODULE_2__["epsilon2"] * ab
      )
        return true;
    }
    ao = bo;
  }
  return false;
}

function containsPolygon(coordinates, point) {
  return !!Object(_polygonContains_js__WEBPACK_IMPORTED_MODULE_0__["default"])(coordinates.map(ringRadians), pointRadians(point));
}

function ringRadians(ring) {
  return ring = ring.map(pointRadians), ring.pop(), ring;
}

function pointRadians(point) {
  return [point[0] * _math_js__WEBPACK_IMPORTED_MODULE_2__["radians"], point[1] * _math_js__WEBPACK_IMPORTED_MODULE_2__["radians"]];
}

/* harmony default export */ __webpack_exports__["default"] = (function(object, point) {
  return (object && containsObjectType.hasOwnProperty(object.type)
      ? containsObjectType[object.type]
      : containsGeometry)(object, point);
});


/***/ }),

/***/ "HpDs":
/*!***********************************************!*\
  !*** ./node_modules/d3-chord/src/constant.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return function() {
    return x;
  };
});


/***/ }),

/***/ "INn1":
/*!***********************************************!*\
  !*** ./node_modules/d3-polygon/src/length.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(polygon) {
  var i = -1,
      n = polygon.length,
      b = polygon[n - 1],
      xa,
      ya,
      xb = b[0],
      yb = b[1],
      perimeter = 0;

  while (++i < n) {
    xa = xb;
    ya = yb;
    b = polygon[i];
    xb = b[0];
    yb = b[1];
    xa -= xb;
    ya -= yb;
    perimeter += Math.sqrt(xa * xa + ya * ya);
  }

  return perimeter;
});


/***/ }),

/***/ "IYKK":
/*!*********************************************!*\
  !*** ./node_modules/d3-geo/src/identity.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return x;
});


/***/ }),

/***/ "JIJZ":
/*!***********************************************************!*\
  !*** ./node_modules/c3/node_modules/d3-scale/src/band.js ***!
  \***********************************************************/
/*! exports provided: default, point */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return band; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "point", function() { return point; });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "sRF9");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./init */ "//NX");
/* harmony import */ var _ordinal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ordinal */ "h8aP");




function band() {
  var scale = Object(_ordinal__WEBPACK_IMPORTED_MODULE_2__["default"])().unknown(undefined),
      domain = scale.domain,
      ordinalRange = scale.range,
      range = [0, 1],
      step,
      bandwidth,
      round = false,
      paddingInner = 0,
      paddingOuter = 0,
      align = 0.5;

  delete scale.unknown;

  function rescale() {
    var n = domain().length,
        reverse = range[1] < range[0],
        start = range[reverse - 0],
        stop = range[1 - reverse];
    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
    if (round) step = Math.floor(step);
    start += (stop - start - step * (n - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
    var values = Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["range"])(n).map(function(i) { return start + step * i; });
    return ordinalRange(reverse ? values.reverse() : values);
  }

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.range = function(_) {
    return arguments.length ? (range = [+_[0], +_[1]], rescale()) : range.slice();
  };

  scale.rangeRound = function(_) {
    return range = [+_[0], +_[1]], round = true, rescale();
  };

  scale.bandwidth = function() {
    return bandwidth;
  };

  scale.step = function() {
    return step;
  };

  scale.round = function(_) {
    return arguments.length ? (round = !!_, rescale()) : round;
  };

  scale.padding = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
  };

  scale.paddingInner = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
  };

  scale.paddingOuter = function(_) {
    return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
  };

  scale.align = function(_) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
  };

  scale.copy = function() {
    return band(domain(), range)
        .round(round)
        .paddingInner(paddingInner)
        .paddingOuter(paddingOuter)
        .align(align);
  };

  return _init__WEBPACK_IMPORTED_MODULE_1__["initRange"].apply(rescale(), arguments);
}

function pointish(scale) {
  var copy = scale.copy;

  scale.padding = scale.paddingOuter;
  delete scale.paddingInner;
  delete scale.paddingOuter;

  scale.copy = function() {
    return pointish(copy());
  };

  return scale;
}

function point() {
  return pointish(band.apply(null, arguments).paddingInner(1));
}


/***/ }),

/***/ "JMsZ":
/*!******************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/categorical/Dark2.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors.js */ "ZtE7");


/* harmony default export */ __webpack_exports__["default"] = (Object(_colors_js__WEBPACK_IMPORTED_MODULE_0__["default"])("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666"));


/***/ }),

/***/ "Ke4m":
/*!*********************************************!*\
  !*** ./node_modules/d3-voronoi/src/Cell.js ***!
  \*********************************************/
/*! exports provided: createCell, cellHalfedgeStart, cellHalfedgeEnd, sortCellHalfedges, clipCells */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createCell", function() { return createCell; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cellHalfedgeStart", function() { return cellHalfedgeStart; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cellHalfedgeEnd", function() { return cellHalfedgeEnd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sortCellHalfedges", function() { return sortCellHalfedges; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clipCells", function() { return clipCells; });
/* harmony import */ var _Edge__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Edge */ "FbTJ");
/* harmony import */ var _Diagram__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Diagram */ "Go7+");



function createCell(site) {
  return _Diagram__WEBPACK_IMPORTED_MODULE_1__["cells"][site.index] = {
    site: site,
    halfedges: []
  };
}

function cellHalfedgeAngle(cell, edge) {
  var site = cell.site,
      va = edge.left,
      vb = edge.right;
  if (site === vb) vb = va, va = site;
  if (vb) return Math.atan2(vb[1] - va[1], vb[0] - va[0]);
  if (site === va) va = edge[1], vb = edge[0];
  else va = edge[0], vb = edge[1];
  return Math.atan2(va[0] - vb[0], vb[1] - va[1]);
}

function cellHalfedgeStart(cell, edge) {
  return edge[+(edge.left !== cell.site)];
}

function cellHalfedgeEnd(cell, edge) {
  return edge[+(edge.left === cell.site)];
}

function sortCellHalfedges() {
  for (var i = 0, n = _Diagram__WEBPACK_IMPORTED_MODULE_1__["cells"].length, cell, halfedges, j, m; i < n; ++i) {
    if ((cell = _Diagram__WEBPACK_IMPORTED_MODULE_1__["cells"][i]) && (m = (halfedges = cell.halfedges).length)) {
      var index = new Array(m),
          array = new Array(m);
      for (j = 0; j < m; ++j) index[j] = j, array[j] = cellHalfedgeAngle(cell, _Diagram__WEBPACK_IMPORTED_MODULE_1__["edges"][halfedges[j]]);
      index.sort(function(i, j) { return array[j] - array[i]; });
      for (j = 0; j < m; ++j) array[j] = halfedges[index[j]];
      for (j = 0; j < m; ++j) halfedges[j] = array[j];
    }
  }
}

function clipCells(x0, y0, x1, y1) {
  var nCells = _Diagram__WEBPACK_IMPORTED_MODULE_1__["cells"].length,
      iCell,
      cell,
      site,
      iHalfedge,
      halfedges,
      nHalfedges,
      start,
      startX,
      startY,
      end,
      endX,
      endY,
      cover = true;

  for (iCell = 0; iCell < nCells; ++iCell) {
    if (cell = _Diagram__WEBPACK_IMPORTED_MODULE_1__["cells"][iCell]) {
      site = cell.site;
      halfedges = cell.halfedges;
      iHalfedge = halfedges.length;

      // Remove any dangling clipped edges.
      while (iHalfedge--) {
        if (!_Diagram__WEBPACK_IMPORTED_MODULE_1__["edges"][halfedges[iHalfedge]]) {
          halfedges.splice(iHalfedge, 1);
        }
      }

      // Insert any border edges as necessary.
      iHalfedge = 0, nHalfedges = halfedges.length;
      while (iHalfedge < nHalfedges) {
        end = cellHalfedgeEnd(cell, _Diagram__WEBPACK_IMPORTED_MODULE_1__["edges"][halfedges[iHalfedge]]), endX = end[0], endY = end[1];
        start = cellHalfedgeStart(cell, _Diagram__WEBPACK_IMPORTED_MODULE_1__["edges"][halfedges[++iHalfedge % nHalfedges]]), startX = start[0], startY = start[1];
        if (Math.abs(endX - startX) > _Diagram__WEBPACK_IMPORTED_MODULE_1__["epsilon"] || Math.abs(endY - startY) > _Diagram__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) {
          halfedges.splice(iHalfedge, 0, _Diagram__WEBPACK_IMPORTED_MODULE_1__["edges"].push(Object(_Edge__WEBPACK_IMPORTED_MODULE_0__["createBorderEdge"])(site, end,
              Math.abs(endX - x0) < _Diagram__WEBPACK_IMPORTED_MODULE_1__["epsilon"] && y1 - endY > _Diagram__WEBPACK_IMPORTED_MODULE_1__["epsilon"] ? [x0, Math.abs(startX - x0) < _Diagram__WEBPACK_IMPORTED_MODULE_1__["epsilon"] ? startY : y1]
              : Math.abs(endY - y1) < _Diagram__WEBPACK_IMPORTED_MODULE_1__["epsilon"] && x1 - endX > _Diagram__WEBPACK_IMPORTED_MODULE_1__["epsilon"] ? [Math.abs(startY - y1) < _Diagram__WEBPACK_IMPORTED_MODULE_1__["epsilon"] ? startX : x1, y1]
              : Math.abs(endX - x1) < _Diagram__WEBPACK_IMPORTED_MODULE_1__["epsilon"] && endY - y0 > _Diagram__WEBPACK_IMPORTED_MODULE_1__["epsilon"] ? [x1, Math.abs(startX - x1) < _Diagram__WEBPACK_IMPORTED_MODULE_1__["epsilon"] ? startY : y0]
              : Math.abs(endY - y0) < _Diagram__WEBPACK_IMPORTED_MODULE_1__["epsilon"] && endX - x0 > _Diagram__WEBPACK_IMPORTED_MODULE_1__["epsilon"] ? [Math.abs(startY - y0) < _Diagram__WEBPACK_IMPORTED_MODULE_1__["epsilon"] ? startX : x0, y0]
              : null)) - 1);
          ++nHalfedges;
        }
      }

      if (nHalfedges) cover = false;
    }
  }

  // If there weren’t any edges, have the closest site cover the extent.
  // It doesn’t matter which corner of the extent we measure!
  if (cover) {
    var dx, dy, d2, dc = Infinity;

    for (iCell = 0, cover = null; iCell < nCells; ++iCell) {
      if (cell = _Diagram__WEBPACK_IMPORTED_MODULE_1__["cells"][iCell]) {
        site = cell.site;
        dx = site[0] - x0;
        dy = site[1] - y0;
        d2 = dx * dx + dy * dy;
        if (d2 < dc) dc = d2, cover = cell;
      }
    }

    if (cover) {
      var v00 = [x0, y0], v01 = [x0, y1], v11 = [x1, y1], v10 = [x1, y0];
      cover.halfedges.push(
        _Diagram__WEBPACK_IMPORTED_MODULE_1__["edges"].push(Object(_Edge__WEBPACK_IMPORTED_MODULE_0__["createBorderEdge"])(site = cover.site, v00, v01)) - 1,
        _Diagram__WEBPACK_IMPORTED_MODULE_1__["edges"].push(Object(_Edge__WEBPACK_IMPORTED_MODULE_0__["createBorderEdge"])(site, v01, v11)) - 1,
        _Diagram__WEBPACK_IMPORTED_MODULE_1__["edges"].push(Object(_Edge__WEBPACK_IMPORTED_MODULE_0__["createBorderEdge"])(site, v11, v10)) - 1,
        _Diagram__WEBPACK_IMPORTED_MODULE_1__["edges"].push(Object(_Edge__WEBPACK_IMPORTED_MODULE_0__["createBorderEdge"])(site, v10, v00)) - 1
      );
    }
  }

  // Lastly delete any cells with no edges; these were entirely clipped.
  for (iCell = 0; iCell < nCells; ++iCell) {
    if (cell = _Diagram__WEBPACK_IMPORTED_MODULE_1__["cells"][iCell]) {
      if (!cell.halfedges.length) {
        delete _Diagram__WEBPACK_IMPORTED_MODULE_1__["cells"][iCell];
      }
    }
  }
}


/***/ }),

/***/ "Kljt":
/*!***********************************************!*\
  !*** ./node_modules/d3-voronoi/src/Circle.js ***!
  \***********************************************/
/*! exports provided: firstCircle, attachCircle, detachCircle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "firstCircle", function() { return firstCircle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "attachCircle", function() { return attachCircle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "detachCircle", function() { return detachCircle; });
/* harmony import */ var _RedBlackTree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RedBlackTree */ "AyFX");
/* harmony import */ var _Diagram__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Diagram */ "Go7+");



var circlePool = [];

var firstCircle;

function Circle() {
  Object(_RedBlackTree__WEBPACK_IMPORTED_MODULE_0__["RedBlackNode"])(this);
  this.x =
  this.y =
  this.arc =
  this.site =
  this.cy = null;
}

function attachCircle(arc) {
  var lArc = arc.P,
      rArc = arc.N;

  if (!lArc || !rArc) return;

  var lSite = lArc.site,
      cSite = arc.site,
      rSite = rArc.site;

  if (lSite === rSite) return;

  var bx = cSite[0],
      by = cSite[1],
      ax = lSite[0] - bx,
      ay = lSite[1] - by,
      cx = rSite[0] - bx,
      cy = rSite[1] - by;

  var d = 2 * (ax * cy - ay * cx);
  if (d >= -_Diagram__WEBPACK_IMPORTED_MODULE_1__["epsilon2"]) return;

  var ha = ax * ax + ay * ay,
      hc = cx * cx + cy * cy,
      x = (cy * ha - ay * hc) / d,
      y = (ax * hc - cx * ha) / d;

  var circle = circlePool.pop() || new Circle;
  circle.arc = arc;
  circle.site = cSite;
  circle.x = x + bx;
  circle.y = (circle.cy = y + by) + Math.sqrt(x * x + y * y); // y bottom

  arc.circle = circle;

  var before = null,
      node = _Diagram__WEBPACK_IMPORTED_MODULE_1__["circles"]._;

  while (node) {
    if (circle.y < node.y || (circle.y === node.y && circle.x <= node.x)) {
      if (node.L) node = node.L;
      else { before = node.P; break; }
    } else {
      if (node.R) node = node.R;
      else { before = node; break; }
    }
  }

  _Diagram__WEBPACK_IMPORTED_MODULE_1__["circles"].insert(before, circle);
  if (!before) firstCircle = circle;
}

function detachCircle(arc) {
  var circle = arc.circle;
  if (circle) {
    if (!circle.P) firstCircle = circle.N;
    _Diagram__WEBPACK_IMPORTED_MODULE_1__["circles"].remove(circle);
    circlePool.push(circle);
    Object(_RedBlackTree__WEBPACK_IMPORTED_MODULE_0__["RedBlackNode"])(circle);
    arc.circle = null;
  }
}


/***/ }),

/***/ "LMxf":
/*!**********************************************!*\
  !*** ./node_modules/d3-quadtree/src/data.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function() {
  var data = [];
  this.visit(function(node) {
    if (!node.length) do data.push(node.data); while (node = node.next)
  });
  return data;
});


/***/ }),

/***/ "LP84":
/*!************************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/orthographic.js ***!
  \************************************************************/
/*! exports provided: orthographicRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "orthographicRaw", function() { return orthographicRaw; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "R0y8");
/* harmony import */ var _azimuthal_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./azimuthal.js */ "dg0l");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.js */ "1ibS");




function orthographicRaw(x, y) {
  return [Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["cos"])(y) * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sin"])(x), Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sin"])(y)];
}

orthographicRaw.invert = Object(_azimuthal_js__WEBPACK_IMPORTED_MODULE_1__["azimuthalInvert"])(_math_js__WEBPACK_IMPORTED_MODULE_0__["asin"]);

/* harmony default export */ __webpack_exports__["default"] = (function() {
  return Object(_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(orthographicRaw)
      .scale(249.5)
      .clipAngle(90 + _math_js__WEBPACK_IMPORTED_MODULE_0__["epsilon"]);
});


/***/ }),

/***/ "LSUK":
/*!***************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/diverging/RdGy.js ***!
  \***************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors.js */ "ZtE7");
/* harmony import */ var _ramp_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp.js */ "jQWc");



var scheme = new Array(3).concat(
  "ef8a62ffffff999999",
  "ca0020f4a582bababa404040",
  "ca0020f4a582ffffffbababa404040",
  "b2182bef8a62fddbc7e0e0e09999994d4d4d",
  "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d",
  "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d",
  "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d",
  "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a",
  "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a"
).map(_colors_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp_js__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "LV99":
/*!*******************************!*\
  !*** ./node_modules/c3/c3.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* @license C3.js v0.7.20 | (c) C3 Team and other contributors | http://c3js.org/ */
(function (global, factory) {
   true ? module.exports = factory() :
  undefined;
}(this, (function () { 'use strict';

  function ChartInternal(api) {
      var $$ = this;
      // Note: This part will be replaced by rollup-plugin-modify
      // When bundling esm output. Beware of changing this line.
      // TODO: Maybe we should check that the modification by rollup-plugin-modify
      // is valid during unit tests.
      $$.d3 = window.d3
          ? window.d3
          :  true
              ? __webpack_require__(/*! d3 */ "UQyC")
              : undefined;
      $$.api = api;
      $$.config = $$.getDefaultConfig();
      $$.data = {};
      $$.cache = {};
      $$.axes = {};
  }

  /**
   * The Chart class
   *
   * The methods of this class is the public APIs of the chart object.
   */
  function Chart(config) {
      this.internal = new ChartInternal(this);
      this.internal.loadConfig(config);
      this.internal.beforeInit(config);
      this.internal.init();
      this.internal.afterInit(config);
      (function bindThis(fn, target, argThis) {
          Object.keys(fn).forEach(function (key) {
              target[key] = fn[key].bind(argThis);
              if (Object.keys(fn[key]).length > 0) {
                  bindThis(fn[key], target[key], argThis);
              }
          });
      })(Chart.prototype, this, this);
  }

  var asHalfPixel = function (n) {
      return Math.ceil(n) + 0.5;
  };
  var ceil10 = function (v) {
      return Math.ceil(v / 10) * 10;
  };
  var diffDomain = function (d) {
      return d[1] - d[0];
  };
  var getOption = function (options, key, defaultValue) {
      return isDefined(options[key]) ? options[key] : defaultValue;
  };
  var getPathBox = function (path) {
      var box = getBBox(path), items = [path.pathSegList.getItem(0), path.pathSegList.getItem(1)], minX = items[0].x, minY = Math.min(items[0].y, items[1].y);
      return { x: minX, y: minY, width: box.width, height: box.height };
  };
  var getBBox = function (element) {
      try {
          return element.getBBox();
      }
      catch (ignore) {
          // Firefox will throw an exception if getBBox() is called whereas the
          // element is rendered with display:none
          // See https://github.com/c3js/c3/issues/2692
          // The previous code was using `getBoundingClientRect` which was returning
          // everything at 0 in this case so let's reproduce this behavior here.
          return { x: 0, y: 0, width: 0, height: 0 };
      }
  };
  var hasValue = function (dict, value) {
      var found = false;
      Object.keys(dict).forEach(function (key) {
          if (dict[key] === value) {
              found = true;
          }
      });
      return found;
  };
  var isArray = function (o) {
      return Array.isArray(o);
  };
  var isDefined = function (v) {
      return typeof v !== 'undefined';
  };
  var isEmpty = function (o) {
      return (typeof o === 'undefined' ||
          o === null ||
          (isString(o) && o.length === 0) ||
          (typeof o === 'object' && Object.keys(o).length === 0));
  };
  var isFunction = function (o) {
      return typeof o === 'function';
  };
  var isNumber = function (o) {
      return typeof o === 'number';
  };
  var isString = function (o) {
      return typeof o === 'string';
  };
  var isUndefined = function (v) {
      return typeof v === 'undefined';
  };
  var isValue = function (v) {
      return v || v === 0;
  };
  var notEmpty = function (o) {
      return !isEmpty(o);
  };
  var sanitise = function (str) {
      return typeof str === 'string'
          ? str.replace(/</g, '&lt;').replace(/>/g, '&gt;')
          : str;
  };
  var flattenArray = function (arr) {
      return Array.isArray(arr) ? [].concat.apply([], arr) : [];
  };
  /**
   * Returns whether the point is within the given box.
   *
   * @param {Array} point An [x,y] coordinate
   * @param {Object} box An object with {x, y, width, height} keys
   * @param {Number} sensitivity An offset to ease check on very small boxes
   */
  var isWithinBox = function (point, box, sensitivity) {
      if (sensitivity === void 0) { sensitivity = 0; }
      var xStart = box.x - sensitivity;
      var xEnd = box.x + box.width + sensitivity;
      var yStart = box.y + box.height + sensitivity;
      var yEnd = box.y - sensitivity;
      return (xStart < point[0] && point[0] < xEnd && yEnd < point[1] && point[1] < yStart);
  };
  /**
   * Returns Internet Explorer version number (or false if no Internet Explorer used).
   *
   * @param string agent Optional parameter to specify user agent
   */
  var getIEVersion = function (agent) {
      // https://stackoverflow.com/questions/19999388/check-if-user-is-using-ie
      if (typeof agent === 'undefined') {
          agent = window.navigator.userAgent;
      }
      var pos = agent.indexOf('MSIE '); // up to IE10
      if (pos > 0) {
          return parseInt(agent.substring(pos + 5, agent.indexOf('.', pos)), 10);
      }
      pos = agent.indexOf('Trident/'); // IE11
      if (pos > 0) {
          pos = agent.indexOf('rv:');
          return parseInt(agent.substring(pos + 3, agent.indexOf('.', pos)), 10);
      }
      return false;
  };
  /**
   * Returns whether the used browser is Internet Explorer.
   *
   * @param version Optional parameter to specify IE version
   */
  var isIE = function (version) {
      var ver = getIEVersion();
      if (typeof version === 'undefined') {
          return !!ver;
      }
      return version === ver;
  };

  function AxisInternal(component, params) {
      var internal = this;
      internal.component = component;
      internal.params = params || {};
      internal.d3 = component.d3;
      internal.scale = internal.d3.scaleLinear();
      internal.range;
      internal.orient = 'bottom';
      internal.innerTickSize = 6;
      internal.outerTickSize = this.params.withOuterTick ? 6 : 0;
      internal.tickPadding = 3;
      internal.tickValues = null;
      internal.tickFormat;
      internal.tickArguments;
      internal.tickOffset = 0;
      internal.tickCulling = true;
      internal.tickCentered;
      internal.tickTextCharSize;
      internal.tickTextRotate = internal.params.tickTextRotate;
      internal.tickLength;
      internal.axis = internal.generateAxis();
  }
  AxisInternal.prototype.axisX = function (selection, x, tickOffset) {
      selection.attr('transform', function (d) {
          return 'translate(' + Math.ceil(x(d) + tickOffset) + ', 0)';
      });
  };
  AxisInternal.prototype.axisY = function (selection, y) {
      selection.attr('transform', function (d) {
          return 'translate(0,' + Math.ceil(y(d)) + ')';
      });
  };
  AxisInternal.prototype.scaleExtent = function (domain) {
      var start = domain[0], stop = domain[domain.length - 1];
      return start < stop ? [start, stop] : [stop, start];
  };
  AxisInternal.prototype.generateTicks = function (scale) {
      var internal = this;
      var i, domain, ticks = [];
      if (scale.ticks) {
          return scale.ticks.apply(scale, internal.tickArguments);
      }
      domain = scale.domain();
      for (i = Math.ceil(domain[0]); i < domain[1]; i++) {
          ticks.push(i);
      }
      if (ticks.length > 0 && ticks[0] > 0) {
          ticks.unshift(ticks[0] - (ticks[1] - ticks[0]));
      }
      return ticks;
  };
  AxisInternal.prototype.copyScale = function () {
      var internal = this;
      var newScale = internal.scale.copy(), domain;
      if (internal.params.isCategory) {
          domain = internal.scale.domain();
          newScale.domain([domain[0], domain[1] - 1]);
      }
      return newScale;
  };
  AxisInternal.prototype.textFormatted = function (v) {
      var internal = this, formatted = internal.tickFormat ? internal.tickFormat(v) : v;
      return typeof formatted !== 'undefined' ? formatted : '';
  };
  AxisInternal.prototype.updateRange = function () {
      var internal = this;
      internal.range = internal.scale.rangeExtent
          ? internal.scale.rangeExtent()
          : internal.scaleExtent(internal.scale.range());
      return internal.range;
  };
  AxisInternal.prototype.updateTickTextCharSize = function (tick) {
      var internal = this;
      if (internal.tickTextCharSize) {
          return internal.tickTextCharSize;
      }
      var size = {
          h: 11.5,
          w: 5.5
      };
      tick
          .select('text')
          .text(function (d) {
          return internal.textFormatted(d);
      })
          .each(function (d) {
          var box = getBBox(this), text = internal.textFormatted(d), h = box.height, w = text ? box.width / text.length : undefined;
          if (h && w) {
              size.h = h;
              size.w = w;
          }
      })
          .text('');
      internal.tickTextCharSize = size;
      return size;
  };
  AxisInternal.prototype.isVertical = function () {
      return this.orient === 'left' || this.orient === 'right';
  };
  AxisInternal.prototype.tspanData = function (d, i, scale) {
      var internal = this;
      var splitted = internal.params.tickMultiline
          ? internal.splitTickText(d, scale)
          : [].concat(internal.textFormatted(d));
      if (internal.params.tickMultiline && internal.params.tickMultilineMax > 0) {
          splitted = internal.ellipsify(splitted, internal.params.tickMultilineMax);
      }
      return splitted.map(function (s) {
          return { index: i, splitted: s, length: splitted.length };
      });
  };
  AxisInternal.prototype.splitTickText = function (d, scale) {
      var internal = this, tickText = internal.textFormatted(d), maxWidth = internal.params.tickWidth, subtext, spaceIndex, textWidth, splitted = [];
      if (Object.prototype.toString.call(tickText) === '[object Array]') {
          return tickText;
      }
      if (!maxWidth || maxWidth <= 0) {
          maxWidth = internal.isVertical()
              ? 95
              : internal.params.isCategory
                  ? Math.ceil(scale(1) - scale(0)) - 12
                  : 110;
      }
      function split(splitted, text) {
          spaceIndex = undefined;
          for (var i = 1; i < text.length; i++) {
              if (text.charAt(i) === ' ') {
                  spaceIndex = i;
              }
              subtext = text.substr(0, i + 1);
              textWidth = internal.tickTextCharSize.w * subtext.length;
              // if text width gets over tick width, split by space index or crrent index
              if (maxWidth < textWidth) {
                  return split(splitted.concat(text.substr(0, spaceIndex ? spaceIndex : i)), text.slice(spaceIndex ? spaceIndex + 1 : i));
              }
          }
          return splitted.concat(text);
      }
      return split(splitted, tickText + '');
  };
  AxisInternal.prototype.ellipsify = function (splitted, max) {
      if (splitted.length <= max) {
          return splitted;
      }
      var ellipsified = splitted.slice(0, max);
      var remaining = 3;
      for (var i = max - 1; i >= 0; i--) {
          var available = ellipsified[i].length;
          ellipsified[i] = ellipsified[i]
              .substr(0, available - remaining)
              .padEnd(available, '.');
          remaining -= available;
          if (remaining <= 0) {
              break;
          }
      }
      return ellipsified;
  };
  AxisInternal.prototype.updateTickLength = function () {
      var internal = this;
      internal.tickLength =
          Math.max(internal.innerTickSize, 0) + internal.tickPadding;
  };
  AxisInternal.prototype.lineY2 = function (d) {
      var internal = this, tickPosition = internal.scale(d) + (internal.tickCentered ? 0 : internal.tickOffset);
      return internal.range[0] < tickPosition && tickPosition < internal.range[1]
          ? internal.innerTickSize
          : 0;
  };
  AxisInternal.prototype.textY = function () {
      var internal = this, rotate = internal.tickTextRotate;
      return rotate
          ? 11.5 - 2.5 * (rotate / 15) * (rotate > 0 ? 1 : -1)
          : internal.tickLength;
  };
  AxisInternal.prototype.textTransform = function () {
      var internal = this, rotate = internal.tickTextRotate;
      return rotate ? 'rotate(' + rotate + ')' : '';
  };
  AxisInternal.prototype.textTextAnchor = function () {
      var internal = this, rotate = internal.tickTextRotate;
      return rotate ? (rotate > 0 ? 'start' : 'end') : 'middle';
  };
  AxisInternal.prototype.tspanDx = function () {
      var internal = this, rotate = internal.tickTextRotate;
      return rotate ? 8 * Math.sin(Math.PI * (rotate / 180)) : 0;
  };
  AxisInternal.prototype.tspanDy = function (d, i) {
      var internal = this, dy = internal.tickTextCharSize.h;
      if (i === 0) {
          if (internal.isVertical()) {
              dy = -((d.length - 1) * (internal.tickTextCharSize.h / 2) - 3);
          }
          else {
              dy = '.71em';
          }
      }
      return dy;
  };
  AxisInternal.prototype.generateAxis = function () {
      var internal = this, d3 = internal.d3, params = internal.params;
      function axis(g, transition) {
          var self;
          g.each(function () {
              var g = (axis.g = d3.select(this));
              var scale0 = this.__chart__ || internal.scale, scale1 = (this.__chart__ = internal.copyScale());
              var ticksValues = internal.tickValues
                  ? internal.tickValues
                  : internal.generateTicks(scale1), ticks = g.selectAll('.tick').data(ticksValues, scale1), tickEnter = ticks
                  .enter()
                  .insert('g', '.domain')
                  .attr('class', 'tick')
                  .style('opacity', 1e-6), 
              // MEMO: No exit transition. The reason is this transition affects max tick width calculation because old tick will be included in the ticks.
              tickExit = ticks.exit().remove(), tickUpdate = ticks.merge(tickEnter), tickTransform, tickX, tickY;
              if (params.isCategory) {
                  internal.tickOffset = Math.ceil((scale1(1) - scale1(0)) / 2);
                  tickX = internal.tickCentered ? 0 : internal.tickOffset;
                  tickY = internal.tickCentered ? internal.tickOffset : 0;
              }
              else {
                  internal.tickOffset = tickX = 0;
              }
              internal.updateRange();
              internal.updateTickLength();
              internal.updateTickTextCharSize(g.select('.tick'));
              var lineUpdate = tickUpdate
                  .select('line')
                  .merge(tickEnter.append('line')), textUpdate = tickUpdate.select('text').merge(tickEnter.append('text'));
              var tspans = tickUpdate
                  .selectAll('text')
                  .selectAll('tspan')
                  .data(function (d, i) {
                  return internal.tspanData(d, i, scale1);
              }), tspanEnter = tspans.enter().append('tspan'), tspanUpdate = tspanEnter.merge(tspans).text(function (d) {
                  return d.splitted;
              });
              tspans.exit().remove();
              var path = g.selectAll('.domain').data([0]), pathUpdate = path
                  .enter()
                  .append('path')
                  .merge(path)
                  .attr('class', 'domain');
              // TODO: each attr should be one function and change its behavior by internal.orient, probably
              switch (internal.orient) {
                  case 'bottom': {
                      tickTransform = internal.axisX;
                      lineUpdate
                          .attr('x1', tickX)
                          .attr('x2', tickX)
                          .attr('y2', function (d, i) {
                          return internal.lineY2(d, i);
                      });
                      textUpdate
                          .attr('x', 0)
                          .attr('y', function (d, i) {
                          return internal.textY(d, i);
                      })
                          .attr('transform', function (d, i) {
                          return internal.textTransform(d, i);
                      })
                          .style('text-anchor', function (d, i) {
                          return internal.textTextAnchor(d, i);
                      });
                      tspanUpdate
                          .attr('x', 0)
                          .attr('dy', function (d, i) {
                          return internal.tspanDy(d, i);
                      })
                          .attr('dx', function (d, i) {
                          return internal.tspanDx(d, i);
                      });
                      pathUpdate.attr('d', 'M' +
                          internal.range[0] +
                          ',' +
                          internal.outerTickSize +
                          'V0H' +
                          internal.range[1] +
                          'V' +
                          internal.outerTickSize);
                      break;
                  }
                  case 'top': {
                      // TODO: rotated tick text
                      tickTransform = internal.axisX;
                      lineUpdate
                          .attr('x1', tickX)
                          .attr('x2', tickX)
                          .attr('y2', function (d, i) {
                          return -1 * internal.lineY2(d, i);
                      });
                      textUpdate
                          .attr('x', 0)
                          .attr('y', function (d, i) {
                          return (-1 * internal.textY(d, i) -
                              (params.isCategory ? 2 : internal.tickLength - 2));
                      })
                          .attr('transform', function (d, i) {
                          return internal.textTransform(d, i);
                      })
                          .style('text-anchor', function (d, i) {
                          return internal.textTextAnchor(d, i);
                      });
                      tspanUpdate
                          .attr('x', 0)
                          .attr('dy', function (d, i) {
                          return internal.tspanDy(d, i);
                      })
                          .attr('dx', function (d, i) {
                          return internal.tspanDx(d, i);
                      });
                      pathUpdate.attr('d', 'M' +
                          internal.range[0] +
                          ',' +
                          -internal.outerTickSize +
                          'V0H' +
                          internal.range[1] +
                          'V' +
                          -internal.outerTickSize);
                      break;
                  }
                  case 'left': {
                      tickTransform = internal.axisY;
                      lineUpdate
                          .attr('x2', -internal.innerTickSize)
                          .attr('y1', tickY)
                          .attr('y2', tickY);
                      textUpdate
                          .attr('x', -internal.tickLength)
                          .attr('y', internal.tickOffset)
                          .style('text-anchor', 'end');
                      tspanUpdate
                          .attr('x', -internal.tickLength)
                          .attr('dy', function (d, i) {
                          return internal.tspanDy(d, i);
                      });
                      pathUpdate.attr('d', 'M' +
                          -internal.outerTickSize +
                          ',' +
                          internal.range[0] +
                          'H0V' +
                          internal.range[1] +
                          'H' +
                          -internal.outerTickSize);
                      break;
                  }
                  case 'right': {
                      tickTransform = internal.axisY;
                      lineUpdate
                          .attr('x2', internal.innerTickSize)
                          .attr('y1', tickY)
                          .attr('y2', tickY);
                      textUpdate
                          .attr('x', internal.tickLength)
                          .attr('y', internal.tickOffset)
                          .style('text-anchor', 'start');
                      tspanUpdate.attr('x', internal.tickLength).attr('dy', function (d, i) {
                          return internal.tspanDy(d, i);
                      });
                      pathUpdate.attr('d', 'M' +
                          internal.outerTickSize +
                          ',' +
                          internal.range[0] +
                          'H0V' +
                          internal.range[1] +
                          'H' +
                          internal.outerTickSize);
                      break;
                  }
              }
              if (scale1.rangeBand) {
                  var x = scale1, dx = x.rangeBand() / 2;
                  scale0 = scale1 = function (d) {
                      return x(d) + dx;
                  };
              }
              else if (scale0.rangeBand) {
                  scale0 = scale1;
              }
              else {
                  tickExit.call(tickTransform, scale1, internal.tickOffset);
              }
              tickEnter.call(tickTransform, scale0, internal.tickOffset);
              self = (transition ? tickUpdate.transition(transition) : tickUpdate)
                  .style('opacity', 1)
                  .call(tickTransform, scale1, internal.tickOffset);
          });
          return self;
      }
      axis.scale = function (x) {
          if (!arguments.length) {
              return internal.scale;
          }
          internal.scale = x;
          return axis;
      };
      axis.orient = function (x) {
          if (!arguments.length) {
              return internal.orient;
          }
          internal.orient =
              x in { top: 1, right: 1, bottom: 1, left: 1 } ? x + '' : 'bottom';
          return axis;
      };
      axis.tickFormat = function (format) {
          if (!arguments.length) {
              return internal.tickFormat;
          }
          internal.tickFormat = format;
          return axis;
      };
      axis.tickCentered = function (isCentered) {
          if (!arguments.length) {
              return internal.tickCentered;
          }
          internal.tickCentered = isCentered;
          return axis;
      };
      axis.tickOffset = function () {
          return internal.tickOffset;
      };
      axis.tickInterval = function () {
          var interval, length;
          if (params.isCategory) {
              interval = internal.tickOffset * 2;
          }
          else {
              length =
                  axis.g
                      .select('path.domain')
                      .node()
                      .getTotalLength() -
                      internal.outerTickSize * 2;
              interval = length / axis.g.selectAll('line').size();
          }
          return interval === Infinity ? 0 : interval;
      };
      axis.ticks = function () {
          if (!arguments.length) {
              return internal.tickArguments;
          }
          internal.tickArguments = arguments;
          return axis;
      };
      axis.tickCulling = function (culling) {
          if (!arguments.length) {
              return internal.tickCulling;
          }
          internal.tickCulling = culling;
          return axis;
      };
      axis.tickValues = function (x) {
          if (typeof x === 'function') {
              internal.tickValues = function () {
                  return x(internal.scale.domain());
              };
          }
          else {
              if (!arguments.length) {
                  return internal.tickValues;
              }
              internal.tickValues = x;
          }
          return axis;
      };
      return axis;
  };

  var CLASS = {
      target: 'c3-target',
      chart: 'c3-chart',
      chartLine: 'c3-chart-line',
      chartLines: 'c3-chart-lines',
      chartBar: 'c3-chart-bar',
      chartBars: 'c3-chart-bars',
      chartText: 'c3-chart-text',
      chartTexts: 'c3-chart-texts',
      chartArc: 'c3-chart-arc',
      chartArcs: 'c3-chart-arcs',
      chartArcsTitle: 'c3-chart-arcs-title',
      chartArcsBackground: 'c3-chart-arcs-background',
      chartArcsGaugeUnit: 'c3-chart-arcs-gauge-unit',
      chartArcsGaugeMax: 'c3-chart-arcs-gauge-max',
      chartArcsGaugeMin: 'c3-chart-arcs-gauge-min',
      selectedCircle: 'c3-selected-circle',
      selectedCircles: 'c3-selected-circles',
      eventRect: 'c3-event-rect',
      eventRects: 'c3-event-rects',
      eventRectsSingle: 'c3-event-rects-single',
      eventRectsMultiple: 'c3-event-rects-multiple',
      zoomRect: 'c3-zoom-rect',
      brush: 'c3-brush',
      dragZoom: 'c3-drag-zoom',
      focused: 'c3-focused',
      defocused: 'c3-defocused',
      region: 'c3-region',
      regions: 'c3-regions',
      title: 'c3-title',
      tooltipContainer: 'c3-tooltip-container',
      tooltip: 'c3-tooltip',
      tooltipName: 'c3-tooltip-name',
      shape: 'c3-shape',
      shapes: 'c3-shapes',
      line: 'c3-line',
      lines: 'c3-lines',
      bar: 'c3-bar',
      bars: 'c3-bars',
      circle: 'c3-circle',
      circles: 'c3-circles',
      arc: 'c3-arc',
      arcLabelLine: 'c3-arc-label-line',
      arcs: 'c3-arcs',
      area: 'c3-area',
      areas: 'c3-areas',
      empty: 'c3-empty',
      text: 'c3-text',
      texts: 'c3-texts',
      gaugeValue: 'c3-gauge-value',
      grid: 'c3-grid',
      gridLines: 'c3-grid-lines',
      xgrid: 'c3-xgrid',
      xgrids: 'c3-xgrids',
      xgridLine: 'c3-xgrid-line',
      xgridLines: 'c3-xgrid-lines',
      xgridFocus: 'c3-xgrid-focus',
      ygrid: 'c3-ygrid',
      ygrids: 'c3-ygrids',
      ygridLine: 'c3-ygrid-line',
      ygridLines: 'c3-ygrid-lines',
      colorScale: 'c3-colorscale',
      stanfordElements: 'c3-stanford-elements',
      stanfordLine: 'c3-stanford-line',
      stanfordLines: 'c3-stanford-lines',
      stanfordRegion: 'c3-stanford-region',
      stanfordRegions: 'c3-stanford-regions',
      stanfordText: 'c3-stanford-text',
      stanfordTexts: 'c3-stanford-texts',
      axis: 'c3-axis',
      axisX: 'c3-axis-x',
      axisXLabel: 'c3-axis-x-label',
      axisY: 'c3-axis-y',
      axisYLabel: 'c3-axis-y-label',
      axisY2: 'c3-axis-y2',
      axisY2Label: 'c3-axis-y2-label',
      legendBackground: 'c3-legend-background',
      legendItem: 'c3-legend-item',
      legendItemEvent: 'c3-legend-item-event',
      legendItemTile: 'c3-legend-item-tile',
      legendItemHidden: 'c3-legend-item-hidden',
      legendItemFocused: 'c3-legend-item-focused',
      dragarea: 'c3-dragarea',
      EXPANDED: '_expanded_',
      SELECTED: '_selected_',
      INCLUDED: '_included_'
  };

  var AxisClass = /** @class */ (function () {
      function AxisClass(owner) {
          this.owner = owner;
          this.d3 = owner.d3;
          this.internal = AxisInternal;
      }
      return AxisClass;
  }());
  var Axis = AxisClass;
  Axis.prototype.init = function init() {
      var $$ = this.owner, config = $$.config, main = $$.main;
      $$.axes.x = main
          .append('g')
          .attr('class', CLASS.axis + ' ' + CLASS.axisX)
          .attr('clip-path', config.axis_x_inner ? '' : $$.clipPathForXAxis)
          .attr('transform', $$.getTranslate('x'))
          .style('visibility', config.axis_x_show ? 'visible' : 'hidden');
      $$.axes.x
          .append('text')
          .attr('class', CLASS.axisXLabel)
          .attr('transform', config.axis_rotated ? 'rotate(-90)' : '')
          .style('text-anchor', this.textAnchorForXAxisLabel.bind(this));
      $$.axes.y = main
          .append('g')
          .attr('class', CLASS.axis + ' ' + CLASS.axisY)
          .attr('clip-path', config.axis_y_inner ? '' : $$.clipPathForYAxis)
          .attr('transform', $$.getTranslate('y'))
          .style('visibility', config.axis_y_show ? 'visible' : 'hidden');
      $$.axes.y
          .append('text')
          .attr('class', CLASS.axisYLabel)
          .attr('transform', config.axis_rotated ? '' : 'rotate(-90)')
          .style('text-anchor', this.textAnchorForYAxisLabel.bind(this));
      $$.axes.y2 = main
          .append('g')
          .attr('class', CLASS.axis + ' ' + CLASS.axisY2)
          // clip-path?
          .attr('transform', $$.getTranslate('y2'))
          .style('visibility', config.axis_y2_show ? 'visible' : 'hidden');
      $$.axes.y2
          .append('text')
          .attr('class', CLASS.axisY2Label)
          .attr('transform', config.axis_rotated ? '' : 'rotate(-90)')
          .style('text-anchor', this.textAnchorForY2AxisLabel.bind(this));
  };
  Axis.prototype.getXAxis = function getXAxis(scale, orient, tickFormat, tickValues, withOuterTick, withoutTransition, withoutRotateTickText) {
      var $$ = this.owner, config = $$.config, axisParams = {
          isCategory: $$.isCategorized(),
          withOuterTick: withOuterTick,
          tickMultiline: config.axis_x_tick_multiline,
          tickMultilineMax: config.axis_x_tick_multiline
              ? Number(config.axis_x_tick_multilineMax)
              : 0,
          tickWidth: config.axis_x_tick_width,
          tickTextRotate: withoutRotateTickText ? 0 : config.axis_x_tick_rotate,
          withoutTransition: withoutTransition
      }, axis = new this.internal(this, axisParams).axis.scale(scale).orient(orient);
      if ($$.isTimeSeries() && tickValues && typeof tickValues !== 'function') {
          tickValues = tickValues.map(function (v) {
              return $$.parseDate(v);
          });
      }
      // Set tick
      axis.tickFormat(tickFormat).tickValues(tickValues);
      if ($$.isCategorized()) {
          axis.tickCentered(config.axis_x_tick_centered);
          if (isEmpty(config.axis_x_tick_culling)) {
              config.axis_x_tick_culling = false;
          }
      }
      return axis;
  };
  Axis.prototype.updateXAxisTickValues = function updateXAxisTickValues(targets, axis) {
      var $$ = this.owner, config = $$.config, tickValues;
      if (config.axis_x_tick_fit || config.axis_x_tick_count) {
          tickValues = this.generateTickValues($$.mapTargetsToUniqueXs(targets), config.axis_x_tick_count, $$.isTimeSeries());
      }
      if (axis) {
          axis.tickValues(tickValues);
      }
      else {
          $$.xAxis.tickValues(tickValues);
          $$.subXAxis.tickValues(tickValues);
      }
      return tickValues;
  };
  Axis.prototype.getYAxis = function getYAxis(axisId, scale, orient, tickValues, withOuterTick, withoutTransition, withoutRotateTickText) {
      var $$ = this.owner;
      var config = $$.config;
      var tickFormat = config["axis_" + axisId + "_tick_format"];
      if (!tickFormat && $$.isAxisNormalized(axisId)) {
          tickFormat = function (x) { return x + "%"; };
      }
      var axis = new this.internal(this, {
          withOuterTick: withOuterTick,
          withoutTransition: withoutTransition,
          tickTextRotate: withoutRotateTickText ? 0 : config.axis_y_tick_rotate
      }).axis
          .scale(scale)
          .orient(orient);
      if (tickFormat) {
          axis.tickFormat(tickFormat);
      }
      if ($$.isTimeSeriesY()) {
          axis.ticks(config.axis_y_tick_time_type, config.axis_y_tick_time_interval);
      }
      else {
          axis.tickValues(tickValues);
      }
      return axis;
  };
  Axis.prototype.getId = function getId(id) {
      var config = this.owner.config;
      return id in config.data_axes ? config.data_axes[id] : 'y';
  };
  Axis.prototype.getXAxisTickFormat = function getXAxisTickFormat() {
      // #2251 previously set any negative values to a whole number,
      // however both should be truncated according to the users format specification
      var $$ = this.owner, config = $$.config;
      var format = $$.isTimeSeries()
          ? $$.defaultAxisTimeFormat
          : $$.isCategorized()
              ? $$.categoryName
              : function (v) {
                  return v;
              };
      if (config.axis_x_tick_format) {
          if (isFunction(config.axis_x_tick_format)) {
              format = config.axis_x_tick_format;
          }
          else if ($$.isTimeSeries()) {
              format = function (date) {
                  return date ? $$.axisTimeFormat(config.axis_x_tick_format)(date) : '';
              };
          }
      }
      return isFunction(format)
          ? function (v) {
              return format.call($$, v);
          }
          : format;
  };
  Axis.prototype.getTickValues = function getTickValues(tickValues, axis) {
      return tickValues ? tickValues : axis ? axis.tickValues() : undefined;
  };
  Axis.prototype.getXAxisTickValues = function getXAxisTickValues() {
      return this.getTickValues(this.owner.config.axis_x_tick_values, this.owner.xAxis);
  };
  Axis.prototype.getYAxisTickValues = function getYAxisTickValues() {
      return this.getTickValues(this.owner.config.axis_y_tick_values, this.owner.yAxis);
  };
  Axis.prototype.getY2AxisTickValues = function getY2AxisTickValues() {
      return this.getTickValues(this.owner.config.axis_y2_tick_values, this.owner.y2Axis);
  };
  Axis.prototype.getLabelOptionByAxisId = function getLabelOptionByAxisId(axisId) {
      var $$ = this.owner, config = $$.config, option;
      if (axisId === 'y') {
          option = config.axis_y_label;
      }
      else if (axisId === 'y2') {
          option = config.axis_y2_label;
      }
      else if (axisId === 'x') {
          option = config.axis_x_label;
      }
      return option;
  };
  Axis.prototype.getLabelText = function getLabelText(axisId) {
      var option = this.getLabelOptionByAxisId(axisId);
      return isString(option) ? option : option ? option.text : null;
  };
  Axis.prototype.setLabelText = function setLabelText(axisId, text) {
      var $$ = this.owner, config = $$.config, option = this.getLabelOptionByAxisId(axisId);
      if (isString(option)) {
          if (axisId === 'y') {
              config.axis_y_label = text;
          }
          else if (axisId === 'y2') {
              config.axis_y2_label = text;
          }
          else if (axisId === 'x') {
              config.axis_x_label = text;
          }
      }
      else if (option) {
          option.text = text;
      }
  };
  Axis.prototype.getLabelPosition = function getLabelPosition(axisId, defaultPosition) {
      var option = this.getLabelOptionByAxisId(axisId), position = option && typeof option === 'object' && option.position
          ? option.position
          : defaultPosition;
      return {
          isInner: position.indexOf('inner') >= 0,
          isOuter: position.indexOf('outer') >= 0,
          isLeft: position.indexOf('left') >= 0,
          isCenter: position.indexOf('center') >= 0,
          isRight: position.indexOf('right') >= 0,
          isTop: position.indexOf('top') >= 0,
          isMiddle: position.indexOf('middle') >= 0,
          isBottom: position.indexOf('bottom') >= 0
      };
  };
  Axis.prototype.getXAxisLabelPosition = function getXAxisLabelPosition() {
      return this.getLabelPosition('x', this.owner.config.axis_rotated ? 'inner-top' : 'inner-right');
  };
  Axis.prototype.getYAxisLabelPosition = function getYAxisLabelPosition() {
      return this.getLabelPosition('y', this.owner.config.axis_rotated ? 'inner-right' : 'inner-top');
  };
  Axis.prototype.getY2AxisLabelPosition = function getY2AxisLabelPosition() {
      return this.getLabelPosition('y2', this.owner.config.axis_rotated ? 'inner-right' : 'inner-top');
  };
  Axis.prototype.getLabelPositionById = function getLabelPositionById(id) {
      return id === 'y2'
          ? this.getY2AxisLabelPosition()
          : id === 'y'
              ? this.getYAxisLabelPosition()
              : this.getXAxisLabelPosition();
  };
  Axis.prototype.textForXAxisLabel = function textForXAxisLabel() {
      return this.getLabelText('x');
  };
  Axis.prototype.textForYAxisLabel = function textForYAxisLabel() {
      return this.getLabelText('y');
  };
  Axis.prototype.textForY2AxisLabel = function textForY2AxisLabel() {
      return this.getLabelText('y2');
  };
  Axis.prototype.xForAxisLabel = function xForAxisLabel(forHorizontal, position) {
      var $$ = this.owner;
      if (forHorizontal) {
          return position.isLeft ? 0 : position.isCenter ? $$.width / 2 : $$.width;
      }
      else {
          return position.isBottom
              ? -$$.height
              : position.isMiddle
                  ? -$$.height / 2
                  : 0;
      }
  };
  Axis.prototype.dxForAxisLabel = function dxForAxisLabel(forHorizontal, position) {
      if (forHorizontal) {
          return position.isLeft ? '0.5em' : position.isRight ? '-0.5em' : '0';
      }
      else {
          return position.isTop ? '-0.5em' : position.isBottom ? '0.5em' : '0';
      }
  };
  Axis.prototype.textAnchorForAxisLabel = function textAnchorForAxisLabel(forHorizontal, position) {
      if (forHorizontal) {
          return position.isLeft ? 'start' : position.isCenter ? 'middle' : 'end';
      }
      else {
          return position.isBottom ? 'start' : position.isMiddle ? 'middle' : 'end';
      }
  };
  Axis.prototype.xForXAxisLabel = function xForXAxisLabel() {
      return this.xForAxisLabel(!this.owner.config.axis_rotated, this.getXAxisLabelPosition());
  };
  Axis.prototype.xForYAxisLabel = function xForYAxisLabel() {
      return this.xForAxisLabel(this.owner.config.axis_rotated, this.getYAxisLabelPosition());
  };
  Axis.prototype.xForY2AxisLabel = function xForY2AxisLabel() {
      return this.xForAxisLabel(this.owner.config.axis_rotated, this.getY2AxisLabelPosition());
  };
  Axis.prototype.dxForXAxisLabel = function dxForXAxisLabel() {
      return this.dxForAxisLabel(!this.owner.config.axis_rotated, this.getXAxisLabelPosition());
  };
  Axis.prototype.dxForYAxisLabel = function dxForYAxisLabel() {
      return this.dxForAxisLabel(this.owner.config.axis_rotated, this.getYAxisLabelPosition());
  };
  Axis.prototype.dxForY2AxisLabel = function dxForY2AxisLabel() {
      return this.dxForAxisLabel(this.owner.config.axis_rotated, this.getY2AxisLabelPosition());
  };
  Axis.prototype.dyForXAxisLabel = function dyForXAxisLabel() {
      var $$ = this.owner, config = $$.config, position = this.getXAxisLabelPosition();
      if (config.axis_rotated) {
          return position.isInner
              ? '1.2em'
              : -25 - ($$.config.axis_x_inner ? 0 : this.getMaxTickWidth('x'));
      }
      else {
          return position.isInner ? '-0.5em' : $$.getHorizontalAxisHeight('x') - 10;
      }
  };
  Axis.prototype.dyForYAxisLabel = function dyForYAxisLabel() {
      var $$ = this.owner, position = this.getYAxisLabelPosition();
      if ($$.config.axis_rotated) {
          return position.isInner ? '-0.5em' : '3em';
      }
      else {
          return position.isInner
              ? '1.2em'
              : -10 - ($$.config.axis_y_inner ? 0 : this.getMaxTickWidth('y') + 10);
      }
  };
  Axis.prototype.dyForY2AxisLabel = function dyForY2AxisLabel() {
      var $$ = this.owner, position = this.getY2AxisLabelPosition();
      if ($$.config.axis_rotated) {
          return position.isInner ? '1.2em' : '-2.2em';
      }
      else {
          return position.isInner
              ? '-0.5em'
              : 15 + ($$.config.axis_y2_inner ? 0 : this.getMaxTickWidth('y2') + 15);
      }
  };
  Axis.prototype.textAnchorForXAxisLabel = function textAnchorForXAxisLabel() {
      var $$ = this.owner;
      return this.textAnchorForAxisLabel(!$$.config.axis_rotated, this.getXAxisLabelPosition());
  };
  Axis.prototype.textAnchorForYAxisLabel = function textAnchorForYAxisLabel() {
      var $$ = this.owner;
      return this.textAnchorForAxisLabel($$.config.axis_rotated, this.getYAxisLabelPosition());
  };
  Axis.prototype.textAnchorForY2AxisLabel = function textAnchorForY2AxisLabel() {
      var $$ = this.owner;
      return this.textAnchorForAxisLabel($$.config.axis_rotated, this.getY2AxisLabelPosition());
  };
  Axis.prototype.getMaxTickWidth = function getMaxTickWidth(id, withoutRecompute) {
      var $$ = this.owner, maxWidth = 0, targetsToShow, scale, axis, dummy, svg;
      if (withoutRecompute && $$.currentMaxTickWidths[id]) {
          return $$.currentMaxTickWidths[id];
      }
      if ($$.svg) {
          targetsToShow = $$.filterTargetsToShow($$.data.targets);
          if (id === 'y') {
              scale = $$.y.copy().domain($$.getYDomain(targetsToShow, 'y'));
              axis = this.getYAxis(id, scale, $$.yOrient, $$.yAxisTickValues, false, true, true);
          }
          else if (id === 'y2') {
              scale = $$.y2.copy().domain($$.getYDomain(targetsToShow, 'y2'));
              axis = this.getYAxis(id, scale, $$.y2Orient, $$.y2AxisTickValues, false, true, true);
          }
          else {
              scale = $$.x.copy().domain($$.getXDomain(targetsToShow));
              axis = this.getXAxis(scale, $$.xOrient, $$.xAxisTickFormat, $$.xAxisTickValues, false, true, true);
              this.updateXAxisTickValues(targetsToShow, axis);
          }
          dummy = $$.d3
              .select('body')
              .append('div')
              .classed('c3', true);
          (svg = dummy
              .append('svg')
              .style('visibility', 'hidden')
              .style('position', 'fixed')
              .style('top', 0)
              .style('left', 0)),
              svg
                  .append('g')
                  .call(axis)
                  .each(function () {
                  $$.d3
                      .select(this)
                      .selectAll('text')
                      .each(function () {
                      var box = getBBox(this);
                      if (maxWidth < box.width) {
                          maxWidth = box.width;
                      }
                  });
                  dummy.remove();
              });
      }
      $$.currentMaxTickWidths[id] =
          maxWidth <= 0 ? $$.currentMaxTickWidths[id] : maxWidth;
      return $$.currentMaxTickWidths[id];
  };
  Axis.prototype.updateLabels = function updateLabels(withTransition) {
      var $$ = this.owner;
      var axisXLabel = $$.main.select('.' + CLASS.axisX + ' .' + CLASS.axisXLabel), axisYLabel = $$.main.select('.' + CLASS.axisY + ' .' + CLASS.axisYLabel), axisY2Label = $$.main.select('.' + CLASS.axisY2 + ' .' + CLASS.axisY2Label);
      (withTransition ? axisXLabel.transition() : axisXLabel)
          .attr('x', this.xForXAxisLabel.bind(this))
          .attr('dx', this.dxForXAxisLabel.bind(this))
          .attr('dy', this.dyForXAxisLabel.bind(this))
          .text(this.textForXAxisLabel.bind(this));
      (withTransition ? axisYLabel.transition() : axisYLabel)
          .attr('x', this.xForYAxisLabel.bind(this))
          .attr('dx', this.dxForYAxisLabel.bind(this))
          .attr('dy', this.dyForYAxisLabel.bind(this))
          .text(this.textForYAxisLabel.bind(this));
      (withTransition ? axisY2Label.transition() : axisY2Label)
          .attr('x', this.xForY2AxisLabel.bind(this))
          .attr('dx', this.dxForY2AxisLabel.bind(this))
          .attr('dy', this.dyForY2AxisLabel.bind(this))
          .text(this.textForY2AxisLabel.bind(this));
  };
  Axis.prototype.getPadding = function getPadding(padding, key, defaultValue, domainLength) {
      var p = typeof padding === 'number' ? padding : padding[key];
      if (!isValue(p)) {
          return defaultValue;
      }
      if (padding.unit === 'ratio') {
          return padding[key] * domainLength;
      }
      // assume padding is pixels if unit is not specified
      return this.convertPixelsToAxisPadding(p, domainLength);
  };
  Axis.prototype.convertPixelsToAxisPadding = function convertPixelsToAxisPadding(pixels, domainLength) {
      var $$ = this.owner, length = $$.config.axis_rotated ? $$.width : $$.height;
      return domainLength * (pixels / length);
  };
  Axis.prototype.generateTickValues = function generateTickValues(values, tickCount, forTimeSeries) {
      var tickValues = values, targetCount, start, end, count, interval, i, tickValue;
      if (tickCount) {
          targetCount = isFunction(tickCount) ? tickCount() : tickCount;
          // compute ticks according to tickCount
          if (targetCount === 1) {
              tickValues = [values[0]];
          }
          else if (targetCount === 2) {
              tickValues = [values[0], values[values.length - 1]];
          }
          else if (targetCount > 2) {
              count = targetCount - 2;
              start = values[0];
              end = values[values.length - 1];
              interval = (end - start) / (count + 1);
              // re-construct unique values
              tickValues = [start];
              for (i = 0; i < count; i++) {
                  tickValue = +start + interval * (i + 1);
                  tickValues.push(forTimeSeries ? new Date(tickValue) : tickValue);
              }
              tickValues.push(end);
          }
      }
      if (!forTimeSeries) {
          tickValues = tickValues.sort(function (a, b) {
              return a - b;
          });
      }
      return tickValues;
  };
  Axis.prototype.generateTransitions = function generateTransitions(duration) {
      var $$ = this.owner, axes = $$.axes;
      return {
          axisX: duration ? axes.x.transition().duration(duration) : axes.x,
          axisY: duration ? axes.y.transition().duration(duration) : axes.y,
          axisY2: duration ? axes.y2.transition().duration(duration) : axes.y2,
          axisSubX: duration ? axes.subx.transition().duration(duration) : axes.subx
      };
  };
  Axis.prototype.redraw = function redraw(duration, isHidden) {
      var $$ = this.owner, transition = duration ? $$.d3.transition().duration(duration) : null;
      $$.axes.x.style('opacity', isHidden ? 0 : 1).call($$.xAxis, transition);
      $$.axes.y.style('opacity', isHidden ? 0 : 1).call($$.yAxis, transition);
      $$.axes.y2.style('opacity', isHidden ? 0 : 1).call($$.y2Axis, transition);
      $$.axes.subx.style('opacity', isHidden ? 0 : 1).call($$.subXAxis, transition);
  };

  var c3 = {
      version: '0.7.20',
      chart: {
          fn: Chart.prototype,
          internal: {
              fn: ChartInternal.prototype,
              axis: {
                  fn: AxisClass.prototype,
                  internal: {
                      fn: AxisInternal.prototype
                  }
              }
          }
      },
      generate: function (config) {
          return new Chart(config);
      }
  };
  ChartInternal.prototype.beforeInit = function () {
      // can do something
  };
  ChartInternal.prototype.afterInit = function () {
      // can do something
  };
  ChartInternal.prototype.init = function () {
      var $$ = this, config = $$.config;
      $$.initParams();
      if (config.data_url) {
          $$.convertUrlToData(config.data_url, config.data_mimeType, config.data_headers, config.data_keys, $$.initWithData);
      }
      else if (config.data_json) {
          $$.initWithData($$.convertJsonToData(config.data_json, config.data_keys));
      }
      else if (config.data_rows) {
          $$.initWithData($$.convertRowsToData(config.data_rows));
      }
      else if (config.data_columns) {
          $$.initWithData($$.convertColumnsToData(config.data_columns));
      }
      else {
          throw Error('url or json or rows or columns is required.');
      }
  };
  ChartInternal.prototype.initParams = function () {
      var $$ = this, d3 = $$.d3, config = $$.config;
      // MEMO: clipId needs to be unique because it conflicts when multiple charts exist
      $$.clipId = 'c3-' + new Date().valueOf() + '-clip';
      $$.clipIdForXAxis = $$.clipId + '-xaxis';
      $$.clipIdForYAxis = $$.clipId + '-yaxis';
      $$.clipIdForGrid = $$.clipId + '-grid';
      $$.clipIdForSubchart = $$.clipId + '-subchart';
      $$.clipPath = $$.getClipPath($$.clipId);
      $$.clipPathForXAxis = $$.getClipPath($$.clipIdForXAxis);
      $$.clipPathForYAxis = $$.getClipPath($$.clipIdForYAxis);
      $$.clipPathForGrid = $$.getClipPath($$.clipIdForGrid);
      $$.clipPathForSubchart = $$.getClipPath($$.clipIdForSubchart);
      $$.dragStart = null;
      $$.dragging = false;
      $$.flowing = false;
      $$.cancelClick = false;
      $$.mouseover = undefined;
      $$.transiting = false;
      $$.color = $$.generateColor();
      $$.levelColor = $$.generateLevelColor();
      $$.dataTimeParse = (config.data_xLocaltime ? d3.timeParse : d3.utcParse)($$.config.data_xFormat);
      $$.axisTimeFormat = config.axis_x_localtime ? d3.timeFormat : d3.utcFormat;
      $$.defaultAxisTimeFormat = function (date) {
          if (date.getMilliseconds()) {
              return d3.timeFormat('.%L')(date);
          }
          if (date.getSeconds()) {
              return d3.timeFormat(':%S')(date);
          }
          if (date.getMinutes()) {
              return d3.timeFormat('%I:%M')(date);
          }
          if (date.getHours()) {
              return d3.timeFormat('%I %p')(date);
          }
          if (date.getDay() && date.getDate() !== 1) {
              return d3.timeFormat('%-m/%-d')(date);
          }
          if (date.getDate() !== 1) {
              return d3.timeFormat('%-m/%-d')(date);
          }
          if (date.getMonth()) {
              return d3.timeFormat('%-m/%-d')(date);
          }
          return d3.timeFormat('%Y/%-m/%-d')(date);
      };
      $$.hiddenTargetIds = [];
      $$.hiddenLegendIds = [];
      $$.focusedTargetIds = [];
      $$.defocusedTargetIds = [];
      $$.xOrient = config.axis_rotated
          ? config.axis_x_inner
              ? 'right'
              : 'left'
          : config.axis_x_inner
              ? 'top'
              : 'bottom';
      $$.yOrient = config.axis_rotated
          ? config.axis_y_inner
              ? 'top'
              : 'bottom'
          : config.axis_y_inner
              ? 'right'
              : 'left';
      $$.y2Orient = config.axis_rotated
          ? config.axis_y2_inner
              ? 'bottom'
              : 'top'
          : config.axis_y2_inner
              ? 'left'
              : 'right';
      $$.subXOrient = config.axis_rotated ? 'left' : 'bottom';
      $$.isLegendRight = config.legend_position === 'right';
      $$.isLegendInset = config.legend_position === 'inset';
      $$.isLegendTop =
          config.legend_inset_anchor === 'top-left' ||
              config.legend_inset_anchor === 'top-right';
      $$.isLegendLeft =
          config.legend_inset_anchor === 'top-left' ||
              config.legend_inset_anchor === 'bottom-left';
      $$.legendStep = 0;
      $$.legendItemWidth = 0;
      $$.legendItemHeight = 0;
      $$.currentMaxTickWidths = {
          x: 0,
          y: 0,
          y2: 0
      };
      $$.rotated_padding_left = 30;
      $$.rotated_padding_right = config.axis_rotated && !config.axis_x_show ? 0 : 30;
      $$.rotated_padding_top = 5;
      $$.withoutFadeIn = {};
      $$.intervalForObserveInserted = undefined;
      $$.axes.subx = d3.selectAll([]); // needs when excluding subchart.js
  };
  ChartInternal.prototype.initChartElements = function () {
      if (this.initBar) {
          this.initBar();
      }
      if (this.initLine) {
          this.initLine();
      }
      if (this.initArc) {
          this.initArc();
      }
      if (this.initGauge) {
          this.initGauge();
      }
      if (this.initText) {
          this.initText();
      }
  };
  ChartInternal.prototype.initWithData = function (data) {
      var $$ = this, d3 = $$.d3, config = $$.config;
      var defs, main, binding = true;
      $$.axis = new AxisClass($$);
      if (!config.bindto) {
          $$.selectChart = d3.selectAll([]);
      }
      else if (typeof config.bindto.node === 'function') {
          $$.selectChart = config.bindto;
      }
      else {
          $$.selectChart = d3.select(config.bindto);
      }
      if ($$.selectChart.empty()) {
          $$.selectChart = d3
              .select(document.createElement('div'))
              .style('opacity', 0);
          $$.observeInserted($$.selectChart);
          binding = false;
      }
      $$.selectChart.html('').classed('c3', true);
      // Init data as targets
      $$.data.xs = {};
      $$.data.targets = $$.convertDataToTargets(data);
      if (config.data_filter) {
          $$.data.targets = $$.data.targets.filter(config.data_filter);
      }
      // Set targets to hide if needed
      if (config.data_hide) {
          $$.addHiddenTargetIds(config.data_hide === true
              ? $$.mapToIds($$.data.targets)
              : config.data_hide);
      }
      if (config.legend_hide) {
          $$.addHiddenLegendIds(config.legend_hide === true
              ? $$.mapToIds($$.data.targets)
              : config.legend_hide);
      }
      if ($$.isStanfordGraphType()) {
          $$.initStanfordData();
      }
      // Init sizes and scales
      $$.updateSizes();
      $$.updateScales();
      // Set domains for each scale
      $$.x.domain(d3.extent($$.getXDomain($$.data.targets)));
      $$.y.domain($$.getYDomain($$.data.targets, 'y'));
      $$.y2.domain($$.getYDomain($$.data.targets, 'y2'));
      $$.subX.domain($$.x.domain());
      $$.subY.domain($$.y.domain());
      $$.subY2.domain($$.y2.domain());
      // Save original x domain for zoom update
      $$.orgXDomain = $$.x.domain();
      /*-- Basic Elements --*/
      // Define svgs
      $$.svg = $$.selectChart
          .append('svg')
          .style('overflow', 'hidden')
          .on('mouseenter', function () {
          return config.onmouseover.call($$);
      })
          .on('mouseleave', function () {
          return config.onmouseout.call($$);
      });
      if ($$.config.svg_classname) {
          $$.svg.attr('class', $$.config.svg_classname);
      }
      // Define defs
      defs = $$.svg.append('defs');
      $$.clipChart = $$.appendClip(defs, $$.clipId);
      $$.clipXAxis = $$.appendClip(defs, $$.clipIdForXAxis);
      $$.clipYAxis = $$.appendClip(defs, $$.clipIdForYAxis);
      $$.clipGrid = $$.appendClip(defs, $$.clipIdForGrid);
      $$.clipSubchart = $$.appendClip(defs, $$.clipIdForSubchart);
      $$.updateSvgSize();
      // Define regions
      main = $$.main = $$.svg.append('g').attr('transform', $$.getTranslate('main'));
      if ($$.initPie) {
          $$.initPie();
      }
      if ($$.initDragZoom) {
          $$.initDragZoom();
      }
      if (config.subchart_show && $$.initSubchart) {
          $$.initSubchart();
      }
      if ($$.initTooltip) {
          $$.initTooltip();
      }
      if ($$.initLegend) {
          $$.initLegend();
      }
      if ($$.initTitle) {
          $$.initTitle();
      }
      if ($$.initZoom) {
          $$.initZoom();
      }
      if ($$.isStanfordGraphType()) {
          $$.drawColorScale();
      }
      // Update selection based on size and scale
      // TODO: currently this must be called after initLegend because of update of sizes, but it should be done in initSubchart.
      if (config.subchart_show && $$.initSubchartBrush) {
          $$.initSubchartBrush();
      }
      /*-- Main Region --*/
      // text when empty
      main
          .append('text')
          .attr('class', CLASS.text + ' ' + CLASS.empty)
          .attr('text-anchor', 'middle') // horizontal centering of text at x position in all browsers.
          .attr('dominant-baseline', 'middle'); // vertical centering of text at y position in all browsers, except IE.
      // Regions
      $$.initRegion();
      // Grids
      $$.initGrid();
      // Define g for chart area
      main
          .append('g')
          .attr('clip-path', $$.clipPath)
          .attr('class', CLASS.chart);
      // Grid lines
      if (config.grid_lines_front) {
          $$.initGridLines();
      }
      $$.initStanfordElements();
      // Cover whole with rects for events
      $$.initEventRect();
      // Define g for chart
      $$.initChartElements();
      // Add Axis
      $$.axis.init();
      // Set targets
      $$.updateTargets($$.data.targets);
      // Set default extent if defined
      if (config.axis_x_selection) {
          $$.brush.selectionAsValue($$.getDefaultSelection());
      }
      // Draw with targets
      if (binding) {
          $$.updateDimension();
          $$.config.oninit.call($$);
          $$.redraw({
              withTransition: false,
              withTransform: true,
              withUpdateXDomain: true,
              withUpdateOrgXDomain: true,
              withTransitionForAxis: false
          });
      }
      // Bind to resize event
      $$.bindResize();
      // Bind to window focus event
      $$.bindWindowFocus();
      // export element of the chart
      $$.api.element = $$.selectChart.node();
  };
  ChartInternal.prototype.smoothLines = function (el, type) {
      var $$ = this;
      if (type === 'grid') {
          el.each(function () {
              var g = $$.d3.select(this), x1 = g.attr('x1'), x2 = g.attr('x2'), y1 = g.attr('y1'), y2 = g.attr('y2');
              g.attr({
                  x1: Math.ceil(x1),
                  x2: Math.ceil(x2),
                  y1: Math.ceil(y1),
                  y2: Math.ceil(y2)
              });
          });
      }
  };
  ChartInternal.prototype.updateSizes = function () {
      var $$ = this, config = $$.config;
      var legendHeight = $$.legend ? $$.getLegendHeight() : 0, legendWidth = $$.legend ? $$.getLegendWidth() : 0, legendHeightForBottom = $$.isLegendRight || $$.isLegendInset ? 0 : legendHeight, hasArc = $$.hasArcType(), xAxisHeight = config.axis_rotated || hasArc ? 0 : $$.getHorizontalAxisHeight('x'), subchartXAxisHeight = config.axis_rotated || hasArc ? 0 : $$.getHorizontalAxisHeight('x', true), subchartHeight = config.subchart_show && !hasArc
          ? config.subchart_size_height + subchartXAxisHeight
          : 0;
      $$.currentWidth = $$.getCurrentWidth();
      $$.currentHeight = $$.getCurrentHeight();
      // for main
      $$.margin = config.axis_rotated
          ? {
              top: $$.getHorizontalAxisHeight('y2') + $$.getCurrentPaddingTop(),
              right: hasArc ? 0 : $$.getCurrentPaddingRight(),
              bottom: $$.getHorizontalAxisHeight('y') +
                  legendHeightForBottom +
                  $$.getCurrentPaddingBottom(),
              left: subchartHeight + (hasArc ? 0 : $$.getCurrentPaddingLeft())
          }
          : {
              top: 4 + $$.getCurrentPaddingTop(),
              right: hasArc ? 0 : $$.getCurrentPaddingRight(),
              bottom: xAxisHeight +
                  subchartHeight +
                  legendHeightForBottom +
                  $$.getCurrentPaddingBottom(),
              left: hasArc ? 0 : $$.getCurrentPaddingLeft()
          };
      // for subchart
      $$.margin2 = config.axis_rotated
          ? {
              top: $$.margin.top,
              right: NaN,
              bottom: 20 + legendHeightForBottom,
              left: $$.rotated_padding_left
          }
          : {
              top: $$.currentHeight - subchartHeight - legendHeightForBottom,
              right: NaN,
              bottom: subchartXAxisHeight + legendHeightForBottom,
              left: $$.margin.left
          };
      // for legend
      $$.margin3 = {
          top: 0,
          right: NaN,
          bottom: 0,
          left: 0
      };
      if ($$.updateSizeForLegend) {
          $$.updateSizeForLegend(legendHeight, legendWidth);
      }
      $$.width = $$.currentWidth - $$.margin.left - $$.margin.right;
      $$.height = $$.currentHeight - $$.margin.top - $$.margin.bottom;
      if ($$.width < 0) {
          $$.width = 0;
      }
      if ($$.height < 0) {
          $$.height = 0;
      }
      $$.width2 = config.axis_rotated
          ? $$.margin.left - $$.rotated_padding_left - $$.rotated_padding_right
          : $$.width;
      $$.height2 = config.axis_rotated
          ? $$.height
          : $$.currentHeight - $$.margin2.top - $$.margin2.bottom;
      if ($$.width2 < 0) {
          $$.width2 = 0;
      }
      if ($$.height2 < 0) {
          $$.height2 = 0;
      }
      // for arc
      $$.arcWidth = $$.width - ($$.isLegendRight ? legendWidth + 10 : 0);
      $$.arcHeight = $$.height - ($$.isLegendRight ? 0 : 10);
      if ($$.hasType('gauge') && !config.gauge_fullCircle) {
          $$.arcHeight += $$.height - $$.getGaugeLabelHeight();
      }
      if ($$.updateRadius) {
          $$.updateRadius();
      }
      if ($$.isLegendRight && hasArc) {
          $$.margin3.left = $$.arcWidth / 2 + $$.radiusExpanded * 1.1;
      }
  };
  ChartInternal.prototype.updateTargets = function (targets) {
      var $$ = this, config = $$.config;
      /*-- Main --*/
      //-- Text --//
      $$.updateTargetsForText(targets);
      //-- Bar --//
      $$.updateTargetsForBar(targets);
      //-- Line --//
      $$.updateTargetsForLine(targets);
      //-- Arc --//
      if ($$.hasArcType() && $$.updateTargetsForArc) {
          $$.updateTargetsForArc(targets);
      }
      /*-- Sub --*/
      if (config.subchart_show && $$.updateTargetsForSubchart) {
          $$.updateTargetsForSubchart(targets);
      }
      // Fade-in each chart
      $$.showTargets();
  };
  ChartInternal.prototype.showTargets = function () {
      var $$ = this;
      $$.svg
          .selectAll('.' + CLASS.target)
          .filter(function (d) {
          return $$.isTargetToShow(d.id);
      })
          .transition()
          .duration($$.config.transition_duration)
          .style('opacity', 1);
  };
  ChartInternal.prototype.redraw = function (options, transitions) {
      var $$ = this, main = $$.main, d3 = $$.d3, config = $$.config;
      var areaIndices = $$.getShapeIndices($$.isAreaType), barIndices = $$.getShapeIndices($$.isBarType), lineIndices = $$.getShapeIndices($$.isLineType);
      var withY, withSubchart, withTransition, withTransitionForExit, withTransitionForAxis, withTransform, withUpdateXDomain, withUpdateOrgXDomain, withTrimXDomain, withLegend, withEventRect, withDimension, withUpdateXAxis;
      var hideAxis = $$.hasArcType();
      var drawArea, drawBar, drawLine, xForText, yForText;
      var duration, durationForExit, durationForAxis;
      var transitionsToWait, waitForDraw, flow, transition;
      var targetsToShow = $$.filterTargetsToShow($$.data.targets), tickValues, i, intervalForCulling, xDomainForZoom;
      var xv = $$.xv.bind($$), cx, cy;
      options = options || {};
      withY = getOption(options, 'withY', true);
      withSubchart = getOption(options, 'withSubchart', true);
      withTransition = getOption(options, 'withTransition', true);
      withTransform = getOption(options, 'withTransform', false);
      withUpdateXDomain = getOption(options, 'withUpdateXDomain', false);
      withUpdateOrgXDomain = getOption(options, 'withUpdateOrgXDomain', false);
      withTrimXDomain = getOption(options, 'withTrimXDomain', true);
      withUpdateXAxis = getOption(options, 'withUpdateXAxis', withUpdateXDomain);
      withLegend = getOption(options, 'withLegend', false);
      withEventRect = getOption(options, 'withEventRect', true);
      withDimension = getOption(options, 'withDimension', true);
      withTransitionForExit = getOption(options, 'withTransitionForExit', withTransition);
      withTransitionForAxis = getOption(options, 'withTransitionForAxis', withTransition);
      duration = withTransition ? config.transition_duration : 0;
      durationForExit = withTransitionForExit ? duration : 0;
      durationForAxis = withTransitionForAxis ? duration : 0;
      transitions = transitions || $$.axis.generateTransitions(durationForAxis);
      // update legend and transform each g
      if (withLegend && config.legend_show) {
          $$.updateLegend($$.mapToIds($$.data.targets), options, transitions);
      }
      else if (withDimension) {
          // need to update dimension (e.g. axis.y.tick.values) because y tick values should change
          // no need to update axis in it because they will be updated in redraw()
          $$.updateDimension(true);
      }
      // MEMO: needed for grids calculation
      if ($$.isCategorized() && targetsToShow.length === 0) {
          $$.x.domain([0, $$.axes.x.selectAll('.tick').size()]);
      }
      if (targetsToShow.length) {
          $$.updateXDomain(targetsToShow, withUpdateXDomain, withUpdateOrgXDomain, withTrimXDomain);
          if (!config.axis_x_tick_values) {
              tickValues = $$.axis.updateXAxisTickValues(targetsToShow);
          }
      }
      else {
          $$.xAxis.tickValues([]);
          $$.subXAxis.tickValues([]);
      }
      if (config.zoom_rescale && !options.flow) {
          xDomainForZoom = $$.x.orgDomain();
      }
      $$.y.domain($$.getYDomain(targetsToShow, 'y', xDomainForZoom));
      $$.y2.domain($$.getYDomain(targetsToShow, 'y2', xDomainForZoom));
      if (!config.axis_y_tick_values && config.axis_y_tick_count) {
          $$.yAxis.tickValues($$.axis.generateTickValues($$.y.domain(), config.axis_y_tick_count));
      }
      if (!config.axis_y2_tick_values && config.axis_y2_tick_count) {
          $$.y2Axis.tickValues($$.axis.generateTickValues($$.y2.domain(), config.axis_y2_tick_count));
      }
      // axes
      $$.axis.redraw(durationForAxis, hideAxis);
      // Update axis label
      $$.axis.updateLabels(withTransition);
      // show/hide if manual culling needed
      if ((withUpdateXDomain || withUpdateXAxis) && targetsToShow.length) {
          if (config.axis_x_tick_culling && tickValues) {
              for (i = 1; i < tickValues.length; i++) {
                  if (tickValues.length / i < config.axis_x_tick_culling_max) {
                      intervalForCulling = i;
                      break;
                  }
              }
              $$.svg.selectAll('.' + CLASS.axisX + ' .tick text').each(function (e) {
                  var index = tickValues.indexOf(e);
                  if (index >= 0) {
                      d3.select(this).style('display', index % intervalForCulling ? 'none' : 'block');
                  }
              });
          }
          else {
              $$.svg
                  .selectAll('.' + CLASS.axisX + ' .tick text')
                  .style('display', 'block');
          }
      }
      // setup drawer - MEMO: these must be called after axis updated
      drawArea = $$.generateDrawArea
          ? $$.generateDrawArea(areaIndices, false)
          : undefined;
      drawBar = $$.generateDrawBar ? $$.generateDrawBar(barIndices) : undefined;
      drawLine = $$.generateDrawLine
          ? $$.generateDrawLine(lineIndices, false)
          : undefined;
      xForText = $$.generateXYForText(areaIndices, barIndices, lineIndices, true);
      yForText = $$.generateXYForText(areaIndices, barIndices, lineIndices, false);
      // update circleY based on updated parameters
      $$.updateCircleY();
      // generate circle x/y functions depending on updated params
      cx = ($$.config.axis_rotated ? $$.circleY : $$.circleX).bind($$);
      cy = ($$.config.axis_rotated ? $$.circleX : $$.circleY).bind($$);
      // Update sub domain
      if (withY) {
          $$.subY.domain($$.getYDomain(targetsToShow, 'y'));
          $$.subY2.domain($$.getYDomain(targetsToShow, 'y2'));
      }
      // xgrid focus
      $$.updateXgridFocus();
      // Data empty label positioning and text.
      main
          .select('text.' + CLASS.text + '.' + CLASS.empty)
          .attr('x', $$.width / 2)
          .attr('y', $$.height / 2)
          .text(config.data_empty_label_text)
          .transition()
          .style('opacity', targetsToShow.length ? 0 : 1);
      // event rect
      if (withEventRect) {
          $$.redrawEventRect();
      }
      // grid
      $$.updateGrid(duration);
      $$.updateStanfordElements(duration);
      // rect for regions
      $$.updateRegion(duration);
      // bars
      $$.updateBar(durationForExit);
      // lines, areas and circles
      $$.updateLine(durationForExit);
      $$.updateArea(durationForExit);
      $$.updateCircle(cx, cy);
      // text
      if ($$.hasDataLabel()) {
          $$.updateText(xForText, yForText, durationForExit);
      }
      // title
      if ($$.redrawTitle) {
          $$.redrawTitle();
      }
      // arc
      if ($$.redrawArc) {
          $$.redrawArc(duration, durationForExit, withTransform);
      }
      // subchart
      if (config.subchart_show && $$.redrawSubchart) {
          $$.redrawSubchart(withSubchart, transitions, duration, durationForExit, areaIndices, barIndices, lineIndices);
      }
      if ($$.isStanfordGraphType()) {
          $$.drawColorScale();
      }
      // circles for select
      main
          .selectAll('.' + CLASS.selectedCircles)
          .filter($$.isBarType.bind($$))
          .selectAll('circle')
          .remove();
      if (options.flow) {
          flow = $$.generateFlow({
              targets: targetsToShow,
              flow: options.flow,
              duration: options.flow.duration,
              drawBar: drawBar,
              drawLine: drawLine,
              drawArea: drawArea,
              cx: cx,
              cy: cy,
              xv: xv,
              xForText: xForText,
              yForText: yForText
          });
      }
      if (duration && $$.isTabVisible()) {
          // Only use transition if tab visible. See #938.
          // transition should be derived from one transition
          transition = d3.transition().duration(duration);
          transitionsToWait = [];
          [
              $$.redrawBar(drawBar, true, transition),
              $$.redrawLine(drawLine, true, transition),
              $$.redrawArea(drawArea, true, transition),
              $$.redrawCircle(cx, cy, true, transition),
              $$.redrawText(xForText, yForText, options.flow, true, transition),
              $$.redrawRegion(true, transition),
              $$.redrawGrid(true, transition)
          ].forEach(function (transitions) {
              transitions.forEach(function (transition) {
                  transitionsToWait.push(transition);
              });
          });
          // Wait for end of transitions to call flow and onrendered callback
          waitForDraw = $$.generateWait();
          transitionsToWait.forEach(function (t) {
              waitForDraw.add(t);
          });
          waitForDraw(function () {
              if (flow) {
                  flow();
              }
              if (config.onrendered) {
                  config.onrendered.call($$);
              }
          });
      }
      else {
          $$.redrawBar(drawBar);
          $$.redrawLine(drawLine);
          $$.redrawArea(drawArea);
          $$.redrawCircle(cx, cy);
          $$.redrawText(xForText, yForText, options.flow);
          $$.redrawRegion();
          $$.redrawGrid();
          if (flow) {
              flow();
          }
          if (config.onrendered) {
              config.onrendered.call($$);
          }
      }
      // update fadein condition
      $$.mapToIds($$.data.targets).forEach(function (id) {
          $$.withoutFadeIn[id] = true;
      });
  };
  ChartInternal.prototype.updateAndRedraw = function (options) {
      var $$ = this, config = $$.config, transitions;
      options = options || {};
      // same with redraw
      options.withTransition = getOption(options, 'withTransition', true);
      options.withTransform = getOption(options, 'withTransform', false);
      options.withLegend = getOption(options, 'withLegend', false);
      // NOT same with redraw
      options.withUpdateXDomain = getOption(options, 'withUpdateXDomain', true);
      options.withUpdateOrgXDomain = getOption(options, 'withUpdateOrgXDomain', true);
      options.withTransitionForExit = false;
      options.withTransitionForTransform = getOption(options, 'withTransitionForTransform', options.withTransition);
      // MEMO: this needs to be called before updateLegend and it means this ALWAYS needs to be called)
      $$.updateSizes();
      // MEMO: called in updateLegend in redraw if withLegend
      if (!(options.withLegend && config.legend_show)) {
          transitions = $$.axis.generateTransitions(options.withTransitionForAxis ? config.transition_duration : 0);
          // Update scales
          $$.updateScales();
          $$.updateSvgSize();
          // Update g positions
          $$.transformAll(options.withTransitionForTransform, transitions);
      }
      // Draw with new sizes & scales
      $$.redraw(options, transitions);
  };
  ChartInternal.prototype.redrawWithoutRescale = function () {
      this.redraw({
          withY: false,
          withSubchart: false,
          withEventRect: false,
          withTransitionForAxis: false
      });
  };
  ChartInternal.prototype.isTimeSeries = function () {
      return this.config.axis_x_type === 'timeseries';
  };
  ChartInternal.prototype.isCategorized = function () {
      return this.config.axis_x_type.indexOf('categor') >= 0;
  };
  ChartInternal.prototype.isCustomX = function () {
      var $$ = this, config = $$.config;
      return !$$.isTimeSeries() && (config.data_x || notEmpty(config.data_xs));
  };
  ChartInternal.prototype.isTimeSeriesY = function () {
      return this.config.axis_y_type === 'timeseries';
  };
  ChartInternal.prototype.getTranslate = function (target) {
      var $$ = this, config = $$.config, x, y;
      if (target === 'main') {
          x = asHalfPixel($$.margin.left);
          y = asHalfPixel($$.margin.top);
      }
      else if (target === 'context') {
          x = asHalfPixel($$.margin2.left);
          y = asHalfPixel($$.margin2.top);
      }
      else if (target === 'legend') {
          x = $$.margin3.left;
          y = $$.margin3.top;
      }
      else if (target === 'x') {
          x = 0;
          y = config.axis_rotated ? 0 : $$.height;
      }
      else if (target === 'y') {
          x = 0;
          y = config.axis_rotated ? $$.height : 0;
      }
      else if (target === 'y2') {
          x = config.axis_rotated ? 0 : $$.width;
          y = config.axis_rotated ? 1 : 0;
      }
      else if (target === 'subx') {
          x = 0;
          y = config.axis_rotated ? 0 : $$.height2;
      }
      else if (target === 'arc') {
          x = $$.arcWidth / 2;
          y = $$.arcHeight / 2 - ($$.hasType('gauge') ? 6 : 0); // to prevent wrong display of min and max label
      }
      return 'translate(' + x + ',' + y + ')';
  };
  ChartInternal.prototype.initialOpacity = function (d) {
      return d.value !== null && this.withoutFadeIn[d.id] ? 1 : 0;
  };
  ChartInternal.prototype.initialOpacityForCircle = function (d) {
      return d.value !== null && this.withoutFadeIn[d.id]
          ? this.opacityForCircle(d)
          : 0;
  };
  ChartInternal.prototype.opacityForCircle = function (d) {
      var isPointShouldBeShown = isFunction(this.config.point_show)
          ? this.config.point_show(d)
          : this.config.point_show;
      var opacity = isPointShouldBeShown || this.isStanfordType(d) ? 1 : 0;
      return isValue(d.value) ? (this.isScatterType(d) ? 0.5 : opacity) : 0;
  };
  ChartInternal.prototype.opacityForText = function () {
      return this.hasDataLabel() ? 1 : 0;
  };
  ChartInternal.prototype.xx = function (d) {
      return d ? this.x(d.x) : null;
  };
  ChartInternal.prototype.xvCustom = function (d, xyValue) {
      var $$ = this, value = xyValue ? d[xyValue] : d.value;
      if ($$.isTimeSeries()) {
          value = $$.parseDate(d.value);
      }
      else if ($$.isCategorized() && typeof d.value === 'string') {
          value = $$.config.axis_x_categories.indexOf(d.value);
      }
      return Math.ceil($$.x(value));
  };
  ChartInternal.prototype.yvCustom = function (d, xyValue) {
      var $$ = this, yScale = d.axis && d.axis === 'y2' ? $$.y2 : $$.y, value = xyValue ? d[xyValue] : d.value;
      return Math.ceil(yScale(value));
  };
  ChartInternal.prototype.xv = function (d) {
      var $$ = this, value = d.value;
      if ($$.isTimeSeries()) {
          value = $$.parseDate(d.value);
      }
      else if ($$.isCategorized() && typeof d.value === 'string') {
          value = $$.config.axis_x_categories.indexOf(d.value);
      }
      return Math.ceil($$.x(value));
  };
  ChartInternal.prototype.yv = function (d) {
      var $$ = this, yScale = d.axis && d.axis === 'y2' ? $$.y2 : $$.y;
      return Math.ceil(yScale(d.value));
  };
  ChartInternal.prototype.subxx = function (d) {
      return d ? this.subX(d.x) : null;
  };
  ChartInternal.prototype.transformMain = function (withTransition, transitions) {
      var $$ = this, xAxis, yAxis, y2Axis;
      if (transitions && transitions.axisX) {
          xAxis = transitions.axisX;
      }
      else {
          xAxis = $$.main.select('.' + CLASS.axisX);
          if (withTransition) {
              xAxis = xAxis.transition();
          }
      }
      if (transitions && transitions.axisY) {
          yAxis = transitions.axisY;
      }
      else {
          yAxis = $$.main.select('.' + CLASS.axisY);
          if (withTransition) {
              yAxis = yAxis.transition();
          }
      }
      if (transitions && transitions.axisY2) {
          y2Axis = transitions.axisY2;
      }
      else {
          y2Axis = $$.main.select('.' + CLASS.axisY2);
          if (withTransition) {
              y2Axis = y2Axis.transition();
          }
      }
      (withTransition ? $$.main.transition() : $$.main).attr('transform', $$.getTranslate('main'));
      xAxis.attr('transform', $$.getTranslate('x'));
      yAxis.attr('transform', $$.getTranslate('y'));
      y2Axis.attr('transform', $$.getTranslate('y2'));
      $$.main
          .select('.' + CLASS.chartArcs)
          .attr('transform', $$.getTranslate('arc'));
  };
  ChartInternal.prototype.transformAll = function (withTransition, transitions) {
      var $$ = this;
      $$.transformMain(withTransition, transitions);
      if ($$.config.subchart_show) {
          $$.transformContext(withTransition, transitions);
      }
      if ($$.legend) {
          $$.transformLegend(withTransition);
      }
  };
  ChartInternal.prototype.updateSvgSize = function () {
      var $$ = this, brush = $$.svg.select("." + CLASS.brush + " .overlay");
      $$.svg.attr('width', $$.currentWidth).attr('height', $$.currentHeight);
      $$.svg
          .selectAll(['#' + $$.clipId, '#' + $$.clipIdForGrid])
          .select('rect')
          .attr('width', $$.width)
          .attr('height', $$.height);
      $$.svg
          .select('#' + $$.clipIdForXAxis)
          .select('rect')
          .attr('x', $$.getXAxisClipX.bind($$))
          .attr('y', $$.getXAxisClipY.bind($$))
          .attr('width', $$.getXAxisClipWidth.bind($$))
          .attr('height', $$.getXAxisClipHeight.bind($$));
      $$.svg
          .select('#' + $$.clipIdForYAxis)
          .select('rect')
          .attr('x', $$.getYAxisClipX.bind($$))
          .attr('y', $$.getYAxisClipY.bind($$))
          .attr('width', $$.getYAxisClipWidth.bind($$))
          .attr('height', $$.getYAxisClipHeight.bind($$));
      $$.svg
          .select('#' + $$.clipIdForSubchart)
          .select('rect')
          .attr('width', $$.width)
          .attr('height', (brush.size() && brush.attr('height')) || 0);
      // MEMO: parent div's height will be bigger than svg when <!DOCTYPE html>
      $$.selectChart.style('max-height', $$.currentHeight + 'px');
  };
  ChartInternal.prototype.updateDimension = function (withoutAxis) {
      var $$ = this;
      if (!withoutAxis) {
          if ($$.config.axis_rotated) {
              $$.axes.x.call($$.xAxis);
              $$.axes.subx.call($$.subXAxis);
          }
          else {
              $$.axes.y.call($$.yAxis);
              $$.axes.y2.call($$.y2Axis);
          }
      }
      $$.updateSizes();
      $$.updateScales();
      $$.updateSvgSize();
      $$.transformAll(false);
  };
  ChartInternal.prototype.observeInserted = function (selection) {
      var $$ = this, observer;
      if (typeof MutationObserver === 'undefined') {
          window.console.error('MutationObserver not defined.');
          return;
      }
      observer = new MutationObserver(function (mutations) {
          mutations.forEach(function (mutation) {
              if (mutation.type === 'childList' && mutation.previousSibling) {
                  observer.disconnect();
                  // need to wait for completion of load because size calculation requires the actual sizes determined after that completion
                  $$.intervalForObserveInserted = window.setInterval(function () {
                      // parentNode will NOT be null when completed
                      if (selection.node().parentNode) {
                          window.clearInterval($$.intervalForObserveInserted);
                          $$.updateDimension();
                          if ($$.brush) {
                              $$.brush.update();
                          }
                          $$.config.oninit.call($$);
                          $$.redraw({
                              withTransform: true,
                              withUpdateXDomain: true,
                              withUpdateOrgXDomain: true,
                              withTransition: false,
                              withTransitionForTransform: false,
                              withLegend: true
                          });
                          selection.transition().style('opacity', 1);
                      }
                  }, 10);
              }
          });
      });
      observer.observe(selection.node(), {
          attributes: true,
          childList: true,
          characterData: true
      });
  };
  /**
   * Binds handlers to the window resize event.
   */
  ChartInternal.prototype.bindResize = function () {
      var $$ = this, config = $$.config;
      $$.resizeFunction = $$.generateResize(); // need to call .remove
      $$.resizeFunction.add(function () {
          config.onresize.call($$);
      });
      if (config.resize_auto) {
          $$.resizeFunction.add(function () {
              if ($$.resizeTimeout !== undefined) {
                  window.clearTimeout($$.resizeTimeout);
              }
              $$.resizeTimeout = window.setTimeout(function () {
                  delete $$.resizeTimeout;
                  $$.updateAndRedraw({
                      withUpdateXDomain: false,
                      withUpdateOrgXDomain: false,
                      withTransition: false,
                      withTransitionForTransform: false,
                      withLegend: true
                  });
                  if ($$.brush) {
                      $$.brush.update();
                  }
              }, 100);
          });
      }
      $$.resizeFunction.add(function () {
          config.onresized.call($$);
      });
      $$.resizeIfElementDisplayed = function () {
          // if element not displayed skip it
          if ($$.api == null || !$$.api.element.offsetParent) {
              return;
          }
          $$.resizeFunction();
      };
      window.addEventListener('resize', $$.resizeIfElementDisplayed, false);
  };
  /**
   * Binds handlers to the window focus event.
   */
  ChartInternal.prototype.bindWindowFocus = function () {
      var _this = this;
      if (this.windowFocusHandler) {
          // The handler is already set
          return;
      }
      this.windowFocusHandler = function () {
          _this.redraw();
      };
      window.addEventListener('focus', this.windowFocusHandler);
  };
  /**
   * Unbinds from the window focus event.
   */
  ChartInternal.prototype.unbindWindowFocus = function () {
      window.removeEventListener('focus', this.windowFocusHandler);
      delete this.windowFocusHandler;
  };
  ChartInternal.prototype.generateResize = function () {
      var resizeFunctions = [];
      function callResizeFunctions() {
          resizeFunctions.forEach(function (f) {
              f();
          });
      }
      callResizeFunctions.add = function (f) {
          resizeFunctions.push(f);
      };
      callResizeFunctions.remove = function (f) {
          for (var i = 0; i < resizeFunctions.length; i++) {
              if (resizeFunctions[i] === f) {
                  resizeFunctions.splice(i, 1);
                  break;
              }
          }
      };
      return callResizeFunctions;
  };
  ChartInternal.prototype.endall = function (transition, callback) {
      var n = 0;
      transition
          .each(function () {
          ++n;
      })
          .on('end', function () {
          if (!--n) {
              callback.apply(this, arguments);
          }
      });
  };
  ChartInternal.prototype.generateWait = function () {
      var $$ = this;
      var transitionsToWait = [], f = function (callback) {
          var timer = setInterval(function () {
              if (!$$.isTabVisible()) {
                  return;
              }
              var done = 0;
              transitionsToWait.forEach(function (t) {
                  if (t.empty()) {
                      done += 1;
                      return;
                  }
                  try {
                      t.transition();
                  }
                  catch (e) {
                      done += 1;
                  }
              });
              if (done === transitionsToWait.length) {
                  clearInterval(timer);
                  if (callback) {
                      callback();
                  }
              }
          }, 50);
      };
      f.add = function (transition) {
          transitionsToWait.push(transition);
      };
      return f;
  };
  ChartInternal.prototype.parseDate = function (date) {
      var $$ = this, parsedDate;
      if (date instanceof Date) {
          parsedDate = date;
      }
      else if (typeof date === 'string') {
          parsedDate = $$.dataTimeParse(date);
      }
      else if (typeof date === 'object') {
          parsedDate = new Date(+date);
      }
      else if (typeof date === 'number' && !isNaN(date)) {
          parsedDate = new Date(+date);
      }
      if (!parsedDate || isNaN(+parsedDate)) {
          window.console.error("Failed to parse x '" + date + "' to Date object");
      }
      return parsedDate;
  };
  ChartInternal.prototype.isTabVisible = function () {
      return !document.hidden;
  };
  ChartInternal.prototype.getPathBox = getPathBox;
  ChartInternal.prototype.CLASS = CLASS;

  /* jshint ignore:start */
  (function () {
      if (!('SVGPathSeg' in window)) {
          // Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-InterfaceSVGPathSeg
          window.SVGPathSeg = function (type, typeAsLetter, owningPathSegList) {
              this.pathSegType = type;
              this.pathSegTypeAsLetter = typeAsLetter;
              this._owningPathSegList = owningPathSegList;
          };
          window.SVGPathSeg.prototype.classname = 'SVGPathSeg';
          window.SVGPathSeg.PATHSEG_UNKNOWN = 0;
          window.SVGPathSeg.PATHSEG_CLOSEPATH = 1;
          window.SVGPathSeg.PATHSEG_MOVETO_ABS = 2;
          window.SVGPathSeg.PATHSEG_MOVETO_REL = 3;
          window.SVGPathSeg.PATHSEG_LINETO_ABS = 4;
          window.SVGPathSeg.PATHSEG_LINETO_REL = 5;
          window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS = 6;
          window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL = 7;
          window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS = 8;
          window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL = 9;
          window.SVGPathSeg.PATHSEG_ARC_ABS = 10;
          window.SVGPathSeg.PATHSEG_ARC_REL = 11;
          window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS = 12;
          window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL = 13;
          window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS = 14;
          window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL = 15;
          window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS = 16;
          window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL = 17;
          window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS = 18;
          window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL = 19;
          // Notify owning PathSegList on any changes so they can be synchronized back to the path element.
          window.SVGPathSeg.prototype._segmentChanged = function () {
              if (this._owningPathSegList)
                  this._owningPathSegList.segmentChanged(this);
          };
          window.SVGPathSegClosePath = function (owningPathSegList) {
              window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CLOSEPATH, 'z', owningPathSegList);
          };
          window.SVGPathSegClosePath.prototype = Object.create(window.SVGPathSeg.prototype);
          window.SVGPathSegClosePath.prototype.toString = function () {
              return '[object SVGPathSegClosePath]';
          };
          window.SVGPathSegClosePath.prototype._asPathString = function () {
              return this.pathSegTypeAsLetter;
          };
          window.SVGPathSegClosePath.prototype.clone = function () {
              return new window.SVGPathSegClosePath(undefined);
          };
          window.SVGPathSegMovetoAbs = function (owningPathSegList, x, y) {
              window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_MOVETO_ABS, 'M', owningPathSegList);
              this._x = x;
              this._y = y;
          };
          window.SVGPathSegMovetoAbs.prototype = Object.create(window.SVGPathSeg.prototype);
          window.SVGPathSegMovetoAbs.prototype.toString = function () {
              return '[object SVGPathSegMovetoAbs]';
          };
          window.SVGPathSegMovetoAbs.prototype._asPathString = function () {
              return this.pathSegTypeAsLetter + ' ' + this._x + ' ' + this._y;
          };
          window.SVGPathSegMovetoAbs.prototype.clone = function () {
              return new window.SVGPathSegMovetoAbs(undefined, this._x, this._y);
          };
          Object.defineProperty(window.SVGPathSegMovetoAbs.prototype, 'x', {
              get: function () {
                  return this._x;
              },
              set: function (x) {
                  this._x = x;
                  this._segmentChanged();
              },
              enumerable: true
          });
          Object.defineProperty(window.SVGPathSegMovetoAbs.prototype, 'y', {
              get: function () {
                  return this._y;
              },
              set: function (y) {
                  this._y = y;
                  this._segmentChanged();
              },
              enumerable: true
          });
          window.SVGPathSegMovetoRel = function (owningPathSegList, x, y) {
              window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_MOVETO_REL, 'm', owningPathSegList);
              this._x = x;
              this._y = y;
          };
          window.SVGPathSegMovetoRel.prototype = Object.create(window.SVGPathSeg.prototype);
          window.SVGPathSegMovetoRel.prototype.toString = function () {
              return '[object SVGPathSegMovetoRel]';
          };
          window.SVGPathSegMovetoRel.prototype._asPathString = function () {
              return this.pathSegTypeAsLetter + ' ' + this._x + ' ' + this._y;
          };
          window.SVGPathSegMovetoRel.prototype.clone = function () {
              return new window.SVGPathSegMovetoRel(undefined, this._x, this._y);
          };
          Object.defineProperty(window.SVGPathSegMovetoRel.prototype, 'x', {
              get: function () {
                  return this._x;
              },
              set: function (x) {
                  this._x = x;
                  this._segmentChanged();
              },
              enumerable: true
          });
          Object.defineProperty(window.SVGPathSegMovetoRel.prototype, 'y', {
              get: function () {
                  return this._y;
              },
              set: function (y) {
                  this._y = y;
                  this._segmentChanged();
              },
              enumerable: true
          });
          window.SVGPathSegLinetoAbs = function (owningPathSegList, x, y) {
              window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_LINETO_ABS, 'L', owningPathSegList);
              this._x = x;
              this._y = y;
          };
          window.SVGPathSegLinetoAbs.prototype = Object.create(window.SVGPathSeg.prototype);
          window.SVGPathSegLinetoAbs.prototype.toString = function () {
              return '[object SVGPathSegLinetoAbs]';
          };
          window.SVGPathSegLinetoAbs.prototype._asPathString = function () {
              return this.pathSegTypeAsLetter + ' ' + this._x + ' ' + this._y;
          };
          window.SVGPathSegLinetoAbs.prototype.clone = function () {
              return new window.SVGPathSegLinetoAbs(undefined, this._x, this._y);
          };
          Object.defineProperty(window.SVGPathSegLinetoAbs.prototype, 'x', {
              get: function () {
                  return this._x;
              },
              set: function (x) {
                  this._x = x;
                  this._segmentChanged();
              },
              enumerable: true
          });
          Object.defineProperty(window.SVGPathSegLinetoAbs.prototype, 'y', {
              get: function () {
                  return this._y;
              },
              set: function (y) {
                  this._y = y;
                  this._segmentChanged();
              },
              enumerable: true
          });
          window.SVGPathSegLinetoRel = function (owningPathSegList, x, y) {
              window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_LINETO_REL, 'l', owningPathSegList);
              this._x = x;
              this._y = y;
          };
          window.SVGPathSegLinetoRel.prototype = Object.create(window.SVGPathSeg.prototype);
          window.SVGPathSegLinetoRel.prototype.toString = function () {
              return '[object SVGPathSegLinetoRel]';
          };
          window.SVGPathSegLinetoRel.prototype._asPathString = function () {
              return this.pathSegTypeAsLetter + ' ' + this._x + ' ' + this._y;
          };
          window.SVGPathSegLinetoRel.prototype.clone = function () {
              return new window.SVGPathSegLinetoRel(undefined, this._x, this._y);
          };
          Object.defineProperty(window.SVGPathSegLinetoRel.prototype, 'x', {
              get: function () {
                  return this._x;
              },
              set: function (x) {
                  this._x = x;
                  this._segmentChanged();
              },
              enumerable: true
          });
          Object.defineProperty(window.SVGPathSegLinetoRel.prototype, 'y', {
              get: function () {
                  return this._y;
              },
              set: function (y) {
                  this._y = y;
                  this._segmentChanged();
              },
              enumerable: true
          });
          window.SVGPathSegCurvetoCubicAbs = function (owningPathSegList, x, y, x1, y1, x2, y2) {
              window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS, 'C', owningPathSegList);
              this._x = x;
              this._y = y;
              this._x1 = x1;
              this._y1 = y1;
              this._x2 = x2;
              this._y2 = y2;
          };
          window.SVGPathSegCurvetoCubicAbs.prototype = Object.create(window.SVGPathSeg.prototype);
          window.SVGPathSegCurvetoCubicAbs.prototype.toString = function () {
              return '[object SVGPathSegCurvetoCubicAbs]';
          };
          window.SVGPathSegCurvetoCubicAbs.prototype._asPathString = function () {
              return (this.pathSegTypeAsLetter +
                  ' ' +
                  this._x1 +
                  ' ' +
                  this._y1 +
                  ' ' +
                  this._x2 +
                  ' ' +
                  this._y2 +
                  ' ' +
                  this._x +
                  ' ' +
                  this._y);
          };
          window.SVGPathSegCurvetoCubicAbs.prototype.clone = function () {
              return new window.SVGPathSegCurvetoCubicAbs(undefined, this._x, this._y, this._x1, this._y1, this._x2, this._y2);
          };
          Object.defineProperty(window.SVGPathSegCurvetoCubicAbs.prototype, 'x', {
              get: function () {
                  return this._x;
              },
              set: function (x) {
                  this._x = x;
                  this._segmentChanged();
              },
              enumerable: true
          });
          Object.defineProperty(window.SVGPathSegCurvetoCubicAbs.prototype, 'y', {
              get: function () {
                  return this._y;
              },
              set: function (y) {
                  this._y = y;
                  this._segmentChanged();
              },
              enumerable: true
          });
          Object.defineProperty(window.SVGPathSegCurvetoCubicAbs.prototype, 'x1', {
              get: function () {
                  return this._x1;
              },
              set: function (x1) {
                  this._x1 = x1;
                  this._segmentChanged();
              },
              enumerable: true
          });
          Object.defineProperty(window.SVGPathSegCurvetoCubicAbs.prototype, 'y1', {
              get: function () {
                  return this._y1;
              },
              set: function (y1) {
                  this._y1 = y1;
                  this._segmentChanged();
              },
              enumerable: true
          });
          Object.defineProperty(window.SVGPathSegCurvetoCubicAbs.prototype, 'x2', {
              get: function () {
                  return this._x2;
              },
              set: function (x2) {
                  this._x2 = x2;
                  this._segmentChanged();
              },
              enumerable: true
          });
          Object.defineProperty(window.SVGPathSegCurvetoCubicAbs.prototype, 'y2', {
              get: function () {
                  return this._y2;
              },
              set: function (y2) {
                  this._y2 = y2;
                  this._segmentChanged();
              },
              enumerable: true
          });
          window.SVGPathSegCurvetoCubicRel = function (owningPathSegList, x, y, x1, y1, x2, y2) {
              window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL, 'c', owningPathSegList);
              this._x = x;
              this._y = y;
              this._x1 = x1;
              this._y1 = y1;
              this._x2 = x2;
              this._y2 = y2;
          };
          window.SVGPathSegCurvetoCubicRel.prototype = Object.create(window.SVGPathSeg.prototype);
          window.SVGPathSegCurvetoCubicRel.prototype.toString = function () {
              return '[object SVGPathSegCurvetoCubicRel]';
          };
          window.SVGPathSegCurvetoCubicRel.prototype._asPathString = function () {
              return (this.pathSegTypeAsLetter +
                  ' ' +
                  this._x1 +
                  ' ' +
                  this._y1 +
                  ' ' +
                  this._x2 +
                  ' ' +
                  this._y2 +
                  ' ' +
                  this._x +
                  ' ' +
                  this._y);
          };
          window.SVGPathSegCurvetoCubicRel.prototype.clone = function () {
              return new window.SVGPathSegCurvetoCubicRel(undefined, this._x, this._y, this._x1, this._y1, this._x2, this._y2);
          };
          Object.defineProperty(window.SVGPathSegCurvetoCubicRel.prototype, 'x', {
              get: function () {
                  return this._x;
              },
              set: function (x) {
                  this._x = x;
                  this._segmentChanged();
              },
              enumerable: true
          });
          Object.defineProperty(window.SVGPathSegCurvetoCubicRel.prototype, 'y', {
              get: function () {
                  return this._y;
              },
              set: function (y) {
                  this._y = y;
                  this._segmentChanged();
              },
              enumerable: true
          });
          Object.defineProperty(window.SVGPathSegCurvetoCubicRel.prototype, 'x1', {
              get: function () {
                  return this._x1;
              },
              set: function (x1) {
                  this._x1 = x1;
                  this._segmentChanged();
              },
              enumerable: true
          });
          Object.defineProperty(window.SVGPathSegCurvetoCubicRel.prototype, 'y1', {
              get: function () {
                  return this._y1;
              },
              set: function (y1) {
                  this._y1 = y1;
                  this._segmentChanged();
              },
              enumerable: true
          });
          Object.defineProperty(window.SVGPathSegCurvetoCubicRel.prototype, 'x2', {
              get: function () {
                  return this._x2;
              },
              set: function (x2) {
                  this._x2 = x2;
                  this._segmentChanged();
              },
              enumerable: true
          });
          Object.defineProperty(window.SVGPathSegCurvetoCubicRel.prototype, 'y2', {
              get: function () {
                  return this._y2;
              },
              set: function (y2) {
                  this._y2 = y2;
                  this._segmentChanged();
              },
              enumerable: true
          });
          window.SVGPathSegCurvetoQuadraticAbs = function (owningPathSegList, x, y, x1, y1) {
              window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS, 'Q', owningPathSegList);
              this._x = x;
              this._y = y;
              this._x1 = x1;
              this._y1 = y1;
          };
          window.SVGPathSegCurvetoQuadraticAbs.prototype = Object.create(window.SVGPathSeg.prototype);
          window.SVGPathSegCurvetoQuadraticAbs.prototype.toString = function () {
              return '[object SVGPathSegCurvetoQuadraticAbs]';
          };
          window.SVGPathSegCurvetoQuadraticAbs.prototype._asPathString = function () {
              return (this.pathSegTypeAsLetter +
                  ' ' +
                  this._x1 +
                  ' ' +
                  this._y1 +
                  ' ' +
                  this._x +
                  ' ' +
                  this._y);
          };
          window.SVGPathSegCurvetoQuadraticAbs.prototype.clone = function () {
              return new window.SVGPathSegCurvetoQuadraticAbs(undefined, this._x, this._y, this._x1, this._y1);
          };
          Object.defineProperty(window.SVGPathSegCurvetoQuadraticAbs.prototype, 'x', {
              get: function () {
                  return this._x;
              },
              set: function (x) {
                  this._x = x;
                  this._segmentChanged();
              },
              enumerable: true
          });
          Object.defineProperty(window.SVGPathSegCurvetoQuadraticAbs.prototype, 'y', {
              get: function () {
                  return this._y;
              },
              set: function (y) {
                  this._y = y;
                  this._segmentChanged();
              },
              enumerable: true
          });
          Object.defineProperty(window.SVGPathSegCurvetoQuadraticAbs.prototype, 'x1', {
              get: function () {
                  return this._x1;
              },
              set: function (x1) {
                  this._x1 = x1;
                  this._segmentChanged();
              },
              enumerable: true
          });
          Object.defineProperty(window.SVGPathSegCurvetoQuadraticAbs.prototype, 'y1', {
              get: function () {
                  return this._y1;
              },
              set: function (y1) {
                  this._y1 = y1;
                  this._segmentChanged();
              },
              enumerable: true
          });
          window.SVGPathSegCurvetoQuadraticRel = function (owningPathSegList, x, y, x1, y1) {
              window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL, 'q', owningPathSegList);
              this._x = x;
              this._y = y;
              this._x1 = x1;
              this._y1 = y1;
          };
          window.SVGPathSegCurvetoQuadraticRel.prototype = Object.create(window.SVGPathSeg.prototype);
          window.SVGPathSegCurvetoQuadraticRel.prototype.toString = function () {
              return '[object SVGPathSegCurvetoQuadraticRel]';
          };
          window.SVGPathSegCurvetoQuadraticRel.prototype._asPathString = function () {
              return (this.pathSegTypeAsLetter +
                  ' ' +
                  this._x1 +
                  ' ' +
                  this._y1 +
                  ' ' +
                  this._x +
                  ' ' +
                  this._y);
          };
          window.SVGPathSegCurvetoQuadraticRel.prototype.clone = function () {
              return new window.SVGPathSegCurvetoQuadraticRel(undefined, this._x, this._y, this._x1, this._y1);
          };
          Object.defineProperty(window.SVGPathSegCurvetoQuadraticRel.prototype, 'x', {
              get: function () {
                  return this._x;
              },
              set: function (x) {
                  this._x = x;
                  this._segmentChanged();
              },
              enumerable: true
          });
          Object.defineProperty(window.SVGPathSegCurvetoQuadraticRel.prototype, 'y', {
              get: function () {
                  return this._y;
              },
              set: function (y) {
                  this._y = y;
                  this._segmentChanged();
              },
              enumerable: true
          });
          Object.defineProperty(window.SVGPathSegCurvetoQuadraticRel.prototype, 'x1', {
              get: function () {
                  return this._x1;
              },
              set: function (x1) {
                  this._x1 = x1;
                  this._segmentChanged();
              },
              enumerable: true
          });
          Object.defineProperty(window.SVGPathSegCurvetoQuadraticRel.prototype, 'y1', {
              get: function () {
                  return this._y1;
              },
              set: function (y1) {
                  this._y1 = y1;
                  this._segmentChanged();
              },
              enumerable: true
          });
          window.SVGPathSegArcAbs = function (owningPathSegList, x, y, r1, r2, angle, largeArcFlag, sweepFlag) {
              window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_ARC_ABS, 'A', owningPathSegList);
              this._x = x;
              this._y = y;
              this._r1 = r1;
              this._r2 = r2;
              this._angle = angle;
              this._largeArcFlag = largeArcFlag;
              this._sweepFlag = sweepFlag;
          };
          window.SVGPathSegArcAbs.prototype = Object.create(window.SVGPathSeg.prototype);
          window.SVGPathSegArcAbs.prototype.toString = function () {
              return '[object SVGPathSegArcAbs]';
          };
          window.SVGPathSegArcAbs.prototype._asPathString = function () {
              return (this.pathSegTypeAsLetter +
                  ' ' +
                  this._r1 +
                  ' ' +
                  this._r2 +
                  ' ' +
                  this._angle +
                  ' ' +
                  (this._largeArcFlag ? '1' : '0') +
                  ' ' +
                  (this._sweepFlag ? '1' : '0') +
                  ' ' +
                  this._x +
                  ' ' +
                  this._y);
          };
          window.SVGPathSegArcAbs.prototype.clone = function () {
              return new window.SVGPathSegArcAbs(undefined, this._x, this._y, this._r1, this._r2, this._angle, this._largeArcFlag, this._sweepFlag);
          };
          Object.defineProperty(window.SVGPathSegArcAbs.prototype, 'x', {
              get: function () {
                  return this._x;
              },
              set: function (x) {
                  this._x = x;
                  this._segmentChanged();
              },
              enumerable: true
          });
          Object.defineProperty(window.SVGPathSegArcAbs.prototype, 'y', {
              get: function () {
                  return this._y;
              },
              set: function (y) {
                  this._y = y;
                  this._segmentChanged();
              },
              enumerable: true
          });
          Object.defineProperty(window.SVGPathSegArcAbs.prototype, 'r1', {
              get: function () {
                  return this._r1;
              },
              set: function (r1) {
                  this._r1 = r1;
                  this._segmentChanged();
              },
              enumerable: true
          });
          Object.defineProperty(window.SVGPathSegArcAbs.prototype, 'r2', {
              get: function () {
                  return this._r2;
              },
              set: function (r2) {
                  this._r2 = r2;
                  this._segmentChanged();
              },
              enumerable: true
          });
          Object.defineProperty(window.SVGPathSegArcAbs.prototype, 'angle', {
              get: function () {
                  return this._angle;
              },
              set: function (angle) {
                  this._angle = angle;
                  this._segmentChanged();
              },
              enumerable: true
          });
          Object.defineProperty(window.SVGPathSegArcAbs.prototype, 'largeArcFlag', {
              get: function () {
                  return this._largeArcFlag;
              },
              set: function (largeArcFlag) {
                  this._largeArcFlag = largeArcFlag;
                  this._segmentChanged();
              },
              enumerable: true
          });
          Object.defineProperty(window.SVGPathSegArcAbs.prototype, 'sweepFlag', {
              get: function () {
                  return this._sweepFlag;
              },
              set: function (sweepFlag) {
                  this._sweepFlag = sweepFlag;
                  this._segmentChanged();
              },
              enumerable: true
          });
          window.SVGPathSegArcRel = function (owningPathSegList, x, y, r1, r2, angle, largeArcFlag, sweepFlag) {
              window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_ARC_REL, 'a', owningPathSegList);
              this._x = x;
              this._y = y;
              this._r1 = r1;
              this._r2 = r2;
              this._angle = angle;
              this._largeArcFlag = largeArcFlag;
              this._sweepFlag = sweepFlag;
          };
          window.SVGPathSegArcRel.prototype = Object.create(window.SVGPathSeg.prototype);
          window.SVGPathSegArcRel.prototype.toString = function () {
              return '[object SVGPathSegArcRel]';
          };
          window.SVGPathSegArcRel.prototype._asPathString = function () {
              return (this.pathSegTypeAsLetter +
                  ' ' +
                  this._r1 +
                  ' ' +
                  this._r2 +
                  ' ' +
                  this._angle +
                  ' ' +
                  (this._largeArcFlag ? '1' : '0') +
                  ' ' +
                  (this._sweepFlag ? '1' : '0') +
                  ' ' +
                  this._x +
                  ' ' +
                  this._y);
          };
          window.SVGPathSegArcRel.prototype.clone = function () {
              return new window.SVGPathSegArcRel(undefined, this._x, this._y, this._r1, this._r2, this._angle, this._largeArcFlag, this._sweepFlag);
          };
          Object.defineProperty(window.SVGPathSegArcRel.prototype, 'x', {
              get: function () {
                  return this._x;
              },
              set: function (x) {
                  this._x = x;
                  this._segmentChanged();
              },
              enumerable: true
          });
          Object.defineProperty(window.SVGPathSegArcRel.prototype, 'y', {
              get: function () {
                  return this._y;
              },
              set: function (y) {
                  this._y = y;
                  this._segmentChanged();
              },
              enumerable: true
          });
          Object.defineProperty(window.SVGPathSegArcRel.prototype, 'r1', {
              get: function () {
                  return this._r1;
              },
              set: function (r1) {
                  this._r1 = r1;
                  this._segmentChanged();
              },
              enumerable: true
          });
          Object.defineProperty(window.SVGPathSegArcRel.prototype, 'r2', {
              get: function () {
                  return this._r2;
              },
              set: function (r2) {
                  this._r2 = r2;
                  this._segmentChanged();
              },
              enumerable: true
          });
          Object.defineProperty(window.SVGPathSegArcRel.prototype, 'angle', {
              get: function () {
                  return this._angle;
              },
              set: function (angle) {
                  this._angle = angle;
                  this._segmentChanged();
              },
              enumerable: true
          });
          Object.defineProperty(window.SVGPathSegArcRel.prototype, 'largeArcFlag', {
              get: function () {
                  return this._largeArcFlag;
              },
              set: function (largeArcFlag) {
                  this._largeArcFlag = largeArcFlag;
                  this._segmentChanged();
              },
              enumerable: true
          });
          Object.defineProperty(window.SVGPathSegArcRel.prototype, 'sweepFlag', {
              get: function () {
                  return this._sweepFlag;
              },
              set: function (sweepFlag) {
                  this._sweepFlag = sweepFlag;
                  this._segmentChanged();
              },
              enumerable: true
          });
          window.SVGPathSegLinetoHorizontalAbs = function (owningPathSegList, x) {
              window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS, 'H', owningPathSegList);
              this._x = x;
          };
          window.SVGPathSegLinetoHorizontalAbs.prototype = Object.create(window.SVGPathSeg.prototype);
          window.SVGPathSegLinetoHorizontalAbs.prototype.toString = function () {
              return '[object SVGPathSegLinetoHorizontalAbs]';
          };
          window.SVGPathSegLinetoHorizontalAbs.prototype._asPathString = function () {
              return this.pathSegTypeAsLetter + ' ' + this._x;
          };
          window.SVGPathSegLinetoHorizontalAbs.prototype.clone = function () {
              return new window.SVGPathSegLinetoHorizontalAbs(undefined, this._x);
          };
          Object.defineProperty(window.SVGPathSegLinetoHorizontalAbs.prototype, 'x', {
              get: function () {
                  return this._x;
              },
              set: function (x) {
                  this._x = x;
                  this._segmentChanged();
              },
              enumerable: true
          });
          window.SVGPathSegLinetoHorizontalRel = function (owningPathSegList, x) {
              window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL, 'h', owningPathSegList);
              this._x = x;
          };
          window.SVGPathSegLinetoHorizontalRel.prototype = Object.create(window.SVGPathSeg.prototype);
          window.SVGPathSegLinetoHorizontalRel.prototype.toString = function () {
              return '[object SVGPathSegLinetoHorizontalRel]';
          };
          window.SVGPathSegLinetoHorizontalRel.prototype._asPathString = function () {
              return this.pathSegTypeAsLetter + ' ' + this._x;
          };
          window.SVGPathSegLinetoHorizontalRel.prototype.clone = function () {
              return new window.SVGPathSegLinetoHorizontalRel(undefined, this._x);
          };
          Object.defineProperty(window.SVGPathSegLinetoHorizontalRel.prototype, 'x', {
              get: function () {
                  return this._x;
              },
              set: function (x) {
                  this._x = x;
                  this._segmentChanged();
              },
              enumerable: true
          });
          window.SVGPathSegLinetoVerticalAbs = function (owningPathSegList, y) {
              window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS, 'V', owningPathSegList);
              this._y = y;
          };
          window.SVGPathSegLinetoVerticalAbs.prototype = Object.create(window.SVGPathSeg.prototype);
          window.SVGPathSegLinetoVerticalAbs.prototype.toString = function () {
              return '[object SVGPathSegLinetoVerticalAbs]';
          };
          window.SVGPathSegLinetoVerticalAbs.prototype._asPathString = function () {
              return this.pathSegTypeAsLetter + ' ' + this._y;
          };
          window.SVGPathSegLinetoVerticalAbs.prototype.clone = function () {
              return new window.SVGPathSegLinetoVerticalAbs(undefined, this._y);
          };
          Object.defineProperty(window.SVGPathSegLinetoVerticalAbs.prototype, 'y', {
              get: function () {
                  return this._y;
              },
              set: function (y) {
                  this._y = y;
                  this._segmentChanged();
              },
              enumerable: true
          });
          window.SVGPathSegLinetoVerticalRel = function (owningPathSegList, y) {
              window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL, 'v', owningPathSegList);
              this._y = y;
          };
          window.SVGPathSegLinetoVerticalRel.prototype = Object.create(window.SVGPathSeg.prototype);
          window.SVGPathSegLinetoVerticalRel.prototype.toString = function () {
              return '[object SVGPathSegLinetoVerticalRel]';
          };
          window.SVGPathSegLinetoVerticalRel.prototype._asPathString = function () {
              return this.pathSegTypeAsLetter + ' ' + this._y;
          };
          window.SVGPathSegLinetoVerticalRel.prototype.clone = function () {
              return new window.SVGPathSegLinetoVerticalRel(undefined, this._y);
          };
          Object.defineProperty(window.SVGPathSegLinetoVerticalRel.prototype, 'y', {
              get: function () {
                  return this._y;
              },
              set: function (y) {
                  this._y = y;
                  this._segmentChanged();
              },
              enumerable: true
          });
          window.SVGPathSegCurvetoCubicSmoothAbs = function (owningPathSegList, x, y, x2, y2) {
              window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS, 'S', owningPathSegList);
              this._x = x;
              this._y = y;
              this._x2 = x2;
              this._y2 = y2;
          };
          window.SVGPathSegCurvetoCubicSmoothAbs.prototype = Object.create(window.SVGPathSeg.prototype);
          window.SVGPathSegCurvetoCubicSmoothAbs.prototype.toString = function () {
              return '[object SVGPathSegCurvetoCubicSmoothAbs]';
          };
          window.SVGPathSegCurvetoCubicSmoothAbs.prototype._asPathString = function () {
              return (this.pathSegTypeAsLetter +
                  ' ' +
                  this._x2 +
                  ' ' +
                  this._y2 +
                  ' ' +
                  this._x +
                  ' ' +
                  this._y);
          };
          window.SVGPathSegCurvetoCubicSmoothAbs.prototype.clone = function () {
              return new window.SVGPathSegCurvetoCubicSmoothAbs(undefined, this._x, this._y, this._x2, this._y2);
          };
          Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothAbs.prototype, 'x', {
              get: function () {
                  return this._x;
              },
              set: function (x) {
                  this._x = x;
                  this._segmentChanged();
              },
              enumerable: true
          });
          Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothAbs.prototype, 'y', {
              get: function () {
                  return this._y;
              },
              set: function (y) {
                  this._y = y;
                  this._segmentChanged();
              },
              enumerable: true
          });
          Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothAbs.prototype, 'x2', {
              get: function () {
                  return this._x2;
              },
              set: function (x2) {
                  this._x2 = x2;
                  this._segmentChanged();
              },
              enumerable: true
          });
          Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothAbs.prototype, 'y2', {
              get: function () {
                  return this._y2;
              },
              set: function (y2) {
                  this._y2 = y2;
                  this._segmentChanged();
              },
              enumerable: true
          });
          window.SVGPathSegCurvetoCubicSmoothRel = function (owningPathSegList, x, y, x2, y2) {
              window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL, 's', owningPathSegList);
              this._x = x;
              this._y = y;
              this._x2 = x2;
              this._y2 = y2;
          };
          window.SVGPathSegCurvetoCubicSmoothRel.prototype = Object.create(window.SVGPathSeg.prototype);
          window.SVGPathSegCurvetoCubicSmoothRel.prototype.toString = function () {
              return '[object SVGPathSegCurvetoCubicSmoothRel]';
          };
          window.SVGPathSegCurvetoCubicSmoothRel.prototype._asPathString = function () {
              return (this.pathSegTypeAsLetter +
                  ' ' +
                  this._x2 +
                  ' ' +
                  this._y2 +
                  ' ' +
                  this._x +
                  ' ' +
                  this._y);
          };
          window.SVGPathSegCurvetoCubicSmoothRel.prototype.clone = function () {
              return new window.SVGPathSegCurvetoCubicSmoothRel(undefined, this._x, this._y, this._x2, this._y2);
          };
          Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothRel.prototype, 'x', {
              get: function () {
                  return this._x;
              },
              set: function (x) {
                  this._x = x;
                  this._segmentChanged();
              },
              enumerable: true
          });
          Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothRel.prototype, 'y', {
              get: function () {
                  return this._y;
              },
              set: function (y) {
                  this._y = y;
                  this._segmentChanged();
              },
              enumerable: true
          });
          Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothRel.prototype, 'x2', {
              get: function () {
                  return this._x2;
              },
              set: function (x2) {
                  this._x2 = x2;
                  this._segmentChanged();
              },
              enumerable: true
          });
          Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothRel.prototype, 'y2', {
              get: function () {
                  return this._y2;
              },
              set: function (y2) {
                  this._y2 = y2;
                  this._segmentChanged();
              },
              enumerable: true
          });
          window.SVGPathSegCurvetoQuadraticSmoothAbs = function (owningPathSegList, x, y) {
              window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS, 'T', owningPathSegList);
              this._x = x;
              this._y = y;
          };
          window.SVGPathSegCurvetoQuadraticSmoothAbs.prototype = Object.create(window.SVGPathSeg.prototype);
          window.SVGPathSegCurvetoQuadraticSmoothAbs.prototype.toString = function () {
              return '[object SVGPathSegCurvetoQuadraticSmoothAbs]';
          };
          window.SVGPathSegCurvetoQuadraticSmoothAbs.prototype._asPathString = function () {
              return this.pathSegTypeAsLetter + ' ' + this._x + ' ' + this._y;
          };
          window.SVGPathSegCurvetoQuadraticSmoothAbs.prototype.clone = function () {
              return new window.SVGPathSegCurvetoQuadraticSmoothAbs(undefined, this._x, this._y);
          };
          Object.defineProperty(window.SVGPathSegCurvetoQuadraticSmoothAbs.prototype, 'x', {
              get: function () {
                  return this._x;
              },
              set: function (x) {
                  this._x = x;
                  this._segmentChanged();
              },
              enumerable: true
          });
          Object.defineProperty(window.SVGPathSegCurvetoQuadraticSmoothAbs.prototype, 'y', {
              get: function () {
                  return this._y;
              },
              set: function (y) {
                  this._y = y;
                  this._segmentChanged();
              },
              enumerable: true
          });
          window.SVGPathSegCurvetoQuadraticSmoothRel = function (owningPathSegList, x, y) {
              window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL, 't', owningPathSegList);
              this._x = x;
              this._y = y;
          };
          window.SVGPathSegCurvetoQuadraticSmoothRel.prototype = Object.create(window.SVGPathSeg.prototype);
          window.SVGPathSegCurvetoQuadraticSmoothRel.prototype.toString = function () {
              return '[object SVGPathSegCurvetoQuadraticSmoothRel]';
          };
          window.SVGPathSegCurvetoQuadraticSmoothRel.prototype._asPathString = function () {
              return this.pathSegTypeAsLetter + ' ' + this._x + ' ' + this._y;
          };
          window.SVGPathSegCurvetoQuadraticSmoothRel.prototype.clone = function () {
              return new window.SVGPathSegCurvetoQuadraticSmoothRel(undefined, this._x, this._y);
          };
          Object.defineProperty(window.SVGPathSegCurvetoQuadraticSmoothRel.prototype, 'x', {
              get: function () {
                  return this._x;
              },
              set: function (x) {
                  this._x = x;
                  this._segmentChanged();
              },
              enumerable: true
          });
          Object.defineProperty(window.SVGPathSegCurvetoQuadraticSmoothRel.prototype, 'y', {
              get: function () {
                  return this._y;
              },
              set: function (y) {
                  this._y = y;
                  this._segmentChanged();
              },
              enumerable: true
          });
          // Add createSVGPathSeg* functions to window.SVGPathElement.
          // Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-Interfacewindow.SVGPathElement.
          window.SVGPathElement.prototype.createSVGPathSegClosePath = function () {
              return new window.SVGPathSegClosePath(undefined);
          };
          window.SVGPathElement.prototype.createSVGPathSegMovetoAbs = function (x, y) {
              return new window.SVGPathSegMovetoAbs(undefined, x, y);
          };
          window.SVGPathElement.prototype.createSVGPathSegMovetoRel = function (x, y) {
              return new window.SVGPathSegMovetoRel(undefined, x, y);
          };
          window.SVGPathElement.prototype.createSVGPathSegLinetoAbs = function (x, y) {
              return new window.SVGPathSegLinetoAbs(undefined, x, y);
          };
          window.SVGPathElement.prototype.createSVGPathSegLinetoRel = function (x, y) {
              return new window.SVGPathSegLinetoRel(undefined, x, y);
          };
          window.SVGPathElement.prototype.createSVGPathSegCurvetoCubicAbs = function (x, y, x1, y1, x2, y2) {
              return new window.SVGPathSegCurvetoCubicAbs(undefined, x, y, x1, y1, x2, y2);
          };
          window.SVGPathElement.prototype.createSVGPathSegCurvetoCubicRel = function (x, y, x1, y1, x2, y2) {
              return new window.SVGPathSegCurvetoCubicRel(undefined, x, y, x1, y1, x2, y2);
          };
          window.SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticAbs = function (x, y, x1, y1) {
              return new window.SVGPathSegCurvetoQuadraticAbs(undefined, x, y, x1, y1);
          };
          window.SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticRel = function (x, y, x1, y1) {
              return new window.SVGPathSegCurvetoQuadraticRel(undefined, x, y, x1, y1);
          };
          window.SVGPathElement.prototype.createSVGPathSegArcAbs = function (x, y, r1, r2, angle, largeArcFlag, sweepFlag) {
              return new window.SVGPathSegArcAbs(undefined, x, y, r1, r2, angle, largeArcFlag, sweepFlag);
          };
          window.SVGPathElement.prototype.createSVGPathSegArcRel = function (x, y, r1, r2, angle, largeArcFlag, sweepFlag) {
              return new window.SVGPathSegArcRel(undefined, x, y, r1, r2, angle, largeArcFlag, sweepFlag);
          };
          window.SVGPathElement.prototype.createSVGPathSegLinetoHorizontalAbs = function (x) {
              return new window.SVGPathSegLinetoHorizontalAbs(undefined, x);
          };
          window.SVGPathElement.prototype.createSVGPathSegLinetoHorizontalRel = function (x) {
              return new window.SVGPathSegLinetoHorizontalRel(undefined, x);
          };
          window.SVGPathElement.prototype.createSVGPathSegLinetoVerticalAbs = function (y) {
              return new window.SVGPathSegLinetoVerticalAbs(undefined, y);
          };
          window.SVGPathElement.prototype.createSVGPathSegLinetoVerticalRel = function (y) {
              return new window.SVGPathSegLinetoVerticalRel(undefined, y);
          };
          window.SVGPathElement.prototype.createSVGPathSegCurvetoCubicSmoothAbs = function (x, y, x2, y2) {
              return new window.SVGPathSegCurvetoCubicSmoothAbs(undefined, x, y, x2, y2);
          };
          window.SVGPathElement.prototype.createSVGPathSegCurvetoCubicSmoothRel = function (x, y, x2, y2) {
              return new window.SVGPathSegCurvetoCubicSmoothRel(undefined, x, y, x2, y2);
          };
          window.SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticSmoothAbs = function (x, y) {
              return new window.SVGPathSegCurvetoQuadraticSmoothAbs(undefined, x, y);
          };
          window.SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticSmoothRel = function (x, y) {
              return new window.SVGPathSegCurvetoQuadraticSmoothRel(undefined, x, y);
          };
          if (!('getPathSegAtLength' in window.SVGPathElement.prototype)) {
              // Add getPathSegAtLength to SVGPathElement.
              // Spec: https://www.w3.org/TR/SVG11/single-page.html#paths-__svg__SVGPathElement__getPathSegAtLength
              // This polyfill requires SVGPathElement.getTotalLength to implement the distance-along-a-path algorithm.
              window.SVGPathElement.prototype.getPathSegAtLength = function (distance) {
                  if (distance === undefined || !isFinite(distance))
                      throw 'Invalid arguments.';
                  var measurementElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                  measurementElement.setAttribute('d', this.getAttribute('d'));
                  var lastPathSegment = measurementElement.pathSegList.numberOfItems - 1;
                  // If the path is empty, return 0.
                  if (lastPathSegment <= 0)
                      return 0;
                  do {
                      measurementElement.pathSegList.removeItem(lastPathSegment);
                      if (distance > measurementElement.getTotalLength())
                          break;
                      lastPathSegment--;
                  } while (lastPathSegment > 0);
                  return lastPathSegment;
              };
          }
      }
      if (!('SVGPathSegList' in window)) {
          // Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-InterfaceSVGPathSegList
          window.SVGPathSegList = function (pathElement) {
              this._pathElement = pathElement;
              this._list = this._parsePath(this._pathElement.getAttribute('d'));
              // Use a MutationObserver to catch changes to the path's "d" attribute.
              this._mutationObserverConfig = {
                  attributes: true,
                  attributeFilter: ['d']
              };
              this._pathElementMutationObserver = new MutationObserver(this._updateListFromPathMutations.bind(this));
              this._pathElementMutationObserver.observe(this._pathElement, this._mutationObserverConfig);
          };
          window.SVGPathSegList.prototype.classname = 'SVGPathSegList';
          Object.defineProperty(window.SVGPathSegList.prototype, 'numberOfItems', {
              get: function () {
                  this._checkPathSynchronizedToList();
                  return this._list.length;
              },
              enumerable: true
          });
          // Add the pathSegList accessors to window.SVGPathElement.
          // Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-InterfaceSVGAnimatedPathData
          Object.defineProperty(window.SVGPathElement.prototype, 'pathSegList', {
              get: function () {
                  if (!this._pathSegList)
                      this._pathSegList = new window.SVGPathSegList(this);
                  return this._pathSegList;
              },
              enumerable: true
          });
          // FIXME: The following are not implemented and simply return window.SVGPathElement.pathSegList.
          Object.defineProperty(window.SVGPathElement.prototype, 'normalizedPathSegList', {
              get: function () {
                  return this.pathSegList;
              },
              enumerable: true
          });
          Object.defineProperty(window.SVGPathElement.prototype, 'animatedPathSegList', {
              get: function () {
                  return this.pathSegList;
              },
              enumerable: true
          });
          Object.defineProperty(window.SVGPathElement.prototype, 'animatedNormalizedPathSegList', {
              get: function () {
                  return this.pathSegList;
              },
              enumerable: true
          });
          // Process any pending mutations to the path element and update the list as needed.
          // This should be the first call of all public functions and is needed because
          // MutationObservers are not synchronous so we can have pending asynchronous mutations.
          window.SVGPathSegList.prototype._checkPathSynchronizedToList = function () {
              this._updateListFromPathMutations(this._pathElementMutationObserver.takeRecords());
          };
          window.SVGPathSegList.prototype._updateListFromPathMutations = function (mutationRecords) {
              if (!this._pathElement)
                  return;
              var hasPathMutations = false;
              mutationRecords.forEach(function (record) {
                  if (record.attributeName == 'd')
                      hasPathMutations = true;
              });
              if (hasPathMutations)
                  this._list = this._parsePath(this._pathElement.getAttribute('d'));
          };
          // Serialize the list and update the path's 'd' attribute.
          window.SVGPathSegList.prototype._writeListToPath = function () {
              this._pathElementMutationObserver.disconnect();
              this._pathElement.setAttribute('d', window.SVGPathSegList._pathSegArrayAsString(this._list));
              this._pathElementMutationObserver.observe(this._pathElement, this._mutationObserverConfig);
          };
          // When a path segment changes the list needs to be synchronized back to the path element.
          window.SVGPathSegList.prototype.segmentChanged = function (pathSeg) {
              this._writeListToPath();
          };
          window.SVGPathSegList.prototype.clear = function () {
              this._checkPathSynchronizedToList();
              this._list.forEach(function (pathSeg) {
                  pathSeg._owningPathSegList = null;
              });
              this._list = [];
              this._writeListToPath();
          };
          window.SVGPathSegList.prototype.initialize = function (newItem) {
              this._checkPathSynchronizedToList();
              this._list = [newItem];
              newItem._owningPathSegList = this;
              this._writeListToPath();
              return newItem;
          };
          window.SVGPathSegList.prototype._checkValidIndex = function (index) {
              if (isNaN(index) || index < 0 || index >= this.numberOfItems)
                  throw 'INDEX_SIZE_ERR';
          };
          window.SVGPathSegList.prototype.getItem = function (index) {
              this._checkPathSynchronizedToList();
              this._checkValidIndex(index);
              return this._list[index];
          };
          window.SVGPathSegList.prototype.insertItemBefore = function (newItem, index) {
              this._checkPathSynchronizedToList();
              // Spec: If the index is greater than or equal to numberOfItems, then the new item is appended to the end of the list.
              if (index > this.numberOfItems)
                  index = this.numberOfItems;
              if (newItem._owningPathSegList) {
                  // SVG2 spec says to make a copy.
                  newItem = newItem.clone();
              }
              this._list.splice(index, 0, newItem);
              newItem._owningPathSegList = this;
              this._writeListToPath();
              return newItem;
          };
          window.SVGPathSegList.prototype.replaceItem = function (newItem, index) {
              this._checkPathSynchronizedToList();
              if (newItem._owningPathSegList) {
                  // SVG2 spec says to make a copy.
                  newItem = newItem.clone();
              }
              this._checkValidIndex(index);
              this._list[index] = newItem;
              newItem._owningPathSegList = this;
              this._writeListToPath();
              return newItem;
          };
          window.SVGPathSegList.prototype.removeItem = function (index) {
              this._checkPathSynchronizedToList();
              this._checkValidIndex(index);
              var item = this._list[index];
              this._list.splice(index, 1);
              this._writeListToPath();
              return item;
          };
          window.SVGPathSegList.prototype.appendItem = function (newItem) {
              this._checkPathSynchronizedToList();
              if (newItem._owningPathSegList) {
                  // SVG2 spec says to make a copy.
                  newItem = newItem.clone();
              }
              this._list.push(newItem);
              newItem._owningPathSegList = this;
              // TODO: Optimize this to just append to the existing attribute.
              this._writeListToPath();
              return newItem;
          };
          window.SVGPathSegList._pathSegArrayAsString = function (pathSegArray) {
              var string = '';
              var first = true;
              pathSegArray.forEach(function (pathSeg) {
                  if (first) {
                      first = false;
                      string += pathSeg._asPathString();
                  }
                  else {
                      string += ' ' + pathSeg._asPathString();
                  }
              });
              return string;
          };
          // This closely follows SVGPathParser::parsePath from Source/core/svg/SVGPathParser.cpp.
          window.SVGPathSegList.prototype._parsePath = function (string) {
              if (!string || string.length == 0)
                  return [];
              var owningPathSegList = this;
              var Builder = function () {
                  this.pathSegList = [];
              };
              Builder.prototype.appendSegment = function (pathSeg) {
                  this.pathSegList.push(pathSeg);
              };
              var Source = function (string) {
                  this._string = string;
                  this._currentIndex = 0;
                  this._endIndex = this._string.length;
                  this._previousCommand = window.SVGPathSeg.PATHSEG_UNKNOWN;
                  this._skipOptionalSpaces();
              };
              Source.prototype._isCurrentSpace = function () {
                  var character = this._string[this._currentIndex];
                  return (character <= ' ' &&
                      (character == ' ' ||
                          character == '\n' ||
                          character == '\t' ||
                          character == '\r' ||
                          character == '\f'));
              };
              Source.prototype._skipOptionalSpaces = function () {
                  while (this._currentIndex < this._endIndex && this._isCurrentSpace())
                      this._currentIndex++;
                  return this._currentIndex < this._endIndex;
              };
              Source.prototype._skipOptionalSpacesOrDelimiter = function () {
                  if (this._currentIndex < this._endIndex &&
                      !this._isCurrentSpace() &&
                      this._string.charAt(this._currentIndex) != ',')
                      return false;
                  if (this._skipOptionalSpaces()) {
                      if (this._currentIndex < this._endIndex &&
                          this._string.charAt(this._currentIndex) == ',') {
                          this._currentIndex++;
                          this._skipOptionalSpaces();
                      }
                  }
                  return this._currentIndex < this._endIndex;
              };
              Source.prototype.hasMoreData = function () {
                  return this._currentIndex < this._endIndex;
              };
              Source.prototype.peekSegmentType = function () {
                  var lookahead = this._string[this._currentIndex];
                  return this._pathSegTypeFromChar(lookahead);
              };
              Source.prototype._pathSegTypeFromChar = function (lookahead) {
                  switch (lookahead) {
                      case 'Z':
                      case 'z':
                          return window.SVGPathSeg.PATHSEG_CLOSEPATH;
                      case 'M':
                          return window.SVGPathSeg.PATHSEG_MOVETO_ABS;
                      case 'm':
                          return window.SVGPathSeg.PATHSEG_MOVETO_REL;
                      case 'L':
                          return window.SVGPathSeg.PATHSEG_LINETO_ABS;
                      case 'l':
                          return window.SVGPathSeg.PATHSEG_LINETO_REL;
                      case 'C':
                          return window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS;
                      case 'c':
                          return window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL;
                      case 'Q':
                          return window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS;
                      case 'q':
                          return window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL;
                      case 'A':
                          return window.SVGPathSeg.PATHSEG_ARC_ABS;
                      case 'a':
                          return window.SVGPathSeg.PATHSEG_ARC_REL;
                      case 'H':
                          return window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS;
                      case 'h':
                          return window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL;
                      case 'V':
                          return window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS;
                      case 'v':
                          return window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL;
                      case 'S':
                          return window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS;
                      case 's':
                          return window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL;
                      case 'T':
                          return window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS;
                      case 't':
                          return window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL;
                      default:
                          return window.SVGPathSeg.PATHSEG_UNKNOWN;
                  }
              };
              Source.prototype._nextCommandHelper = function (lookahead, previousCommand) {
                  // Check for remaining coordinates in the current command.
                  if ((lookahead == '+' ||
                      lookahead == '-' ||
                      lookahead == '.' ||
                      (lookahead >= '0' && lookahead <= '9')) &&
                      previousCommand != window.SVGPathSeg.PATHSEG_CLOSEPATH) {
                      if (previousCommand == window.SVGPathSeg.PATHSEG_MOVETO_ABS)
                          return window.SVGPathSeg.PATHSEG_LINETO_ABS;
                      if (previousCommand == window.SVGPathSeg.PATHSEG_MOVETO_REL)
                          return window.SVGPathSeg.PATHSEG_LINETO_REL;
                      return previousCommand;
                  }
                  return window.SVGPathSeg.PATHSEG_UNKNOWN;
              };
              Source.prototype.initialCommandIsMoveTo = function () {
                  // If the path is empty it is still valid, so return true.
                  if (!this.hasMoreData())
                      return true;
                  var command = this.peekSegmentType();
                  // Path must start with moveTo.
                  return (command == window.SVGPathSeg.PATHSEG_MOVETO_ABS ||
                      command == window.SVGPathSeg.PATHSEG_MOVETO_REL);
              };
              // Parse a number from an SVG path. This very closely follows genericParseNumber(...) from Source/core/svg/SVGParserUtilities.cpp.
              // Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-PathDataBNF
              Source.prototype._parseNumber = function () {
                  var exponent = 0;
                  var integer = 0;
                  var frac = 1;
                  var decimal = 0;
                  var sign = 1;
                  var expsign = 1;
                  var startIndex = this._currentIndex;
                  this._skipOptionalSpaces();
                  // Read the sign.
                  if (this._currentIndex < this._endIndex &&
                      this._string.charAt(this._currentIndex) == '+')
                      this._currentIndex++;
                  else if (this._currentIndex < this._endIndex &&
                      this._string.charAt(this._currentIndex) == '-') {
                      this._currentIndex++;
                      sign = -1;
                  }
                  if (this._currentIndex == this._endIndex ||
                      ((this._string.charAt(this._currentIndex) < '0' ||
                          this._string.charAt(this._currentIndex) > '9') &&
                          this._string.charAt(this._currentIndex) != '.'))
                      // The first character of a number must be one of [0-9+-.].
                      return undefined;
                  // Read the integer part, build right-to-left.
                  var startIntPartIndex = this._currentIndex;
                  while (this._currentIndex < this._endIndex &&
                      this._string.charAt(this._currentIndex) >= '0' &&
                      this._string.charAt(this._currentIndex) <= '9')
                      this._currentIndex++; // Advance to first non-digit.
                  if (this._currentIndex != startIntPartIndex) {
                      var scanIntPartIndex = this._currentIndex - 1;
                      var multiplier = 1;
                      while (scanIntPartIndex >= startIntPartIndex) {
                          integer +=
                              multiplier * (this._string.charAt(scanIntPartIndex--) - '0');
                          multiplier *= 10;
                      }
                  }
                  // Read the decimals.
                  if (this._currentIndex < this._endIndex &&
                      this._string.charAt(this._currentIndex) == '.') {
                      this._currentIndex++;
                      // There must be a least one digit following the .
                      if (this._currentIndex >= this._endIndex ||
                          this._string.charAt(this._currentIndex) < '0' ||
                          this._string.charAt(this._currentIndex) > '9')
                          return undefined;
                      while (this._currentIndex < this._endIndex &&
                          this._string.charAt(this._currentIndex) >= '0' &&
                          this._string.charAt(this._currentIndex) <= '9') {
                          frac *= 10;
                          decimal += (this._string.charAt(this._currentIndex) - '0') / frac;
                          this._currentIndex += 1;
                      }
                  }
                  // Read the exponent part.
                  if (this._currentIndex != startIndex &&
                      this._currentIndex + 1 < this._endIndex &&
                      (this._string.charAt(this._currentIndex) == 'e' ||
                          this._string.charAt(this._currentIndex) == 'E') &&
                      this._string.charAt(this._currentIndex + 1) != 'x' &&
                      this._string.charAt(this._currentIndex + 1) != 'm') {
                      this._currentIndex++;
                      // Read the sign of the exponent.
                      if (this._string.charAt(this._currentIndex) == '+') {
                          this._currentIndex++;
                      }
                      else if (this._string.charAt(this._currentIndex) == '-') {
                          this._currentIndex++;
                          expsign = -1;
                      }
                      // There must be an exponent.
                      if (this._currentIndex >= this._endIndex ||
                          this._string.charAt(this._currentIndex) < '0' ||
                          this._string.charAt(this._currentIndex) > '9')
                          return undefined;
                      while (this._currentIndex < this._endIndex &&
                          this._string.charAt(this._currentIndex) >= '0' &&
                          this._string.charAt(this._currentIndex) <= '9') {
                          exponent *= 10;
                          exponent += this._string.charAt(this._currentIndex) - '0';
                          this._currentIndex++;
                      }
                  }
                  var number = integer + decimal;
                  number *= sign;
                  if (exponent)
                      number *= Math.pow(10, expsign * exponent);
                  if (startIndex == this._currentIndex)
                      return undefined;
                  this._skipOptionalSpacesOrDelimiter();
                  return number;
              };
              Source.prototype._parseArcFlag = function () {
                  if (this._currentIndex >= this._endIndex)
                      return undefined;
                  var flag = false;
                  var flagChar = this._string.charAt(this._currentIndex++);
                  if (flagChar == '0')
                      flag = false;
                  else if (flagChar == '1')
                      flag = true;
                  else
                      return undefined;
                  this._skipOptionalSpacesOrDelimiter();
                  return flag;
              };
              Source.prototype.parseSegment = function () {
                  var lookahead = this._string[this._currentIndex];
                  var command = this._pathSegTypeFromChar(lookahead);
                  if (command == window.SVGPathSeg.PATHSEG_UNKNOWN) {
                      // Possibly an implicit command. Not allowed if this is the first command.
                      if (this._previousCommand == window.SVGPathSeg.PATHSEG_UNKNOWN)
                          return null;
                      command = this._nextCommandHelper(lookahead, this._previousCommand);
                      if (command == window.SVGPathSeg.PATHSEG_UNKNOWN)
                          return null;
                  }
                  else {
                      this._currentIndex++;
                  }
                  this._previousCommand = command;
                  switch (command) {
                      case window.SVGPathSeg.PATHSEG_MOVETO_REL:
                          return new window.SVGPathSegMovetoRel(owningPathSegList, this._parseNumber(), this._parseNumber());
                      case window.SVGPathSeg.PATHSEG_MOVETO_ABS:
                          return new window.SVGPathSegMovetoAbs(owningPathSegList, this._parseNumber(), this._parseNumber());
                      case window.SVGPathSeg.PATHSEG_LINETO_REL:
                          return new window.SVGPathSegLinetoRel(owningPathSegList, this._parseNumber(), this._parseNumber());
                      case window.SVGPathSeg.PATHSEG_LINETO_ABS:
                          return new window.SVGPathSegLinetoAbs(owningPathSegList, this._parseNumber(), this._parseNumber());
                      case window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL:
                          return new window.SVGPathSegLinetoHorizontalRel(owningPathSegList, this._parseNumber());
                      case window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS:
                          return new window.SVGPathSegLinetoHorizontalAbs(owningPathSegList, this._parseNumber());
                      case window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL:
                          return new window.SVGPathSegLinetoVerticalRel(owningPathSegList, this._parseNumber());
                      case window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS:
                          return new window.SVGPathSegLinetoVerticalAbs(owningPathSegList, this._parseNumber());
                      case window.SVGPathSeg.PATHSEG_CLOSEPATH:
                          this._skipOptionalSpaces();
                          return new window.SVGPathSegClosePath(owningPathSegList);
                      case window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL:
                          var points = {
                              x1: this._parseNumber(),
                              y1: this._parseNumber(),
                              x2: this._parseNumber(),
                              y2: this._parseNumber(),
                              x: this._parseNumber(),
                              y: this._parseNumber()
                          };
                          return new window.SVGPathSegCurvetoCubicRel(owningPathSegList, points.x, points.y, points.x1, points.y1, points.x2, points.y2);
                      case window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS:
                          var points = {
                              x1: this._parseNumber(),
                              y1: this._parseNumber(),
                              x2: this._parseNumber(),
                              y2: this._parseNumber(),
                              x: this._parseNumber(),
                              y: this._parseNumber()
                          };
                          return new window.SVGPathSegCurvetoCubicAbs(owningPathSegList, points.x, points.y, points.x1, points.y1, points.x2, points.y2);
                      case window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL:
                          var points = {
                              x2: this._parseNumber(),
                              y2: this._parseNumber(),
                              x: this._parseNumber(),
                              y: this._parseNumber()
                          };
                          return new window.SVGPathSegCurvetoCubicSmoothRel(owningPathSegList, points.x, points.y, points.x2, points.y2);
                      case window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS:
                          var points = {
                              x2: this._parseNumber(),
                              y2: this._parseNumber(),
                              x: this._parseNumber(),
                              y: this._parseNumber()
                          };
                          return new window.SVGPathSegCurvetoCubicSmoothAbs(owningPathSegList, points.x, points.y, points.x2, points.y2);
                      case window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL:
                          var points = {
                              x1: this._parseNumber(),
                              y1: this._parseNumber(),
                              x: this._parseNumber(),
                              y: this._parseNumber()
                          };
                          return new window.SVGPathSegCurvetoQuadraticRel(owningPathSegList, points.x, points.y, points.x1, points.y1);
                      case window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS:
                          var points = {
                              x1: this._parseNumber(),
                              y1: this._parseNumber(),
                              x: this._parseNumber(),
                              y: this._parseNumber()
                          };
                          return new window.SVGPathSegCurvetoQuadraticAbs(owningPathSegList, points.x, points.y, points.x1, points.y1);
                      case window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL:
                          return new window.SVGPathSegCurvetoQuadraticSmoothRel(owningPathSegList, this._parseNumber(), this._parseNumber());
                      case window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS:
                          return new window.SVGPathSegCurvetoQuadraticSmoothAbs(owningPathSegList, this._parseNumber(), this._parseNumber());
                      case window.SVGPathSeg.PATHSEG_ARC_REL:
                          var points = {
                              x1: this._parseNumber(),
                              y1: this._parseNumber(),
                              arcAngle: this._parseNumber(),
                              arcLarge: this._parseArcFlag(),
                              arcSweep: this._parseArcFlag(),
                              x: this._parseNumber(),
                              y: this._parseNumber()
                          };
                          return new window.SVGPathSegArcRel(owningPathSegList, points.x, points.y, points.x1, points.y1, points.arcAngle, points.arcLarge, points.arcSweep);
                      case window.SVGPathSeg.PATHSEG_ARC_ABS:
                          var points = {
                              x1: this._parseNumber(),
                              y1: this._parseNumber(),
                              arcAngle: this._parseNumber(),
                              arcLarge: this._parseArcFlag(),
                              arcSweep: this._parseArcFlag(),
                              x: this._parseNumber(),
                              y: this._parseNumber()
                          };
                          return new window.SVGPathSegArcAbs(owningPathSegList, points.x, points.y, points.x1, points.y1, points.arcAngle, points.arcLarge, points.arcSweep);
                      default:
                          throw 'Unknown path seg type.';
                  }
              };
              var builder = new Builder();
              var source = new Source(string);
              if (!source.initialCommandIsMoveTo())
                  return [];
              while (source.hasMoreData()) {
                  var pathSeg = source.parseSegment();
                  if (!pathSeg)
                      return [];
                  builder.appendSegment(pathSeg);
              }
              return builder.pathSegList;
          };
      }
  })();
  // String.padEnd polyfill for IE11
  //
  // https://github.com/uxitten/polyfill/blob/master/string.polyfill.js
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/padEnd
  if (!String.prototype.padEnd) {
      String.prototype.padEnd = function padEnd(targetLength, padString) {
          targetLength = targetLength >> 0; //floor if number or convert non-number to 0;
          padString = String(typeof padString !== 'undefined' ? padString : ' ');
          if (this.length > targetLength) {
              return String(this);
          }
          else {
              targetLength = targetLength - this.length;
              if (targetLength > padString.length) {
                  padString += padString.repeat(targetLength / padString.length); //append to original to ensure we are longer than needed
              }
              return String(this) + padString.slice(0, targetLength);
          }
      };
  }
  // Object.assign polyfill for IE11
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Polyfill
  if (typeof Object.assign !== 'function') {
      // Must be writable: true, enumerable: false, configurable: true
      Object.defineProperty(Object, 'assign', {
          value: function assign(target, varArgs) {
              if (target === null || target === undefined) {
                  throw new TypeError('Cannot convert undefined or null to object');
              }
              var to = Object(target);
              for (var index = 1; index < arguments.length; index++) {
                  var nextSource = arguments[index];
                  if (nextSource !== null && nextSource !== undefined) {
                      for (var nextKey in nextSource) {
                          // Avoid bugs when hasOwnProperty is shadowed
                          if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                              to[nextKey] = nextSource[nextKey];
                          }
                      }
                  }
              }
              return to;
          },
          writable: true,
          configurable: true
      });
  }
  /* jshint ignore:end */

  Chart.prototype.axis = function () { };
  Chart.prototype.axis.labels = function (labels) {
      var $$ = this.internal;
      if (arguments.length) {
          Object.keys(labels).forEach(function (axisId) {
              $$.axis.setLabelText(axisId, labels[axisId]);
          });
          $$.axis.updateLabels();
      }
      // TODO: return some values?
  };
  Chart.prototype.axis.max = function (max) {
      var $$ = this.internal, config = $$.config;
      if (arguments.length) {
          if (typeof max === 'object') {
              if (isValue(max.x)) {
                  config.axis_x_max = max.x;
              }
              if (isValue(max.y)) {
                  config.axis_y_max = max.y;
              }
              if (isValue(max.y2)) {
                  config.axis_y2_max = max.y2;
              }
          }
          else {
              config.axis_y_max = config.axis_y2_max = max;
          }
          $$.redraw({ withUpdateOrgXDomain: true, withUpdateXDomain: true });
      }
      else {
          return {
              x: config.axis_x_max,
              y: config.axis_y_max,
              y2: config.axis_y2_max
          };
      }
  };
  Chart.prototype.axis.min = function (min) {
      var $$ = this.internal, config = $$.config;
      if (arguments.length) {
          if (typeof min === 'object') {
              if (isValue(min.x)) {
                  config.axis_x_min = min.x;
              }
              if (isValue(min.y)) {
                  config.axis_y_min = min.y;
              }
              if (isValue(min.y2)) {
                  config.axis_y2_min = min.y2;
              }
          }
          else {
              config.axis_y_min = config.axis_y2_min = min;
          }
          $$.redraw({ withUpdateOrgXDomain: true, withUpdateXDomain: true });
      }
      else {
          return {
              x: config.axis_x_min,
              y: config.axis_y_min,
              y2: config.axis_y2_min
          };
      }
  };
  Chart.prototype.axis.range = function (range) {
      if (arguments.length) {
          if (isDefined(range.max)) {
              this.axis.max(range.max);
          }
          if (isDefined(range.min)) {
              this.axis.min(range.min);
          }
      }
      else {
          return {
              max: this.axis.max(),
              min: this.axis.min()
          };
      }
  };
  Chart.prototype.axis.types = function (types) {
      var $$ = this.internal;
      if (types === undefined) {
          return {
              y: $$.config.axis_y_type,
              y2: $$.config.axis_y2_type
          };
      }
      else {
          if (isDefined(types.y)) {
              $$.config.axis_y_type = types.y;
          }
          if (isDefined(types.y2)) {
              $$.config.axis_y2_type = types.y2;
          }
          $$.updateScales();
          $$.redraw();
      }
  };

  Chart.prototype.category = function (i, category) {
      var $$ = this.internal, config = $$.config;
      if (arguments.length > 1) {
          config.axis_x_categories[i] = category;
          $$.redraw();
      }
      return config.axis_x_categories[i];
  };
  Chart.prototype.categories = function (categories) {
      var $$ = this.internal, config = $$.config;
      if (!arguments.length) {
          return config.axis_x_categories;
      }
      config.axis_x_categories = categories;
      $$.redraw();
      return config.axis_x_categories;
  };

  Chart.prototype.resize = function (size) {
      var $$ = this.internal, config = $$.config;
      config.size_width = size ? size.width : null;
      config.size_height = size ? size.height : null;
      this.flush();
  };
  Chart.prototype.flush = function () {
      var $$ = this.internal;
      $$.updateAndRedraw({
          withLegend: true,
          withTransition: false,
          withTransitionForTransform: false
      });
  };
  Chart.prototype.destroy = function () {
      var $$ = this.internal;
      window.clearInterval($$.intervalForObserveInserted);
      if ($$.resizeTimeout !== undefined) {
          window.clearTimeout($$.resizeTimeout);
      }
      window.removeEventListener('resize', $$.resizeIfElementDisplayed);
      // Removes the inner resize functions
      $$.resizeFunction.remove();
      // Unbinds from the window focus event
      $$.unbindWindowFocus();
      $$.selectChart.classed('c3', false).html('');
      // MEMO: this is needed because the reference of some elements will not be released, then memory leak will happen.
      Object.keys($$).forEach(function (key) {
          $$[key] = null;
      });
      return null;
  };

  // TODO: fix
  Chart.prototype.color = function (id) {
      var $$ = this.internal;
      return $$.color(id); // more patterns
  };

  Chart.prototype.data = function (targetIds) {
      var targets = this.internal.data.targets;
      return typeof targetIds === 'undefined'
          ? targets
          : targets.filter(function (t) {
              return [].concat(targetIds).indexOf(t.id) >= 0;
          });
  };
  Chart.prototype.data.shown = function (targetIds) {
      return this.internal.filterTargetsToShow(this.data(targetIds));
  };
  /**
   * Get values of the data loaded in the chart.
   *
   * @param {String|Array} targetId This API returns the value of specified target.
   * @param flat
   * @return {Array} Data values
   */
  Chart.prototype.data.values = function (targetId, flat) {
      if (flat === void 0) { flat = true; }
      var values = null;
      if (targetId) {
          var targets = this.data(targetId);
          if (targets && isArray(targets)) {
              values = targets.reduce(function (ret, v) {
                  var dataValue = v.values.map(function (d) { return d.value; });
                  if (flat) {
                      ret = ret.concat(dataValue);
                  }
                  else {
                      ret.push(dataValue);
                  }
                  return ret;
              }, []);
          }
      }
      return values;
  };
  Chart.prototype.data.names = function (names) {
      this.internal.clearLegendItemTextBoxCache();
      return this.internal.updateDataAttributes('names', names);
  };
  Chart.prototype.data.colors = function (colors) {
      return this.internal.updateDataAttributes('colors', colors);
  };
  Chart.prototype.data.axes = function (axes) {
      return this.internal.updateDataAttributes('axes', axes);
  };
  Chart.prototype.data.stackNormalized = function (normalized) {
      if (normalized === undefined) {
          return this.internal.isStackNormalized();
      }
      this.internal.config.data_stack_normalize = !!normalized;
      this.internal.redraw();
  };

  Chart.prototype.donut = function () { };
  Chart.prototype.donut.padAngle = function (padAngle) {
      if (padAngle === undefined) {
          return this.internal.config.donut_padAngle;
      }
      this.internal.config.donut_padAngle = padAngle;
      this.flush();
  };

  Chart.prototype.flow = function (args) {
      var $$ = this.internal, targets, data, notfoundIds = [], orgDataCount = $$.getMaxDataCount(), dataCount, domain, baseTarget, baseValue, length = 0, tail = 0, diff, to;
      if (args.json) {
          data = $$.convertJsonToData(args.json, args.keys);
      }
      else if (args.rows) {
          data = $$.convertRowsToData(args.rows);
      }
      else if (args.columns) {
          data = $$.convertColumnsToData(args.columns);
      }
      else {
          return;
      }
      targets = $$.convertDataToTargets(data, true);
      // Update/Add data
      $$.data.targets.forEach(function (t) {
          var found = false, i, j;
          for (i = 0; i < targets.length; i++) {
              if (t.id === targets[i].id) {
                  found = true;
                  if (t.values[t.values.length - 1]) {
                      tail = t.values[t.values.length - 1].index + 1;
                  }
                  length = targets[i].values.length;
                  for (j = 0; j < length; j++) {
                      targets[i].values[j].index = tail + j;
                      if (!$$.isTimeSeries()) {
                          targets[i].values[j].x = tail + j;
                      }
                  }
                  t.values = t.values.concat(targets[i].values);
                  targets.splice(i, 1);
                  break;
              }
          }
          if (!found) {
              notfoundIds.push(t.id);
          }
      });
      // Append null for not found targets
      $$.data.targets.forEach(function (t) {
          var i, j;
          for (i = 0; i < notfoundIds.length; i++) {
              if (t.id === notfoundIds[i]) {
                  tail = t.values[t.values.length - 1].index + 1;
                  for (j = 0; j < length; j++) {
                      t.values.push({
                          id: t.id,
                          index: tail + j,
                          x: $$.isTimeSeries() ? $$.getOtherTargetX(tail + j) : tail + j,
                          value: null
                      });
                  }
              }
          }
      });
      // Generate null values for new target
      if ($$.data.targets.length) {
          targets.forEach(function (t) {
              var i, missing = [];
              for (i = $$.data.targets[0].values[0].index; i < tail; i++) {
                  missing.push({
                      id: t.id,
                      index: i,
                      x: $$.isTimeSeries() ? $$.getOtherTargetX(i) : i,
                      value: null
                  });
              }
              t.values.forEach(function (v) {
                  v.index += tail;
                  if (!$$.isTimeSeries()) {
                      v.x += tail;
                  }
              });
              t.values = missing.concat(t.values);
          });
      }
      $$.data.targets = $$.data.targets.concat(targets); // add remained
      // check data count because behavior needs to change when it's only one
      dataCount = $$.getMaxDataCount();
      baseTarget = $$.data.targets[0];
      baseValue = baseTarget.values[0];
      // Update length to flow if needed
      if (isDefined(args.to)) {
          length = 0;
          to = $$.isTimeSeries() ? $$.parseDate(args.to) : args.to;
          baseTarget.values.forEach(function (v) {
              if (v.x < to) {
                  length++;
              }
          });
      }
      else if (isDefined(args.length)) {
          length = args.length;
      }
      // If only one data, update the domain to flow from left edge of the chart
      if (!orgDataCount) {
          if ($$.isTimeSeries()) {
              if (baseTarget.values.length > 1) {
                  diff = baseTarget.values[baseTarget.values.length - 1].x - baseValue.x;
              }
              else {
                  diff = baseValue.x - $$.getXDomain($$.data.targets)[0];
              }
          }
          else {
              diff = 1;
          }
          domain = [baseValue.x - diff, baseValue.x];
          $$.updateXDomain(null, true, true, false, domain);
      }
      else if (orgDataCount === 1) {
          if ($$.isTimeSeries()) {
              diff =
                  (baseTarget.values[baseTarget.values.length - 1].x - baseValue.x) / 2;
              domain = [new Date(+baseValue.x - diff), new Date(+baseValue.x + diff)];
              $$.updateXDomain(null, true, true, false, domain);
          }
      }
      // Set targets
      $$.updateTargets($$.data.targets);
      // Redraw with new targets
      $$.redraw({
          flow: {
              index: baseValue.index,
              length: length,
              duration: isValue(args.duration)
                  ? args.duration
                  : $$.config.transition_duration,
              done: args.done,
              orgDataCount: orgDataCount
          },
          withLegend: true,
          withTransition: orgDataCount > 1,
          withTrimXDomain: false,
          withUpdateXAxis: true
      });
  };
  ChartInternal.prototype.generateFlow = function (args) {
      var $$ = this, config = $$.config, d3 = $$.d3;
      return function () {
          var targets = args.targets, flow = args.flow, drawBar = args.drawBar, drawLine = args.drawLine, drawArea = args.drawArea, cx = args.cx, cy = args.cy, xv = args.xv, xForText = args.xForText, yForText = args.yForText, duration = args.duration;
          var translateX, scaleX = 1, transform, flowIndex = flow.index, flowLength = flow.length, flowStart = $$.getValueOnIndex($$.data.targets[0].values, flowIndex), flowEnd = $$.getValueOnIndex($$.data.targets[0].values, flowIndex + flowLength), orgDomain = $$.x.domain(), domain, durationForFlow = flow.duration || duration, done = flow.done || function () { }, wait = $$.generateWait();
          var xgrid, xgridLines, mainRegion, mainText, mainBar, mainLine, mainArea, mainCircle;
          // set flag
          $$.flowing = true;
          // remove head data after rendered
          $$.data.targets.forEach(function (d) {
              d.values.splice(0, flowLength);
          });
          // update x domain to generate axis elements for flow
          domain = $$.updateXDomain(targets, true, true);
          // update elements related to x scale
          if ($$.updateXGrid) {
              $$.updateXGrid(true);
          }
          xgrid = $$.xgrid || d3.selectAll([]); // xgrid needs to be obtained after updateXGrid
          xgridLines = $$.xgridLines || d3.selectAll([]);
          mainRegion = $$.mainRegion || d3.selectAll([]);
          mainText = $$.mainText || d3.selectAll([]);
          mainBar = $$.mainBar || d3.selectAll([]);
          mainLine = $$.mainLine || d3.selectAll([]);
          mainArea = $$.mainArea || d3.selectAll([]);
          mainCircle = $$.mainCircle || d3.selectAll([]);
          // generate transform to flow
          if (!flow.orgDataCount) {
              // if empty
              if ($$.data.targets[0].values.length !== 1) {
                  translateX = $$.x(orgDomain[0]) - $$.x(domain[0]);
              }
              else {
                  if ($$.isTimeSeries()) {
                      flowStart = $$.getValueOnIndex($$.data.targets[0].values, 0);
                      flowEnd = $$.getValueOnIndex($$.data.targets[0].values, $$.data.targets[0].values.length - 1);
                      translateX = $$.x(flowStart.x) - $$.x(flowEnd.x);
                  }
                  else {
                      translateX = diffDomain(domain) / 2;
                  }
              }
          }
          else if (flow.orgDataCount === 1 ||
              (flowStart && flowStart.x) === (flowEnd && flowEnd.x)) {
              translateX = $$.x(orgDomain[0]) - $$.x(domain[0]);
          }
          else {
              if ($$.isTimeSeries()) {
                  translateX = $$.x(orgDomain[0]) - $$.x(domain[0]);
              }
              else {
                  translateX = $$.x(flowStart.x) - $$.x(flowEnd.x);
              }
          }
          scaleX = diffDomain(orgDomain) / diffDomain(domain);
          transform = 'translate(' + translateX + ',0) scale(' + scaleX + ',1)';
          $$.hideXGridFocus();
          var flowTransition = d3
              .transition()
              .ease(d3.easeLinear)
              .duration(durationForFlow);
          wait.add($$.xAxis($$.axes.x, flowTransition));
          wait.add(mainBar.transition(flowTransition).attr('transform', transform));
          wait.add(mainLine.transition(flowTransition).attr('transform', transform));
          wait.add(mainArea.transition(flowTransition).attr('transform', transform));
          wait.add(mainCircle.transition(flowTransition).attr('transform', transform));
          wait.add(mainText.transition(flowTransition).attr('transform', transform));
          wait.add(mainRegion
              .filter($$.isRegionOnX)
              .transition(flowTransition)
              .attr('transform', transform));
          wait.add(xgrid.transition(flowTransition).attr('transform', transform));
          wait.add(xgridLines.transition(flowTransition).attr('transform', transform));
          wait(function () {
              var i, shapes = [], texts = [];
              // remove flowed elements
              if (flowLength) {
                  for (i = 0; i < flowLength; i++) {
                      shapes.push('.' + CLASS.shape + '-' + (flowIndex + i));
                      texts.push('.' + CLASS.text + '-' + (flowIndex + i));
                  }
                  $$.svg
                      .selectAll('.' + CLASS.shapes)
                      .selectAll(shapes)
                      .remove();
                  $$.svg
                      .selectAll('.' + CLASS.texts)
                      .selectAll(texts)
                      .remove();
                  $$.svg.select('.' + CLASS.xgrid).remove();
              }
              // draw again for removing flowed elements and reverting attr
              xgrid
                  .attr('transform', null)
                  .attr('x1', $$.xgridAttr.x1)
                  .attr('x2', $$.xgridAttr.x2)
                  .attr('y1', $$.xgridAttr.y1)
                  .attr('y2', $$.xgridAttr.y2)
                  .style('opacity', $$.xgridAttr.opacity);
              xgridLines.attr('transform', null);
              xgridLines
                  .select('line')
                  .attr('x1', config.axis_rotated ? 0 : xv)
                  .attr('x2', config.axis_rotated ? $$.width : xv);
              xgridLines
                  .select('text')
                  .attr('x', config.axis_rotated ? $$.width : 0)
                  .attr('y', xv);
              mainBar.attr('transform', null).attr('d', drawBar);
              mainLine.attr('transform', null).attr('d', drawLine);
              mainArea.attr('transform', null).attr('d', drawArea);
              mainCircle
                  .attr('transform', null)
                  .attr('cx', cx)
                  .attr('cy', cy);
              mainText
                  .attr('transform', null)
                  .attr('x', xForText)
                  .attr('y', yForText)
                  .style('fill-opacity', $$.opacityForText.bind($$));
              mainRegion.attr('transform', null);
              mainRegion
                  .filter($$.isRegionOnX)
                  .attr('x', $$.regionX.bind($$))
                  .attr('width', $$.regionWidth.bind($$));
              // callback for end of flow
              done();
              $$.flowing = false;
          });
      };
  };

  Chart.prototype.focus = function (targetIds) {
      var $$ = this.internal, candidates;
      targetIds = $$.mapToTargetIds(targetIds);
      (candidates = $$.svg.selectAll($$.selectorTargets(targetIds.filter($$.isTargetToShow, $$)))),
          this.revert();
      this.defocus();
      candidates.classed(CLASS.focused, true).classed(CLASS.defocused, false);
      if ($$.hasArcType()) {
          $$.expandArc(targetIds);
      }
      $$.toggleFocusLegend(targetIds, true);
      $$.focusedTargetIds = targetIds;
      $$.defocusedTargetIds = $$.defocusedTargetIds.filter(function (id) {
          return targetIds.indexOf(id) < 0;
      });
  };
  Chart.prototype.defocus = function (targetIds) {
      var $$ = this.internal, candidates;
      targetIds = $$.mapToTargetIds(targetIds);
      (candidates = $$.svg.selectAll($$.selectorTargets(targetIds.filter($$.isTargetToShow, $$)))),
          candidates.classed(CLASS.focused, false).classed(CLASS.defocused, true);
      if ($$.hasArcType()) {
          $$.unexpandArc(targetIds);
      }
      $$.toggleFocusLegend(targetIds, false);
      $$.focusedTargetIds = $$.focusedTargetIds.filter(function (id) {
          return targetIds.indexOf(id) < 0;
      });
      $$.defocusedTargetIds = targetIds;
  };
  Chart.prototype.revert = function (targetIds) {
      var $$ = this.internal, candidates;
      targetIds = $$.mapToTargetIds(targetIds);
      candidates = $$.svg.selectAll($$.selectorTargets(targetIds)); // should be for all targets
      candidates.classed(CLASS.focused, false).classed(CLASS.defocused, false);
      if ($$.hasArcType()) {
          $$.unexpandArc(targetIds);
      }
      if ($$.config.legend_show) {
          $$.showLegend(targetIds.filter($$.isLegendToShow.bind($$)));
          $$.legend
              .selectAll($$.selectorLegends(targetIds))
              .filter(function () {
              return $$.d3.select(this).classed(CLASS.legendItemFocused);
          })
              .classed(CLASS.legendItemFocused, false);
      }
      $$.focusedTargetIds = [];
      $$.defocusedTargetIds = [];
  };

  Chart.prototype.xgrids = function (grids) {
      var $$ = this.internal, config = $$.config;
      if (!grids) {
          return config.grid_x_lines;
      }
      config.grid_x_lines = grids;
      $$.redrawWithoutRescale();
      return config.grid_x_lines;
  };
  Chart.prototype.xgrids.add = function (grids) {
      var $$ = this.internal;
      return this.xgrids($$.config.grid_x_lines.concat(grids ? grids : []));
  };
  Chart.prototype.xgrids.remove = function (params) {
      // TODO: multiple
      var $$ = this.internal;
      $$.removeGridLines(params, true);
  };
  Chart.prototype.ygrids = function (grids) {
      var $$ = this.internal, config = $$.config;
      if (!grids) {
          return config.grid_y_lines;
      }
      config.grid_y_lines = grids;
      $$.redrawWithoutRescale();
      return config.grid_y_lines;
  };
  Chart.prototype.ygrids.add = function (grids) {
      var $$ = this.internal;
      return this.ygrids($$.config.grid_y_lines.concat(grids ? grids : []));
  };
  Chart.prototype.ygrids.remove = function (params) {
      // TODO: multiple
      var $$ = this.internal;
      $$.removeGridLines(params, false);
  };

  Chart.prototype.groups = function (groups) {
      var $$ = this.internal, config = $$.config;
      if (isUndefined(groups)) {
          return config.data_groups;
      }
      config.data_groups = groups;
      $$.redraw();
      return config.data_groups;
  };

  Chart.prototype.legend = function () { };
  Chart.prototype.legend.show = function (targetIds) {
      var $$ = this.internal;
      $$.showLegend($$.mapToTargetIds(targetIds));
      $$.updateAndRedraw({ withLegend: true });
  };
  Chart.prototype.legend.hide = function (targetIds) {
      var $$ = this.internal;
      $$.hideLegend($$.mapToTargetIds(targetIds));
      $$.updateAndRedraw({ withLegend: false });
  };

  Chart.prototype.load = function (args) {
      var $$ = this.internal, config = $$.config;
      // update xs if specified
      if (args.xs) {
          $$.addXs(args.xs);
      }
      // update names if exists
      if ('names' in args) {
          Chart.prototype.data.names.bind(this)(args.names);
      }
      // update classes if exists
      if ('classes' in args) {
          Object.keys(args.classes).forEach(function (id) {
              config.data_classes[id] = args.classes[id];
          });
      }
      // update categories if exists
      if ('categories' in args && $$.isCategorized()) {
          config.axis_x_categories = args.categories;
      }
      // update axes if exists
      if ('axes' in args) {
          Object.keys(args.axes).forEach(function (id) {
              config.data_axes[id] = args.axes[id];
          });
      }
      // update colors if exists
      if ('colors' in args) {
          Object.keys(args.colors).forEach(function (id) {
              config.data_colors[id] = args.colors[id];
          });
      }
      // use cache if exists
      if ('cacheIds' in args && $$.hasCaches(args.cacheIds)) {
          $$.load($$.getCaches(args.cacheIds), args.done);
          return;
      }
      // unload if needed
      if (args.unload) {
          // TODO: do not unload if target will load (included in url/rows/columns)
          $$.unload($$.mapToTargetIds(args.unload === true ? null : args.unload), function () {
              $$.loadFromArgs(args);
          });
      }
      else {
          $$.loadFromArgs(args);
      }
  };
  Chart.prototype.unload = function (args) {
      var $$ = this.internal;
      args = args || {};
      if (args instanceof Array) {
          args = { ids: args };
      }
      else if (typeof args === 'string') {
          args = { ids: [args] };
      }
      $$.unload($$.mapToTargetIds(args.ids), function () {
          $$.redraw({
              withUpdateOrgXDomain: true,
              withUpdateXDomain: true,
              withLegend: true
          });
          if (args.done) {
              args.done();
          }
      });
  };

  Chart.prototype.pie = function () { };
  Chart.prototype.pie.padAngle = function (padAngle) {
      if (padAngle === undefined) {
          return this.internal.config.pie_padAngle;
      }
      this.internal.config.pie_padAngle = padAngle;
      this.flush();
  };

  Chart.prototype.regions = function (regions) {
      var $$ = this.internal, config = $$.config;
      if (!regions) {
          return config.regions;
      }
      config.regions = regions;
      $$.redrawWithoutRescale();
      return config.regions;
  };
  Chart.prototype.regions.add = function (regions) {
      var $$ = this.internal, config = $$.config;
      if (!regions) {
          return config.regions;
      }
      config.regions = config.regions.concat(regions);
      $$.redrawWithoutRescale();
      return config.regions;
  };
  Chart.prototype.regions.remove = function (options) {
      var $$ = this.internal, config = $$.config, duration, classes, regions;
      options = options || {};
      duration = getOption(options, 'duration', config.transition_duration);
      classes = getOption(options, 'classes', [CLASS.region]);
      regions = $$.main.select('.' + CLASS.regions).selectAll(classes.map(function (c) {
          return '.' + c;
      }));
      (duration ? regions.transition().duration(duration) : regions)
          .style('opacity', 0)
          .remove();
      config.regions = config.regions.filter(function (region) {
          var found = false;
          if (!region['class']) {
              return true;
          }
          region['class'].split(' ').forEach(function (c) {
              if (classes.indexOf(c) >= 0) {
                  found = true;
              }
          });
          return !found;
      });
      return config.regions;
  };

  Chart.prototype.selected = function (targetId) {
      var $$ = this.internal, d3 = $$.d3;
      return $$.main
          .selectAll('.' + CLASS.shapes + $$.getTargetSelectorSuffix(targetId))
          .selectAll('.' + CLASS.shape)
          .filter(function () {
          return d3.select(this).classed(CLASS.SELECTED);
      })
          .nodes()
          .map(function (d) {
          var data = d.__data__;
          return data.data ? data.data : data;
      });
  };
  Chart.prototype.select = function (ids, indices, resetOther) {
      var $$ = this.internal, d3 = $$.d3, config = $$.config;
      if (!config.data_selection_enabled) {
          return;
      }
      $$.main
          .selectAll('.' + CLASS.shapes)
          .selectAll('.' + CLASS.shape)
          .each(function (d, i) {
          var shape = d3.select(this), id = d.data ? d.data.id : d.id, toggle = $$.getToggle(this, d).bind($$), isTargetId = config.data_selection_grouped || !ids || ids.indexOf(id) >= 0, isTargetIndex = !indices || indices.indexOf(i) >= 0, isSelected = shape.classed(CLASS.SELECTED);
          // line/area selection not supported yet
          if (shape.classed(CLASS.line) || shape.classed(CLASS.area)) {
              return;
          }
          if (isTargetId && isTargetIndex) {
              if (config.data_selection_isselectable(d) && !isSelected) {
                  toggle(true, shape.classed(CLASS.SELECTED, true), d, i);
              }
          }
          else if (isDefined(resetOther) && resetOther) {
              if (isSelected) {
                  toggle(false, shape.classed(CLASS.SELECTED, false), d, i);
              }
          }
      });
  };
  Chart.prototype.unselect = function (ids, indices) {
      var $$ = this.internal, d3 = $$.d3, config = $$.config;
      if (!config.data_selection_enabled) {
          return;
      }
      $$.main
          .selectAll('.' + CLASS.shapes)
          .selectAll('.' + CLASS.shape)
          .each(function (d, i) {
          var shape = d3.select(this), id = d.data ? d.data.id : d.id, toggle = $$.getToggle(this, d).bind($$), isTargetId = config.data_selection_grouped || !ids || ids.indexOf(id) >= 0, isTargetIndex = !indices || indices.indexOf(i) >= 0, isSelected = shape.classed(CLASS.SELECTED);
          // line/area selection not supported yet
          if (shape.classed(CLASS.line) || shape.classed(CLASS.area)) {
              return;
          }
          if (isTargetId && isTargetIndex) {
              if (config.data_selection_isselectable(d)) {
                  if (isSelected) {
                      toggle(false, shape.classed(CLASS.SELECTED, false), d, i);
                  }
              }
          }
      });
  };

  Chart.prototype.show = function (targetIds, options) {
      var $$ = this.internal, targets;
      targetIds = $$.mapToTargetIds(targetIds);
      options = options || {};
      $$.removeHiddenTargetIds(targetIds);
      targets = $$.svg.selectAll($$.selectorTargets(targetIds));
      targets
          .transition()
          .style('display', isIE() ? 'block' : 'initial', 'important')
          .style('opacity', 1, 'important')
          .call($$.endall, function () {
          targets.style('opacity', null).style('opacity', 1);
      });
      if (options.withLegend) {
          $$.showLegend(targetIds);
      }
      $$.redraw({
          withUpdateOrgXDomain: true,
          withUpdateXDomain: true,
          withLegend: true
      });
  };
  Chart.prototype.hide = function (targetIds, options) {
      var $$ = this.internal, targets;
      targetIds = $$.mapToTargetIds(targetIds);
      options = options || {};
      $$.addHiddenTargetIds(targetIds);
      targets = $$.svg.selectAll($$.selectorTargets(targetIds));
      targets
          .transition()
          .style('opacity', 0, 'important')
          .call($$.endall, function () {
          targets.style('opacity', null).style('opacity', 0);
          targets.style('display', 'none');
      });
      if (options.withLegend) {
          $$.hideLegend(targetIds);
      }
      $$.redraw({
          withUpdateOrgXDomain: true,
          withUpdateXDomain: true,
          withLegend: true
      });
  };
  Chart.prototype.toggle = function (targetIds, options) {
      var that = this, $$ = this.internal;
      $$.mapToTargetIds(targetIds).forEach(function (targetId) {
          $$.isTargetToShow(targetId)
              ? that.hide(targetId, options)
              : that.show(targetId, options);
      });
  };

  Chart.prototype.subchart = function () { };
  Chart.prototype.subchart.isShown = function () {
      var $$ = this.internal;
      return $$.config.subchart_show;
  };
  Chart.prototype.subchart.show = function () {
      var $$ = this.internal;
      if ($$.config.subchart_show) {
          return;
      }
      $$.config.subchart_show = true;
      // insert DOM
      $$.initSubchart();
      // update dimensions with sub chart now visible
      $$.updateDimension();
      // insert brush (depends on sizes previously updated)
      $$.initSubchartBrush();
      // attach data
      $$.updateTargetsForSubchart($$.getTargets());
      // reset fade-in state
      $$.mapToIds($$.data.targets).forEach(function (id) {
          $$.withoutFadeIn[id] = false;
      });
      // redraw chart !
      $$.updateAndRedraw();
      // update visible targets !
      $$.showTargets();
  };
  Chart.prototype.subchart.hide = function () {
      var $$ = this.internal;
      if (!$$.config.subchart_show) {
          return;
      }
      $$.config.subchart_show = false;
      // remove DOM
      $$.removeSubchart();
      // re-render chart
      $$.redraw();
  };

  Chart.prototype.tooltip = function () { };
  Chart.prototype.tooltip.show = function (args) {
      var $$ = this.internal, targets, data, mouse = {};
      // determine mouse position on the chart
      if (args.mouse) {
          mouse = args.mouse;
      }
      else {
          // determine focus data
          if (args.data) {
              data = args.data;
          }
          else if (typeof args.x !== 'undefined') {
              if (args.id) {
                  targets = $$.data.targets.filter(function (t) {
                      return t.id === args.id;
                  });
              }
              else {
                  targets = $$.data.targets;
              }
              data = $$.filterByX(targets, args.x).slice(0, 1)[0];
          }
          mouse = data ? $$.getMousePosition(data) : null;
      }
      // emulate mouse events to show
      $$.dispatchEvent('mousemove', mouse);
      $$.config.tooltip_onshow.call($$, data);
  };
  Chart.prototype.tooltip.hide = function () {
      // TODO: get target data by checking the state of focus
      this.internal.dispatchEvent('mouseout', 0);
      this.internal.config.tooltip_onhide.call(this);
  };

  Chart.prototype.transform = function (type, targetIds) {
      var $$ = this.internal, options = ['pie', 'donut'].indexOf(type) >= 0 ? { withTransform: true } : null;
      $$.transformTo(targetIds, type, options);
  };
  ChartInternal.prototype.transformTo = function (targetIds, type, optionsForRedraw) {
      var $$ = this, withTransitionForAxis = !$$.hasArcType(), options = optionsForRedraw || {
          withTransitionForAxis: withTransitionForAxis
      };
      options.withTransitionForTransform = false;
      $$.transiting = false;
      $$.setTargetType(targetIds, type);
      $$.updateTargets($$.data.targets); // this is needed when transforming to arc
      $$.updateAndRedraw(options);
  };

  Chart.prototype.x = function (x) {
      var $$ = this.internal;
      if (arguments.length) {
          $$.updateTargetX($$.data.targets, x);
          $$.redraw({ withUpdateOrgXDomain: true, withUpdateXDomain: true });
      }
      return $$.data.xs;
  };
  Chart.prototype.xs = function (xs) {
      var $$ = this.internal;
      if (arguments.length) {
          $$.updateTargetXs($$.data.targets, xs);
          $$.redraw({ withUpdateOrgXDomain: true, withUpdateXDomain: true });
      }
      return $$.data.xs;
  };

  Chart.prototype.zoom = function (domain) {
      var $$ = this.internal;
      if (domain) {
          if ($$.isTimeSeries()) {
              domain = domain.map(function (x) {
                  return $$.parseDate(x);
              });
          }
          if ($$.config.subchart_show) {
              $$.brush.selectionAsValue(domain, true);
          }
          else {
              $$.updateXDomain(null, true, false, false, domain);
              $$.redraw({ withY: $$.config.zoom_rescale, withSubchart: false });
          }
          $$.config.zoom_onzoom.call(this, $$.x.orgDomain());
          return domain;
      }
      else {
          return $$.x.domain();
      }
  };
  Chart.prototype.zoom.enable = function (enabled) {
      var $$ = this.internal;
      $$.config.zoom_enabled = enabled;
      $$.updateAndRedraw();
  };
  Chart.prototype.unzoom = function () {
      var $$ = this.internal;
      if ($$.config.subchart_show) {
          $$.brush.clear();
      }
      else {
          $$.updateXDomain(null, true, false, false, $$.subX.domain());
          $$.redraw({ withY: $$.config.zoom_rescale, withSubchart: false });
      }
  };
  Chart.prototype.zoom.max = function (max) {
      var $$ = this.internal, config = $$.config, d3 = $$.d3;
      if (max === 0 || max) {
          config.zoom_x_max = d3.max([$$.orgXDomain[1], max]);
      }
      else {
          return config.zoom_x_max;
      }
  };
  Chart.prototype.zoom.min = function (min) {
      var $$ = this.internal, config = $$.config, d3 = $$.d3;
      if (min === 0 || min) {
          config.zoom_x_min = d3.min([$$.orgXDomain[0], min]);
      }
      else {
          return config.zoom_x_min;
      }
  };
  Chart.prototype.zoom.range = function (range) {
      if (arguments.length) {
          if (isDefined(range.max)) {
              this.domain.max(range.max);
          }
          if (isDefined(range.min)) {
              this.domain.min(range.min);
          }
      }
      else {
          return {
              max: this.domain.max(),
              min: this.domain.min()
          };
      }
  };

  ChartInternal.prototype.initPie = function () {
      var $$ = this, d3 = $$.d3;
      $$.pie = d3
          .pie()
          .padAngle(this.getPadAngle.bind(this))
          .value(function (d) {
          return d.values.reduce(function (a, b) {
              return a + b.value;
          }, 0);
      });
      var orderFct = $$.getOrderFunction();
      // we need to reverse the returned order if asc or desc to have the slice in expected order.
      if (orderFct && ($$.isOrderAsc() || $$.isOrderDesc())) {
          var defaultSort_1 = orderFct;
          orderFct = function (t1, t2) { return defaultSort_1(t1, t2) * -1; };
      }
      $$.pie.sort(orderFct || null);
  };
  ChartInternal.prototype.updateRadius = function () {
      var $$ = this, config = $$.config, w = config.gauge_width || config.donut_width, gaugeArcWidth = $$.filterTargetsToShow($$.data.targets).length *
          $$.config.gauge_arcs_minWidth;
      $$.radiusExpanded =
          (Math.min($$.arcWidth, $$.arcHeight) / 2) * ($$.hasType('gauge') ? 0.85 : 1);
      $$.radius = $$.radiusExpanded * 0.95;
      $$.innerRadiusRatio = w ? ($$.radius - w) / $$.radius : 0.6;
      $$.innerRadius =
          $$.hasType('donut') || $$.hasType('gauge')
              ? $$.radius * $$.innerRadiusRatio
              : 0;
      $$.gaugeArcWidth = w
          ? w
          : gaugeArcWidth <= $$.radius - $$.innerRadius
              ? $$.radius - $$.innerRadius
              : gaugeArcWidth <= $$.radius
                  ? gaugeArcWidth
                  : $$.radius;
  };
  ChartInternal.prototype.getPadAngle = function () {
      if (this.hasType('pie')) {
          return this.config.pie_padAngle || 0;
      }
      else if (this.hasType('donut')) {
          return this.config.donut_padAngle || 0;
      }
      else {
          return 0;
      }
  };
  ChartInternal.prototype.updateArc = function () {
      var $$ = this;
      $$.svgArc = $$.getSvgArc();
      $$.svgArcExpanded = $$.getSvgArcExpanded();
      $$.svgArcExpandedSub = $$.getSvgArcExpanded(0.98);
  };
  ChartInternal.prototype.updateAngle = function (d) {
      var $$ = this, config = $$.config, found = false, index = 0, gMin, gMax, gTic, gValue;
      if (!config) {
          return null;
      }
      $$.pie($$.filterTargetsToShow($$.data.targets)).forEach(function (t) {
          if (!found && t.data.id === d.data.id) {
              found = true;
              d = t;
              d.index = index;
          }
          index++;
      });
      if (isNaN(d.startAngle)) {
          d.startAngle = 0;
      }
      if (isNaN(d.endAngle)) {
          d.endAngle = d.startAngle;
      }
      if ($$.isGaugeType(d.data)) {
          gMin = config.gauge_min;
          gMax = config.gauge_max;
          gTic = (Math.PI * (config.gauge_fullCircle ? 2 : 1)) / (gMax - gMin);
          gValue = d.value < gMin ? 0 : d.value < gMax ? d.value - gMin : gMax - gMin;
          d.startAngle = config.gauge_startingAngle;
          d.endAngle = d.startAngle + gTic * gValue;
      }
      return found ? d : null;
  };
  ChartInternal.prototype.getSvgArc = function () {
      var $$ = this, hasGaugeType = $$.hasType('gauge'), singleArcWidth = $$.gaugeArcWidth / $$.filterTargetsToShow($$.data.targets).length, arc = $$.d3
          .arc()
          .outerRadius(function (d) {
          return hasGaugeType ? $$.radius - singleArcWidth * d.index : $$.radius;
      })
          .innerRadius(function (d) {
          return hasGaugeType
              ? $$.radius - singleArcWidth * (d.index + 1)
              : $$.innerRadius;
      }), newArc = function (d, withoutUpdate) {
          var updated;
          if (withoutUpdate) {
              return arc(d);
          } // for interpolate
          updated = $$.updateAngle(d);
          return updated ? arc(updated) : 'M 0 0';
      };
      newArc.centroid = arc.centroid;
      return newArc;
  };
  ChartInternal.prototype.getSvgArcExpanded = function (rate) {
      rate = rate || 1;
      var $$ = this, hasGaugeType = $$.hasType('gauge'), singleArcWidth = $$.gaugeArcWidth / $$.filterTargetsToShow($$.data.targets).length, expandWidth = Math.min($$.radiusExpanded * rate - $$.radius, singleArcWidth * 0.8 - (1 - rate) * 100), arc = $$.d3
          .arc()
          .outerRadius(function (d) {
          return hasGaugeType
              ? $$.radius - singleArcWidth * d.index + expandWidth
              : $$.radiusExpanded * rate;
      })
          .innerRadius(function (d) {
          return hasGaugeType
              ? $$.radius - singleArcWidth * (d.index + 1)
              : $$.innerRadius;
      });
      return function (d) {
          var updated = $$.updateAngle(d);
          return updated ? arc(updated) : 'M 0 0';
      };
  };
  ChartInternal.prototype.getArc = function (d, withoutUpdate, force) {
      return force || this.isArcType(d.data)
          ? this.svgArc(d, withoutUpdate)
          : 'M 0 0';
  };
  ChartInternal.prototype.transformForArcLabel = function (d) {
      var $$ = this, config = $$.config, updated = $$.updateAngle(d), c, x, y, h, ratio, translate = '', hasGauge = $$.hasType('gauge');
      if (updated && !hasGauge) {
          c = this.svgArc.centroid(updated);
          x = isNaN(c[0]) ? 0 : c[0];
          y = isNaN(c[1]) ? 0 : c[1];
          h = Math.sqrt(x * x + y * y);
          if ($$.hasType('donut') && config.donut_label_ratio) {
              ratio = isFunction(config.donut_label_ratio)
                  ? config.donut_label_ratio(d, $$.radius, h)
                  : config.donut_label_ratio;
          }
          else if ($$.hasType('pie') && config.pie_label_ratio) {
              ratio = isFunction(config.pie_label_ratio)
                  ? config.pie_label_ratio(d, $$.radius, h)
                  : config.pie_label_ratio;
          }
          else {
              ratio =
                  $$.radius && h
                      ? ((36 / $$.radius > 0.375 ? 1.175 - 36 / $$.radius : 0.8) *
                          $$.radius) /
                          h
                      : 0;
          }
          translate = 'translate(' + x * ratio + ',' + y * ratio + ')';
      }
      else if (updated &&
          hasGauge &&
          $$.filterTargetsToShow($$.data.targets).length > 1) {
          var y1 = Math.sin(updated.endAngle - Math.PI / 2);
          x = Math.cos(updated.endAngle - Math.PI / 2) * ($$.radiusExpanded + 25);
          y = y1 * ($$.radiusExpanded + 15 - Math.abs(y1 * 10)) + 3;
          translate = 'translate(' + x + ',' + y + ')';
      }
      return translate;
  };
  /**
   * @deprecated Use `getRatio('arc', d)` instead.
   */
  ChartInternal.prototype.getArcRatio = function (d) {
      return this.getRatio('arc', d);
  };
  ChartInternal.prototype.convertToArcData = function (d) {
      return this.addName({
          id: d.data.id,
          value: d.value,
          ratio: this.getRatio('arc', d),
          index: d.index
      });
  };
  ChartInternal.prototype.textForArcLabel = function (d) {
      var $$ = this, updated, value, ratio, id, format;
      if (!$$.shouldShowArcLabel()) {
          return '';
      }
      updated = $$.updateAngle(d);
      value = updated ? updated.value : null;
      ratio = $$.getRatio('arc', updated);
      id = d.data.id;
      if (!$$.hasType('gauge') && !$$.meetsArcLabelThreshold(ratio)) {
          return '';
      }
      format = $$.getArcLabelFormat();
      return format
          ? format(value, ratio, id)
          : $$.defaultArcValueFormat(value, ratio);
  };
  ChartInternal.prototype.textForGaugeMinMax = function (value, isMax) {
      var $$ = this, format = $$.getGaugeLabelExtents();
      return format ? format(value, isMax) : value;
  };
  ChartInternal.prototype.expandArc = function (targetIds) {
      var $$ = this, interval;
      // MEMO: avoid to cancel transition
      if ($$.transiting) {
          interval = window.setInterval(function () {
              if (!$$.transiting) {
                  window.clearInterval(interval);
                  if ($$.legend.selectAll('.c3-legend-item-focused').size() > 0) {
                      $$.expandArc(targetIds);
                  }
              }
          }, 10);
          return;
      }
      targetIds = $$.mapToTargetIds(targetIds);
      $$.svg
          .selectAll($$.selectorTargets(targetIds, '.' + CLASS.chartArc))
          .each(function (d) {
          if (!$$.shouldExpand(d.data.id)) {
              return;
          }
          $$.d3
              .select(this)
              .selectAll('path')
              .transition()
              .duration($$.expandDuration(d.data.id))
              .attr('d', $$.svgArcExpanded)
              .transition()
              .duration($$.expandDuration(d.data.id) * 2)
              .attr('d', $$.svgArcExpandedSub)
              .each(function (d) {
              if ($$.isDonutType(d.data)) ;
          });
      });
  };
  ChartInternal.prototype.unexpandArc = function (targetIds) {
      var $$ = this;
      if ($$.transiting) {
          return;
      }
      targetIds = $$.mapToTargetIds(targetIds);
      $$.svg
          .selectAll($$.selectorTargets(targetIds, '.' + CLASS.chartArc))
          .selectAll('path')
          .transition()
          .duration(function (d) {
          return $$.expandDuration(d.data.id);
      })
          .attr('d', $$.svgArc);
      $$.svg.selectAll('.' + CLASS.arc);
  };
  ChartInternal.prototype.expandDuration = function (id) {
      var $$ = this, config = $$.config;
      if ($$.isDonutType(id)) {
          return config.donut_expand_duration;
      }
      else if ($$.isGaugeType(id)) {
          return config.gauge_expand_duration;
      }
      else if ($$.isPieType(id)) {
          return config.pie_expand_duration;
      }
      else {
          return 50;
      }
  };
  ChartInternal.prototype.shouldExpand = function (id) {
      var $$ = this, config = $$.config;
      return (($$.isDonutType(id) && config.donut_expand) ||
          ($$.isGaugeType(id) && config.gauge_expand) ||
          ($$.isPieType(id) && config.pie_expand));
  };
  ChartInternal.prototype.shouldShowArcLabel = function () {
      var $$ = this, config = $$.config, shouldShow = true;
      if ($$.hasType('donut')) {
          shouldShow = config.donut_label_show;
      }
      else if ($$.hasType('pie')) {
          shouldShow = config.pie_label_show;
      }
      // when gauge, always true
      return shouldShow;
  };
  ChartInternal.prototype.meetsArcLabelThreshold = function (ratio) {
      var $$ = this, config = $$.config, threshold = $$.hasType('donut')
          ? config.donut_label_threshold
          : config.pie_label_threshold;
      return ratio >= threshold;
  };
  ChartInternal.prototype.getArcLabelFormat = function () {
      var $$ = this, config = $$.config, format = config.pie_label_format;
      if ($$.hasType('gauge')) {
          format = config.gauge_label_format;
      }
      else if ($$.hasType('donut')) {
          format = config.donut_label_format;
      }
      return format;
  };
  ChartInternal.prototype.getGaugeLabelExtents = function () {
      var $$ = this, config = $$.config;
      return config.gauge_label_extents;
  };
  ChartInternal.prototype.getArcTitle = function () {
      var $$ = this;
      return $$.hasType('donut') ? $$.config.donut_title : '';
  };
  ChartInternal.prototype.updateTargetsForArc = function (targets) {
      var $$ = this, main = $$.main, mainPies, mainPieEnter, classChartArc = $$.classChartArc.bind($$), classArcs = $$.classArcs.bind($$), classFocus = $$.classFocus.bind($$);
      mainPies = main
          .select('.' + CLASS.chartArcs)
          .selectAll('.' + CLASS.chartArc)
          .data($$.pie(targets))
          .attr('class', function (d) {
          return classChartArc(d) + classFocus(d.data);
      });
      mainPieEnter = mainPies
          .enter()
          .append('g')
          .attr('class', classChartArc);
      mainPieEnter.append('g').attr('class', classArcs);
      mainPieEnter
          .append('text')
          .attr('dy', $$.hasType('gauge') ? '-.1em' : '.35em')
          .style('opacity', 0)
          .style('text-anchor', 'middle')
          .style('pointer-events', 'none');
      // MEMO: can not keep same color..., but not bad to update color in redraw
      //mainPieUpdate.exit().remove();
  };
  ChartInternal.prototype.initArc = function () {
      var $$ = this;
      $$.arcs = $$.main
          .select('.' + CLASS.chart)
          .append('g')
          .attr('class', CLASS.chartArcs)
          .attr('transform', $$.getTranslate('arc'));
      $$.arcs
          .append('text')
          .attr('class', CLASS.chartArcsTitle)
          .style('text-anchor', 'middle')
          .text($$.getArcTitle());
  };
  ChartInternal.prototype.redrawArc = function (duration, durationForExit, withTransform) {
      var $$ = this, d3 = $$.d3, config = $$.config, main = $$.main, arcs, mainArc, arcLabelLines, mainArcLabelLine, hasGaugeType = $$.hasType('gauge');
      arcs = main
          .selectAll('.' + CLASS.arcs)
          .selectAll('.' + CLASS.arc)
          .data($$.arcData.bind($$));
      mainArc = arcs
          .enter()
          .append('path')
          .attr('class', $$.classArc.bind($$))
          .style('fill', function (d) {
          return $$.color(d.data);
      })
          .style('cursor', function (d) {
          return config.interaction_enabled && config.data_selection_isselectable(d)
              ? 'pointer'
              : null;
      })
          .each(function (d) {
          if ($$.isGaugeType(d.data)) {
              d.startAngle = d.endAngle = config.gauge_startingAngle;
          }
          this._current = d;
      })
          .merge(arcs);
      if (hasGaugeType) {
          arcLabelLines = main
              .selectAll('.' + CLASS.arcs)
              .selectAll('.' + CLASS.arcLabelLine)
              .data($$.arcData.bind($$));
          mainArcLabelLine = arcLabelLines
              .enter()
              .append('rect')
              .attr('class', function (d) {
              return (CLASS.arcLabelLine +
                  ' ' +
                  CLASS.target +
                  ' ' +
                  CLASS.target +
                  '-' +
                  d.data.id);
          })
              .merge(arcLabelLines);
          if ($$.filterTargetsToShow($$.data.targets).length === 1) {
              mainArcLabelLine.style('display', 'none');
          }
          else {
              mainArcLabelLine
                  .style('fill', function (d) {
                  return $$.levelColor
                      ? $$.levelColor(d.data.values.reduce(function (total, item) {
                          return total + item.value;
                      }, 0))
                      : $$.color(d.data);
              })
                  .style('display', config.gauge_labelLine_show ? '' : 'none')
                  .each(function (d) {
                  var lineLength = 0, lineThickness = 2, x = 0, y = 0, transform = '';
                  if ($$.hiddenTargetIds.indexOf(d.data.id) < 0) {
                      var updated = $$.updateAngle(d), innerLineLength = ($$.gaugeArcWidth /
                          $$.filterTargetsToShow($$.data.targets).length) *
                          (updated.index + 1), lineAngle = updated.endAngle - Math.PI / 2, arcInnerRadius = $$.radius - innerLineLength, linePositioningAngle = lineAngle - (arcInnerRadius === 0 ? 0 : 1 / arcInnerRadius);
                      lineLength = $$.radiusExpanded - $$.radius + innerLineLength;
                      x = Math.cos(linePositioningAngle) * arcInnerRadius;
                      y = Math.sin(linePositioningAngle) * arcInnerRadius;
                      transform =
                          'rotate(' +
                              (lineAngle * 180) / Math.PI +
                              ', ' +
                              x +
                              ', ' +
                              y +
                              ')';
                  }
                  d3.select(this)
                      .attr('x', x)
                      .attr('y', y)
                      .attr('width', lineLength)
                      .attr('height', lineThickness)
                      .attr('transform', transform)
                      .style('stroke-dasharray', '0, ' + (lineLength + lineThickness) + ', 0');
              });
          }
      }
      mainArc
          .attr('transform', function (d) {
          return !$$.isGaugeType(d.data) && withTransform ? 'scale(0)' : '';
      })
          .on('mouseover', config.interaction_enabled
          ? function (d) {
              var updated, arcData;
              if ($$.transiting) {
                  // skip while transiting
                  return;
              }
              updated = $$.updateAngle(d);
              if (updated) {
                  arcData = $$.convertToArcData(updated);
                  // transitions
                  $$.expandArc(updated.data.id);
                  $$.api.focus(updated.data.id);
                  $$.toggleFocusLegend(updated.data.id, true);
                  $$.config.data_onmouseover(arcData, this);
              }
          }
          : null)
          .on('mousemove', config.interaction_enabled
          ? function (d) {
              var updated = $$.updateAngle(d), arcData, selectedData;
              if (updated) {
                  (arcData = $$.convertToArcData(updated)),
                      (selectedData = [arcData]);
                  $$.showTooltip(selectedData, this);
              }
          }
          : null)
          .on('mouseout', config.interaction_enabled
          ? function (d) {
              var updated, arcData;
              if ($$.transiting) {
                  // skip while transiting
                  return;
              }
              updated = $$.updateAngle(d);
              if (updated) {
                  arcData = $$.convertToArcData(updated);
                  // transitions
                  $$.unexpandArc(updated.data.id);
                  $$.api.revert();
                  $$.revertLegend();
                  $$.hideTooltip();
                  $$.config.data_onmouseout(arcData, this);
              }
          }
          : null)
          .on('click', config.interaction_enabled
          ? function (d, i) {
              var updated = $$.updateAngle(d), arcData;
              if (updated) {
                  arcData = $$.convertToArcData(updated);
                  if ($$.toggleShape) {
                      $$.toggleShape(this, arcData, i);
                  }
                  $$.config.data_onclick.call($$.api, arcData, this);
              }
          }
          : null)
          .each(function () {
          $$.transiting = true;
      })
          .transition()
          .duration(duration)
          .attrTween('d', function (d) {
          var updated = $$.updateAngle(d), interpolate;
          if (!updated) {
              return function () {
                  return 'M 0 0';
              };
          }
          //                if (this._current === d) {
          //                    this._current = {
          //                        startAngle: Math.PI*2,
          //                        endAngle: Math.PI*2,
          //                    };
          //                }
          if (isNaN(this._current.startAngle)) {
              this._current.startAngle = 0;
          }
          if (isNaN(this._current.endAngle)) {
              this._current.endAngle = this._current.startAngle;
          }
          interpolate = d3.interpolate(this._current, updated);
          this._current = interpolate(0);
          return function (t) {
              // prevents crashing the charts once in transition and chart.destroy() has been called
              if ($$.config === null) {
                  return 'M 0 0';
              }
              var interpolated = interpolate(t);
              interpolated.data = d.data; // data.id will be updated by interporator
              return $$.getArc(interpolated, true);
          };
      })
          .attr('transform', withTransform ? 'scale(1)' : '')
          .style('fill', function (d) {
          return $$.levelColor
              ? $$.levelColor(d.data.values.reduce(function (total, item) {
                  return total + item.value;
              }, 0))
              : $$.color(d.data.id);
      }) // Where gauge reading color would receive customization.
          .call($$.endall, function () {
          $$.transiting = false;
      });
      arcs
          .exit()
          .transition()
          .duration(durationForExit)
          .style('opacity', 0)
          .remove();
      main
          .selectAll('.' + CLASS.chartArc)
          .select('text')
          .style('opacity', 0)
          .attr('class', function (d) {
          return $$.isGaugeType(d.data) ? CLASS.gaugeValue : '';
      })
          .text($$.textForArcLabel.bind($$))
          .attr('transform', $$.transformForArcLabel.bind($$))
          .style('font-size', function (d) {
          return $$.isGaugeType(d.data) &&
              $$.filterTargetsToShow($$.data.targets).length === 1
              ? Math.round($$.radius / 5) + 'px'
              : '';
      })
          .transition()
          .duration(duration)
          .style('opacity', function (d) {
          return $$.isTargetToShow(d.data.id) && $$.isArcType(d.data) ? 1 : 0;
      });
      main
          .select('.' + CLASS.chartArcsTitle)
          .style('opacity', $$.hasType('donut') || hasGaugeType ? 1 : 0);
      if (hasGaugeType) {
          var index_1 = 0;
          var backgroundArc = $$.arcs
              .select('g.' + CLASS.chartArcsBackground)
              .selectAll('path.' + CLASS.chartArcsBackground)
              .data($$.data.targets);
          backgroundArc
              .enter()
              .append('path')
              .attr('class', function (d, i) {
              return CLASS.chartArcsBackground + ' ' + CLASS.chartArcsBackground + '-' + i;
          })
              .merge(backgroundArc)
              .attr('d', function (d1) {
              if ($$.hiddenTargetIds.indexOf(d1.id) >= 0) {
                  return 'M 0 0';
              }
              var d = {
                  data: [{ value: config.gauge_max }],
                  startAngle: config.gauge_startingAngle,
                  endAngle: -1 *
                      config.gauge_startingAngle *
                      (config.gauge_fullCircle ? Math.PI : 1),
                  index: index_1++
              };
              return $$.getArc(d, true, true);
          });
          backgroundArc.exit().remove();
          $$.arcs
              .select('.' + CLASS.chartArcsGaugeUnit)
              .attr('dy', '.75em')
              .text(config.gauge_label_show ? config.gauge_units : '');
          $$.arcs
              .select('.' + CLASS.chartArcsGaugeMin)
              .attr('dx', -1 *
              ($$.innerRadius +
                  ($$.radius - $$.innerRadius) / (config.gauge_fullCircle ? 1 : 2)) +
              'px')
              .attr('dy', '1.2em')
              .text(config.gauge_label_show
              ? $$.textForGaugeMinMax(config.gauge_min, false)
              : '');
          $$.arcs
              .select('.' + CLASS.chartArcsGaugeMax)
              .attr('dx', $$.innerRadius +
              ($$.radius - $$.innerRadius) / (config.gauge_fullCircle ? 1 : 2) +
              'px')
              .attr('dy', '1.2em')
              .text(config.gauge_label_show
              ? $$.textForGaugeMinMax(config.gauge_max, true)
              : '');
      }
  };
  ChartInternal.prototype.initGauge = function () {
      var arcs = this.arcs;
      if (this.hasType('gauge')) {
          arcs.append('g').attr('class', CLASS.chartArcsBackground);
          arcs
              .append('text')
              .attr('class', CLASS.chartArcsGaugeUnit)
              .style('text-anchor', 'middle')
              .style('pointer-events', 'none');
          arcs
              .append('text')
              .attr('class', CLASS.chartArcsGaugeMin)
              .style('text-anchor', 'middle')
              .style('pointer-events', 'none');
          arcs
              .append('text')
              .attr('class', CLASS.chartArcsGaugeMax)
              .style('text-anchor', 'middle')
              .style('pointer-events', 'none');
      }
  };
  ChartInternal.prototype.getGaugeLabelHeight = function () {
      return this.config.gauge_label_show ? 20 : 0;
  };

  /**
   * Store value into cache
   *
   * @param key
   * @param value
   */
  ChartInternal.prototype.addToCache = function (key, value) {
      this.cache["$" + key] = value;
  };
  /**
   * Returns a cached value or undefined
   *
   * @param key
   * @return {*}
   */
  ChartInternal.prototype.getFromCache = function (key) {
      return this.cache["$" + key];
  };
  /**
   * Reset cached data
   */
  ChartInternal.prototype.resetCache = function () {
      var _this = this;
      Object.keys(this.cache)
          .filter(function (key) { return /^\$/.test(key); })
          .forEach(function (key) {
          delete _this.cache[key];
      });
  };
  // Old API that stores Targets
  ChartInternal.prototype.hasCaches = function (ids) {
      for (var i = 0; i < ids.length; i++) {
          if (!(ids[i] in this.cache)) {
              return false;
          }
      }
      return true;
  };
  ChartInternal.prototype.addCache = function (id, target) {
      this.cache[id] = this.cloneTarget(target);
  };
  ChartInternal.prototype.getCaches = function (ids) {
      var targets = [], i;
      for (i = 0; i < ids.length; i++) {
          if (ids[i] in this.cache) {
              targets.push(this.cloneTarget(this.cache[ids[i]]));
          }
      }
      return targets;
  };

  ChartInternal.prototype.categoryName = function (i) {
      var config = this.config;
      return i < config.axis_x_categories.length ? config.axis_x_categories[i] : i;
  };

  ChartInternal.prototype.generateTargetClass = function (targetId) {
      return targetId || targetId === 0 ? ('-' + targetId).replace(/\s/g, '-') : '';
  };
  ChartInternal.prototype.generateClass = function (prefix, targetId) {
      return ' ' + prefix + ' ' + prefix + this.generateTargetClass(targetId);
  };
  ChartInternal.prototype.classText = function (d) {
      return this.generateClass(CLASS.text, d.index);
  };
  ChartInternal.prototype.classTexts = function (d) {
      return this.generateClass(CLASS.texts, d.id);
  };
  ChartInternal.prototype.classShape = function (d) {
      return this.generateClass(CLASS.shape, d.index);
  };
  ChartInternal.prototype.classShapes = function (d) {
      return this.generateClass(CLASS.shapes, d.id);
  };
  ChartInternal.prototype.classLine = function (d) {
      return this.classShape(d) + this.generateClass(CLASS.line, d.id);
  };
  ChartInternal.prototype.classLines = function (d) {
      return this.classShapes(d) + this.generateClass(CLASS.lines, d.id);
  };
  ChartInternal.prototype.classCircle = function (d) {
      return this.classShape(d) + this.generateClass(CLASS.circle, d.index);
  };
  ChartInternal.prototype.classCircles = function (d) {
      return this.classShapes(d) + this.generateClass(CLASS.circles, d.id);
  };
  ChartInternal.prototype.classBar = function (d) {
      return this.classShape(d) + this.generateClass(CLASS.bar, d.index);
  };
  ChartInternal.prototype.classBars = function (d) {
      return this.classShapes(d) + this.generateClass(CLASS.bars, d.id);
  };
  ChartInternal.prototype.classArc = function (d) {
      return this.classShape(d.data) + this.generateClass(CLASS.arc, d.data.id);
  };
  ChartInternal.prototype.classArcs = function (d) {
      return this.classShapes(d.data) + this.generateClass(CLASS.arcs, d.data.id);
  };
  ChartInternal.prototype.classArea = function (d) {
      return this.classShape(d) + this.generateClass(CLASS.area, d.id);
  };
  ChartInternal.prototype.classAreas = function (d) {
      return this.classShapes(d) + this.generateClass(CLASS.areas, d.id);
  };
  ChartInternal.prototype.classRegion = function (d, i) {
      return (this.generateClass(CLASS.region, i) + ' ' + ('class' in d ? d['class'] : ''));
  };
  ChartInternal.prototype.classEvent = function (d) {
      return this.generateClass(CLASS.eventRect, d.index);
  };
  ChartInternal.prototype.classTarget = function (id) {
      var $$ = this;
      var additionalClassSuffix = $$.config.data_classes[id], additionalClass = '';
      if (additionalClassSuffix) {
          additionalClass = ' ' + CLASS.target + '-' + additionalClassSuffix;
      }
      return $$.generateClass(CLASS.target, id) + additionalClass;
  };
  ChartInternal.prototype.classFocus = function (d) {
      return this.classFocused(d) + this.classDefocused(d);
  };
  ChartInternal.prototype.classFocused = function (d) {
      return ' ' + (this.focusedTargetIds.indexOf(d.id) >= 0 ? CLASS.focused : '');
  };
  ChartInternal.prototype.classDefocused = function (d) {
      return (' ' + (this.defocusedTargetIds.indexOf(d.id) >= 0 ? CLASS.defocused : ''));
  };
  ChartInternal.prototype.classChartText = function (d) {
      return CLASS.chartText + this.classTarget(d.id);
  };
  ChartInternal.prototype.classChartLine = function (d) {
      return CLASS.chartLine + this.classTarget(d.id);
  };
  ChartInternal.prototype.classChartBar = function (d) {
      return CLASS.chartBar + this.classTarget(d.id);
  };
  ChartInternal.prototype.classChartArc = function (d) {
      return CLASS.chartArc + this.classTarget(d.data.id);
  };
  ChartInternal.prototype.getTargetSelectorSuffix = function (targetId) {
      var targetClass = this.generateTargetClass(targetId);
      if (window.CSS && window.CSS.escape) {
          return window.CSS.escape(targetClass);
      }
      // fallback on imperfect method for old browsers (does not handles unicode)
      return targetClass.replace(/([?!@#$%^&*()=+,.<>'":;\[\]\/|~`{}\\])/g, '\\$1');
  };
  ChartInternal.prototype.selectorTarget = function (id, prefix) {
      return (prefix || '') + '.' + CLASS.target + this.getTargetSelectorSuffix(id);
  };
  ChartInternal.prototype.selectorTargets = function (ids, prefix) {
      var $$ = this;
      ids = ids || [];
      return ids.length
          ? ids.map(function (id) {
              return $$.selectorTarget(id, prefix);
          })
          : null;
  };
  ChartInternal.prototype.selectorLegend = function (id) {
      return '.' + CLASS.legendItem + this.getTargetSelectorSuffix(id);
  };
  ChartInternal.prototype.selectorLegends = function (ids) {
      var $$ = this;
      return ids && ids.length
          ? ids.map(function (id) {
              return $$.selectorLegend(id);
          })
          : null;
  };

  ChartInternal.prototype.getClipPath = function (id) {
      return 'url(' + (isIE(9) ? '' : document.URL.split('#')[0]) + '#' + id + ')';
  };
  ChartInternal.prototype.appendClip = function (parent, id) {
      return parent
          .append('clipPath')
          .attr('id', id)
          .append('rect');
  };
  ChartInternal.prototype.getAxisClipX = function (forHorizontal) {
      // axis line width + padding for left
      var left = Math.max(30, this.margin.left);
      return forHorizontal ? -(1 + left) : -(left - 1);
  };
  ChartInternal.prototype.getAxisClipY = function (forHorizontal) {
      return forHorizontal ? -20 : -this.margin.top;
  };
  ChartInternal.prototype.getXAxisClipX = function () {
      var $$ = this;
      return $$.getAxisClipX(!$$.config.axis_rotated);
  };
  ChartInternal.prototype.getXAxisClipY = function () {
      var $$ = this;
      return $$.getAxisClipY(!$$.config.axis_rotated);
  };
  ChartInternal.prototype.getYAxisClipX = function () {
      var $$ = this;
      return $$.config.axis_y_inner ? -1 : $$.getAxisClipX($$.config.axis_rotated);
  };
  ChartInternal.prototype.getYAxisClipY = function () {
      var $$ = this;
      return $$.getAxisClipY($$.config.axis_rotated);
  };
  ChartInternal.prototype.getAxisClipWidth = function (forHorizontal) {
      var $$ = this, left = Math.max(30, $$.margin.left), right = Math.max(30, $$.margin.right);
      // width + axis line width + padding for left/right
      return forHorizontal ? $$.width + 2 + left + right : $$.margin.left + 20;
  };
  ChartInternal.prototype.getAxisClipHeight = function (forHorizontal) {
      // less than 20 is not enough to show the axis label 'outer' without legend
      return ((forHorizontal ? this.margin.bottom : this.margin.top + this.height) + 20);
  };
  ChartInternal.prototype.getXAxisClipWidth = function () {
      var $$ = this;
      return $$.getAxisClipWidth(!$$.config.axis_rotated);
  };
  ChartInternal.prototype.getXAxisClipHeight = function () {
      var $$ = this;
      return $$.getAxisClipHeight(!$$.config.axis_rotated);
  };
  ChartInternal.prototype.getYAxisClipWidth = function () {
      var $$ = this;
      return ($$.getAxisClipWidth($$.config.axis_rotated) +
          ($$.config.axis_y_inner ? 20 : 0));
  };
  ChartInternal.prototype.getYAxisClipHeight = function () {
      var $$ = this;
      return $$.getAxisClipHeight($$.config.axis_rotated);
  };

  ChartInternal.prototype.generateColor = function () {
      var $$ = this, config = $$.config, d3 = $$.d3, colors = config.data_colors, pattern = notEmpty(config.color_pattern)
          ? config.color_pattern
          : d3.schemeCategory10, callback = config.data_color, ids = [];
      return function (d) {
          var id = d.id || (d.data && d.data.id) || d, color;
          // if callback function is provided
          if (colors[id] instanceof Function) {
              color = colors[id](d);
          }
          // if specified, choose that color
          else if (colors[id]) {
              color = colors[id];
          }
          // if not specified, choose from pattern
          else {
              if (ids.indexOf(id) < 0) {
                  ids.push(id);
              }
              color = pattern[ids.indexOf(id) % pattern.length];
              colors[id] = color;
          }
          return callback instanceof Function ? callback(color, d) : color;
      };
  };
  ChartInternal.prototype.generateLevelColor = function () {
      var $$ = this, config = $$.config, colors = config.color_pattern, threshold = config.color_threshold, asValue = threshold.unit === 'value', values = threshold.values && threshold.values.length ? threshold.values : [], max = threshold.max || 100;
      return notEmpty(threshold) && notEmpty(colors)
          ? function (value) {
              var i, v, color = colors[colors.length - 1];
              for (i = 0; i < values.length; i++) {
                  v = asValue ? value : (value * 100) / max;
                  if (v < values[i]) {
                      color = colors[i];
                      break;
                  }
              }
              return color;
          }
          : null;
  };

  ChartInternal.prototype.getDefaultConfig = function () {
      var config = {
          bindto: '#chart',
          svg_classname: undefined,
          size_width: undefined,
          size_height: undefined,
          padding_left: undefined,
          padding_right: undefined,
          padding_top: undefined,
          padding_bottom: undefined,
          resize_auto: true,
          zoom_enabled: false,
          zoom_initialRange: undefined,
          zoom_type: 'scroll',
          zoom_disableDefaultBehavior: false,
          zoom_privileged: false,
          zoom_rescale: false,
          zoom_onzoom: function () { },
          zoom_onzoomstart: function () { },
          zoom_onzoomend: function () { },
          zoom_x_min: undefined,
          zoom_x_max: undefined,
          interaction_brighten: true,
          interaction_enabled: true,
          onmouseover: function () { },
          onmouseout: function () { },
          onresize: function () { },
          onresized: function () { },
          oninit: function () { },
          onrendered: function () { },
          transition_duration: 350,
          data_epochs: 'epochs',
          data_x: undefined,
          data_xs: {},
          data_xFormat: '%Y-%m-%d',
          data_xLocaltime: true,
          data_xSort: true,
          data_idConverter: function (id) {
              return id;
          },
          data_names: {},
          data_classes: {},
          data_groups: [],
          data_axes: {},
          data_type: undefined,
          data_types: {},
          data_labels: {},
          data_order: 'desc',
          data_regions: {},
          data_color: undefined,
          data_colors: {},
          data_hide: false,
          data_filter: undefined,
          data_selection_enabled: false,
          data_selection_grouped: false,
          data_selection_isselectable: function () {
              return true;
          },
          data_selection_multiple: true,
          data_selection_draggable: false,
          data_stack_normalize: false,
          data_onclick: function () { },
          data_onmouseover: function () { },
          data_onmouseout: function () { },
          data_onselected: function () { },
          data_onunselected: function () { },
          data_url: undefined,
          data_headers: undefined,
          data_json: undefined,
          data_rows: undefined,
          data_columns: undefined,
          data_mimeType: undefined,
          data_keys: undefined,
          // configuration for no plot-able data supplied.
          data_empty_label_text: '',
          // subchart
          subchart_show: false,
          subchart_size_height: 60,
          subchart_axis_x_show: true,
          subchart_onbrush: function () { },
          // color
          color_pattern: [],
          color_threshold: {},
          // legend
          legend_show: true,
          legend_hide: false,
          legend_position: 'bottom',
          legend_inset_anchor: 'top-left',
          legend_inset_x: 10,
          legend_inset_y: 0,
          legend_inset_step: undefined,
          legend_item_onclick: undefined,
          legend_item_onmouseover: undefined,
          legend_item_onmouseout: undefined,
          legend_equally: false,
          legend_padding: 0,
          legend_item_tile_width: 10,
          legend_item_tile_height: 10,
          // axis
          axis_rotated: false,
          axis_x_show: true,
          axis_x_type: 'indexed',
          axis_x_localtime: true,
          axis_x_categories: [],
          axis_x_tick_centered: false,
          axis_x_tick_format: undefined,
          axis_x_tick_culling: {},
          axis_x_tick_culling_max: 10,
          axis_x_tick_count: undefined,
          axis_x_tick_fit: true,
          axis_x_tick_values: null,
          axis_x_tick_rotate: 0,
          axis_x_tick_outer: true,
          axis_x_tick_multiline: true,
          axis_x_tick_multilineMax: 0,
          axis_x_tick_width: null,
          axis_x_max: undefined,
          axis_x_min: undefined,
          axis_x_padding: {},
          axis_x_height: undefined,
          axis_x_selection: undefined,
          axis_x_label: {},
          axis_x_inner: undefined,
          axis_y_show: true,
          axis_y_type: 'linear',
          axis_y_max: undefined,
          axis_y_min: undefined,
          axis_y_inverted: false,
          axis_y_center: undefined,
          axis_y_inner: undefined,
          axis_y_label: {},
          axis_y_tick_format: undefined,
          axis_y_tick_outer: true,
          axis_y_tick_values: null,
          axis_y_tick_rotate: 0,
          axis_y_tick_count: undefined,
          axis_y_tick_time_type: undefined,
          axis_y_tick_time_interval: undefined,
          axis_y_padding: {},
          axis_y_default: undefined,
          axis_y2_show: false,
          axis_y2_type: 'linear',
          axis_y2_max: undefined,
          axis_y2_min: undefined,
          axis_y2_inverted: false,
          axis_y2_center: undefined,
          axis_y2_inner: undefined,
          axis_y2_label: {},
          axis_y2_tick_format: undefined,
          axis_y2_tick_outer: true,
          axis_y2_tick_values: null,
          axis_y2_tick_count: undefined,
          axis_y2_padding: {},
          axis_y2_default: undefined,
          // grid
          grid_x_show: false,
          grid_x_type: 'tick',
          grid_x_lines: [],
          grid_y_show: false,
          // not used
          // grid_y_type: 'tick',
          grid_y_lines: [],
          grid_y_ticks: 10,
          grid_focus_show: true,
          grid_lines_front: true,
          // point - point of each data
          point_show: true,
          point_r: 2.5,
          point_sensitivity: 10,
          point_focus_expand_enabled: true,
          point_focus_expand_r: undefined,
          point_select_r: undefined,
          // line
          line_connectNull: false,
          line_step_type: 'step',
          // bar
          bar_width: undefined,
          bar_width_ratio: 0.6,
          bar_width_max: undefined,
          bar_zerobased: true,
          bar_space: 0,
          // area
          area_zerobased: true,
          area_above: false,
          // pie
          pie_label_show: true,
          pie_label_format: undefined,
          pie_label_threshold: 0.05,
          pie_label_ratio: undefined,
          pie_expand: {},
          pie_expand_duration: 50,
          pie_padAngle: 0,
          // gauge
          gauge_fullCircle: false,
          gauge_label_show: true,
          gauge_labelLine_show: true,
          gauge_label_format: undefined,
          gauge_min: 0,
          gauge_max: 100,
          gauge_startingAngle: (-1 * Math.PI) / 2,
          gauge_label_extents: undefined,
          gauge_units: undefined,
          gauge_width: undefined,
          gauge_arcs_minWidth: 5,
          gauge_expand: {},
          gauge_expand_duration: 50,
          // donut
          donut_label_show: true,
          donut_label_format: undefined,
          donut_label_threshold: 0.05,
          donut_label_ratio: undefined,
          donut_width: undefined,
          donut_title: '',
          donut_expand: {},
          donut_expand_duration: 50,
          donut_padAngle: 0,
          // spline
          spline_interpolation_type: 'cardinal',
          // stanford
          stanford_lines: [],
          stanford_regions: [],
          stanford_texts: [],
          stanford_scaleMin: undefined,
          stanford_scaleMax: undefined,
          stanford_scaleWidth: undefined,
          stanford_scaleFormat: undefined,
          stanford_scaleValues: undefined,
          stanford_colors: undefined,
          stanford_padding: {
              top: 0,
              right: 0,
              bottom: 0,
              left: 0
          },
          // region - region to change style
          regions: [],
          // tooltip - show when mouseover on each data
          tooltip_show: true,
          tooltip_grouped: true,
          tooltip_order: undefined,
          tooltip_format_title: undefined,
          tooltip_format_name: undefined,
          tooltip_format_value: undefined,
          tooltip_horizontal: undefined,
          tooltip_position: undefined,
          tooltip_contents: function (d, defaultTitleFormat, defaultValueFormat, color) {
              return this.getTooltipContent
                  ? this.getTooltipContent(d, defaultTitleFormat, defaultValueFormat, color)
                  : '';
          },
          tooltip_init_show: false,
          tooltip_init_x: 0,
          tooltip_init_position: { top: '0px', left: '50px' },
          tooltip_onshow: function () { },
          tooltip_onhide: function () { },
          // title
          title_text: undefined,
          title_padding: {
              top: 0,
              right: 0,
              bottom: 0,
              left: 0
          },
          title_position: 'top-center'
      };
      Object.keys(this.additionalConfig).forEach(function (key) {
          config[key] = this.additionalConfig[key];
      }, this);
      return config;
  };
  ChartInternal.prototype.additionalConfig = {};
  ChartInternal.prototype.loadConfig = function (config) {
      var this_config = this.config, target, keys, read;
      function find() {
          var key = keys.shift();
          //        console.log("key =>", key, ", target =>", target);
          if (key && target && typeof target === 'object' && key in target) {
              target = target[key];
              return find();
          }
          else if (!key) {
              return target;
          }
          else {
              return undefined;
          }
      }
      Object.keys(this_config).forEach(function (key) {
          target = config;
          keys = key.split('_');
          read = find();
          //        console.log("CONFIG : ", key, read);
          if (isDefined(read)) {
              this_config[key] = read;
          }
      });
  };

  ChartInternal.prototype.convertUrlToData = function (url, mimeType, headers, keys, done) {
      var $$ = this, type = mimeType ? mimeType : 'csv', f, converter;
      if (type === 'json') {
          f = $$.d3.json;
          converter = $$.convertJsonToData;
      }
      else if (type === 'tsv') {
          f = $$.d3.tsv;
          converter = $$.convertXsvToData;
      }
      else {
          f = $$.d3.csv;
          converter = $$.convertXsvToData;
      }
      f(url, headers)
          .then(function (data) {
          done.call($$, converter.call($$, data, keys));
      })
          .catch(function (error) {
          throw error;
      });
  };
  ChartInternal.prototype.convertXsvToData = function (xsv) {
      var keys = xsv.columns, rows = xsv;
      if (rows.length === 0) {
          return {
              keys: keys,
              rows: [keys.reduce(function (row, key) {
                      var _a;
                      return Object.assign(row, (_a = {}, _a[key] = null, _a));
                  }, {})]
          };
      }
      else {
          // [].concat() is to convert result into a plain array otherwise
          // test is not happy because rows have properties.
          return { keys: keys, rows: [].concat(xsv) };
      }
  };
  ChartInternal.prototype.convertJsonToData = function (json, keys) {
      var $$ = this, new_rows = [], targetKeys, data;
      if (keys) {
          // when keys specified, json would be an array that includes objects
          if (keys.x) {
              targetKeys = keys.value.concat(keys.x);
              $$.config.data_x = keys.x;
          }
          else {
              targetKeys = keys.value;
          }
          new_rows.push(targetKeys);
          json.forEach(function (o) {
              var new_row = [];
              targetKeys.forEach(function (key) {
                  // convert undefined to null because undefined data will be removed in convertDataToTargets()
                  var v = $$.findValueInJson(o, key);
                  if (isUndefined(v)) {
                      v = null;
                  }
                  new_row.push(v);
              });
              new_rows.push(new_row);
          });
          data = $$.convertRowsToData(new_rows);
      }
      else {
          Object.keys(json).forEach(function (key) {
              new_rows.push([key].concat(json[key]));
          });
          data = $$.convertColumnsToData(new_rows);
      }
      return data;
  };
  /**
   * Finds value from the given nested object by the given path.
   * If it's not found, then this returns undefined.
   * @param {Object} object the object
   * @param {string} path the path
   */
  ChartInternal.prototype.findValueInJson = function (object, path) {
      if (path in object) {
          // If object has a key that contains . or [], return the key's value
          // instead of searching for an inner object.
          // See https://github.com/c3js/c3/issues/1691 for details.
          return object[path];
      }
      path = path.replace(/\[(\w+)\]/g, '.$1'); // convert indexes to properties (replace [] with .)
      path = path.replace(/^\./, ''); // strip a leading dot
      var pathArray = path.split('.');
      for (var i = 0; i < pathArray.length; ++i) {
          var k = pathArray[i];
          if (k in object) {
              object = object[k];
          }
          else {
              return;
          }
      }
      return object;
  };
  /**
   * Converts the rows to normalized data.
   * @param {any[][]} rows The row data
   * @return {Object}
   */
  ChartInternal.prototype.convertRowsToData = function (rows) {
      var newRows = [];
      var keys = rows[0];
      for (var i = 1; i < rows.length; i++) {
          var newRow = {};
          for (var j = 0; j < rows[i].length; j++) {
              if (isUndefined(rows[i][j])) {
                  throw new Error('Source data is missing a component at (' + i + ',' + j + ')!');
              }
              newRow[keys[j]] = rows[i][j];
          }
          newRows.push(newRow);
      }
      return { keys: keys, rows: newRows };
  };
  /**
   * Converts the columns to normalized data.
   * @param {any[][]} columns The column data
   * @return {Object}
   */
  ChartInternal.prototype.convertColumnsToData = function (columns) {
      var newRows = [];
      var keys = [];
      for (var i = 0; i < columns.length; i++) {
          var key = columns[i][0];
          for (var j = 1; j < columns[i].length; j++) {
              if (isUndefined(newRows[j - 1])) {
                  newRows[j - 1] = {};
              }
              if (isUndefined(columns[i][j])) {
                  throw new Error('Source data is missing a component at (' + i + ',' + j + ')!');
              }
              newRows[j - 1][key] = columns[i][j];
          }
          keys.push(key);
      }
      return { keys: keys, rows: newRows };
  };
  /**
   * Converts the data format into the target format.
   * @param {!Object} data
   * @param {!Array} data.keys Ordered list of target IDs.
   * @param {!Array} data.rows Rows of data to convert.
   * @param {boolean} appendXs True to append to $$.data.xs, False to replace.
   * @return {!Array}
   */
  ChartInternal.prototype.convertDataToTargets = function (data, appendXs) {
      var $$ = this, config = $$.config, targets, ids, xs, keys, epochs;
      // handles format where keys are not orderly provided
      if (isArray(data)) {
          keys = Object.keys(data[0]);
      }
      else {
          keys = data.keys;
          data = data.rows;
      }
      xs = keys.filter($$.isX, $$);
      if (!$$.isStanfordGraphType()) {
          ids = keys.filter($$.isNotX, $$);
      }
      else {
          epochs = keys.filter($$.isEpochs, $$);
          ids = keys.filter($$.isNotXAndNotEpochs, $$);
          if (xs.length !== 1 || epochs.length !== 1 || ids.length !== 1) {
              throw new Error("You must define the 'x' key name and the 'epochs' for Stanford Diagrams");
          }
      }
      // save x for update data by load when custom x and c3.x API
      ids.forEach(function (id) {
          var xKey = $$.getXKey(id);
          if ($$.isCustomX() || $$.isTimeSeries()) {
              // if included in input data
              if (xs.indexOf(xKey) >= 0) {
                  $$.data.xs[id] = (appendXs && $$.data.xs[id]
                      ? $$.data.xs[id]
                      : []).concat(data
                      .map(function (d) {
                      return d[xKey];
                  })
                      .filter(isValue)
                      .map(function (rawX, i) {
                      return $$.generateTargetX(rawX, id, i);
                  }));
              }
              // if not included in input data, find from preloaded data of other id's x
              else if (config.data_x) {
                  $$.data.xs[id] = $$.getOtherTargetXs();
              }
              // if not included in input data, find from preloaded data
              else if (notEmpty(config.data_xs)) {
                  $$.data.xs[id] = $$.getXValuesOfXKey(xKey, $$.data.targets);
              }
              // MEMO: if no x included, use same x of current will be used
          }
          else {
              $$.data.xs[id] = data.map(function (d, i) {
                  return i;
              });
          }
      });
      // check x is defined
      ids.forEach(function (id) {
          if (!$$.data.xs[id]) {
              throw new Error('x is not defined for id = "' + id + '".');
          }
      });
      // convert to target
      targets = ids.map(function (id, index) {
          var convertedId = config.data_idConverter(id);
          return {
              id: convertedId,
              id_org: id,
              values: data
                  .map(function (d, i) {
                  var xKey = $$.getXKey(id), rawX = d[xKey], value = d[id] !== null && !isNaN(d[id]) ? +d[id] : null, x, returnData;
                  // use x as categories if custom x and categorized
                  if ($$.isCustomX() && $$.isCategorized() && !isUndefined(rawX)) {
                      if (index === 0 && i === 0) {
                          config.axis_x_categories = [];
                      }
                      x = config.axis_x_categories.indexOf(rawX);
                      if (x === -1) {
                          x = config.axis_x_categories.length;
                          config.axis_x_categories.push(rawX);
                      }
                  }
                  else {
                      x = $$.generateTargetX(rawX, id, i);
                  }
                  // mark as x = undefined if value is undefined and filter to remove after mapped
                  if (isUndefined(d[id]) || $$.data.xs[id].length <= i) {
                      x = undefined;
                  }
                  returnData = { x: x, value: value, id: convertedId };
                  if ($$.isStanfordGraphType()) {
                      returnData.epochs = d[epochs];
                  }
                  return returnData;
              })
                  .filter(function (v) {
                  return isDefined(v.x);
              })
          };
      });
      // finish targets
      targets.forEach(function (t) {
          var i;
          // sort values by its x
          if (config.data_xSort) {
              t.values = t.values.sort(function (v1, v2) {
                  var x1 = v1.x || v1.x === 0 ? v1.x : Infinity, x2 = v2.x || v2.x === 0 ? v2.x : Infinity;
                  return x1 - x2;
              });
          }
          // indexing each value
          i = 0;
          t.values.forEach(function (v) {
              v.index = i++;
          });
          // this needs to be sorted because its index and value.index is identical
          $$.data.xs[t.id].sort(function (v1, v2) {
              return v1 - v2;
          });
      });
      // cache information about values
      $$.hasNegativeValue = $$.hasNegativeValueInTargets(targets);
      $$.hasPositiveValue = $$.hasPositiveValueInTargets(targets);
      // set target types
      if (config.data_type) {
          $$.setTargetType($$.mapToIds(targets).filter(function (id) {
              return !(id in config.data_types);
          }), config.data_type);
      }
      // cache as original id keyed
      targets.forEach(function (d) {
          $$.addCache(d.id_org, d);
      });
      return targets;
  };

  ChartInternal.prototype.isEpochs = function (key) {
      var $$ = this, config = $$.config;
      return config.data_epochs && key === config.data_epochs;
  };
  ChartInternal.prototype.isX = function (key) {
      var $$ = this, config = $$.config;
      return ((config.data_x && key === config.data_x) ||
          (notEmpty(config.data_xs) && hasValue(config.data_xs, key)));
  };
  ChartInternal.prototype.isNotX = function (key) {
      return !this.isX(key);
  };
  ChartInternal.prototype.isNotXAndNotEpochs = function (key) {
      return !this.isX(key) && !this.isEpochs(key);
  };
  /**
   * Returns whether the normalized stack option is enabled or not.
   *
   * To be enabled it must also have data.groups defined.
   *
   * @return {boolean}
   */
  ChartInternal.prototype.isStackNormalized = function () {
      return this.config.data_stack_normalize && this.config.data_groups.length > 0;
  };
  /**
   * Returns whether the axis is normalized or not.
   *
   * An axis is normalized as long as one of its associated target
   * is normalized.
   *
   * @param axisId Axis ID (y or y2)
   * @return {Boolean}
   */
  ChartInternal.prototype.isAxisNormalized = function (axisId) {
      var $$ = this;
      if (!$$.isStackNormalized()) {
          // shortcut
          return false;
      }
      return $$.data.targets
          .filter(function (target) { return $$.axis.getId(target.id) === axisId; })
          .some(function (target) { return $$.isTargetNormalized(target.id); });
  };
  /**
   * Returns whether the values for this target ID is normalized or not.
   *
   * To be normalized the option needs to be enabled and target needs
   * to be defined in `data.groups`.
   *
   * @param targetId ID of the target
   * @return {Boolean} True if the target is normalized, false otherwise.
   */
  ChartInternal.prototype.isTargetNormalized = function (targetId) {
      var $$ = this;
      return ($$.isStackNormalized() &&
          $$.config.data_groups.some(function (group) { return group.includes(targetId); }));
  };
  ChartInternal.prototype.getXKey = function (id) {
      var $$ = this, config = $$.config;
      return config.data_x
          ? config.data_x
          : notEmpty(config.data_xs)
              ? config.data_xs[id]
              : null;
  };
  /**
   * Get sum of visible data per index for given axis.
   *
   * Expect axisId to be either 'y' or 'y2'.
   *
   * @private
   * @param axisId Compute sum for data associated to given axis.
   * @return {Array}
   */
  ChartInternal.prototype.getTotalPerIndex = function (axisId) {
      var $$ = this;
      if (!$$.isStackNormalized()) {
          return null;
      }
      var cached = $$.getFromCache('getTotalPerIndex');
      if (cached !== undefined) {
          return cached[axisId];
      }
      var sum = { y: [], y2: [] };
      $$.data.targets
          // keep only target that are normalized
          .filter(function (target) { return $$.isTargetNormalized(target.id); })
          // keep only target that are visible
          .filter(function (target) { return $$.isTargetToShow(target.id); })
          // compute sum per axis
          .forEach(function (target) {
          var sumByAxis = sum[$$.axis.getId(target.id)];
          target.values.forEach(function (v, i) {
              if (!sumByAxis[i]) {
                  sumByAxis[i] = 0;
              }
              sumByAxis[i] += isNumber(v.value) ? v.value : 0;
          });
      });
      $$.addToCache('getTotalPerIndex', sum);
      return sum[axisId];
  };
  /**
   * Get sum of visible data.
   *
   * Should be used for normalised data only since all values
   * are expected to be positive.
   *
   * @private
   * @return {Number}
   */
  ChartInternal.prototype.getTotalDataSum = function () {
      var $$ = this;
      var cached = $$.getFromCache('getTotalDataSum');
      if (cached !== undefined) {
          return cached;
      }
      var totalDataSum = flattenArray($$.data.targets
          .filter(function (target) { return $$.isTargetToShow(target.id); })
          .map(function (target) { return target.values; }))
          .map(function (d) { return d.value; })
          .reduce(function (p, c) { return p + c; }, 0);
      $$.addToCache('getTotalDataSum', totalDataSum);
      return totalDataSum;
  };
  ChartInternal.prototype.getXValuesOfXKey = function (key, targets) {
      var $$ = this, xValues, ids = targets && notEmpty(targets) ? $$.mapToIds(targets) : [];
      ids.forEach(function (id) {
          if ($$.getXKey(id) === key) {
              xValues = $$.data.xs[id];
          }
      });
      return xValues;
  };
  ChartInternal.prototype.getXValue = function (id, i) {
      var $$ = this;
      return id in $$.data.xs && $$.data.xs[id] && isValue($$.data.xs[id][i])
          ? $$.data.xs[id][i]
          : i;
  };
  ChartInternal.prototype.getOtherTargetXs = function () {
      var $$ = this, idsForX = Object.keys($$.data.xs);
      return idsForX.length ? $$.data.xs[idsForX[0]] : null;
  };
  ChartInternal.prototype.getOtherTargetX = function (index) {
      var xs = this.getOtherTargetXs();
      return xs && index < xs.length ? xs[index] : null;
  };
  ChartInternal.prototype.addXs = function (xs) {
      var $$ = this;
      Object.keys(xs).forEach(function (id) {
          $$.config.data_xs[id] = xs[id];
      });
  };
  ChartInternal.prototype.addName = function (data) {
      var $$ = this, name;
      if (data) {
          name = $$.config.data_names[data.id];
          data.name = name !== undefined ? name : data.id;
      }
      return data;
  };
  ChartInternal.prototype.getValueOnIndex = function (values, index) {
      var valueOnIndex = values.filter(function (v) {
          return v.index === index;
      });
      return valueOnIndex.length ? valueOnIndex[0] : null;
  };
  ChartInternal.prototype.updateTargetX = function (targets, x) {
      var $$ = this;
      targets.forEach(function (t) {
          t.values.forEach(function (v, i) {
              v.x = $$.generateTargetX(x[i], t.id, i);
          });
          $$.data.xs[t.id] = x;
      });
  };
  ChartInternal.prototype.updateTargetXs = function (targets, xs) {
      var $$ = this;
      targets.forEach(function (t) {
          if (xs[t.id]) {
              $$.updateTargetX([t], xs[t.id]);
          }
      });
  };
  ChartInternal.prototype.generateTargetX = function (rawX, id, index) {
      var $$ = this, x;
      if ($$.isTimeSeries()) {
          x = rawX ? $$.parseDate(rawX) : $$.parseDate($$.getXValue(id, index));
      }
      else if ($$.isCustomX() && !$$.isCategorized()) {
          x = isValue(rawX) ? +rawX : $$.getXValue(id, index);
      }
      else {
          x = index;
      }
      return x;
  };
  ChartInternal.prototype.cloneTarget = function (target) {
      return {
          id: target.id,
          id_org: target.id_org,
          values: target.values.map(function (d) {
              return {
                  x: d.x,
                  value: d.value,
                  id: d.id
              };
          })
      };
  };
  ChartInternal.prototype.getMaxDataCount = function () {
      var $$ = this;
      return $$.d3.max($$.data.targets, function (t) {
          return t.values.length;
      });
  };
  ChartInternal.prototype.mapToIds = function (targets) {
      return targets.map(function (d) {
          return d.id;
      });
  };
  ChartInternal.prototype.mapToTargetIds = function (ids) {
      var $$ = this;
      return ids ? [].concat(ids) : $$.mapToIds($$.data.targets);
  };
  ChartInternal.prototype.hasTarget = function (targets, id) {
      var ids = this.mapToIds(targets), i;
      for (i = 0; i < ids.length; i++) {
          if (ids[i] === id) {
              return true;
          }
      }
      return false;
  };
  ChartInternal.prototype.isTargetToShow = function (targetId) {
      return this.hiddenTargetIds.indexOf(targetId) < 0;
  };
  ChartInternal.prototype.isLegendToShow = function (targetId) {
      return this.hiddenLegendIds.indexOf(targetId) < 0;
  };
  /**
   * Returns only visible targets.
   *
   * This is the same as calling {@link filterTargetsToShow} on $$.data.targets.
   *
   * @return {Array}
   */
  ChartInternal.prototype.getTargetsToShow = function () {
      var $$ = this;
      return $$.filterTargetsToShow($$.data.targets);
  };
  ChartInternal.prototype.filterTargetsToShow = function (targets) {
      var $$ = this;
      return targets.filter(function (t) {
          return $$.isTargetToShow(t.id);
      });
  };
  /**
   * @return {Array} Returns all the targets attached to the chart, visible or not
   */
  ChartInternal.prototype.getTargets = function () {
      var $$ = this;
      return $$.data.targets;
  };
  ChartInternal.prototype.mapTargetsToUniqueXs = function (targets) {
      var $$ = this;
      var xs = $$.d3
          .set($$.d3.merge(targets.map(function (t) {
          return t.values.map(function (v) {
              return +v.x;
          });
      })))
          .values();
      xs = $$.isTimeSeries()
          ? xs.map(function (x) {
              return new Date(+x);
          })
          : xs.map(function (x) {
              return +x;
          });
      return xs.sort(function (a, b) {
          return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
      });
  };
  ChartInternal.prototype.addHiddenTargetIds = function (targetIds) {
      targetIds = targetIds instanceof Array ? targetIds : new Array(targetIds);
      for (var i = 0; i < targetIds.length; i++) {
          if (this.hiddenTargetIds.indexOf(targetIds[i]) < 0) {
              this.hiddenTargetIds = this.hiddenTargetIds.concat(targetIds[i]);
          }
      }
      this.resetCache();
  };
  ChartInternal.prototype.removeHiddenTargetIds = function (targetIds) {
      this.hiddenTargetIds = this.hiddenTargetIds.filter(function (id) {
          return targetIds.indexOf(id) < 0;
      });
      this.resetCache();
  };
  ChartInternal.prototype.addHiddenLegendIds = function (targetIds) {
      targetIds = targetIds instanceof Array ? targetIds : new Array(targetIds);
      for (var i = 0; i < targetIds.length; i++) {
          if (this.hiddenLegendIds.indexOf(targetIds[i]) < 0) {
              this.hiddenLegendIds = this.hiddenLegendIds.concat(targetIds[i]);
          }
      }
  };
  ChartInternal.prototype.removeHiddenLegendIds = function (targetIds) {
      this.hiddenLegendIds = this.hiddenLegendIds.filter(function (id) {
          return targetIds.indexOf(id) < 0;
      });
  };
  ChartInternal.prototype.getValuesAsIdKeyed = function (targets) {
      var ys = {};
      targets.forEach(function (t) {
          ys[t.id] = [];
          t.values.forEach(function (v) {
              ys[t.id].push(v.value);
          });
      });
      return ys;
  };
  ChartInternal.prototype.checkValueInTargets = function (targets, checker) {
      var ids = Object.keys(targets), i, j, values;
      for (i = 0; i < ids.length; i++) {
          values = targets[ids[i]].values;
          for (j = 0; j < values.length; j++) {
              if (checker(values[j].value)) {
                  return true;
              }
          }
      }
      return false;
  };
  ChartInternal.prototype.hasNegativeValueInTargets = function (targets) {
      return this.checkValueInTargets(targets, function (v) {
          return v < 0;
      });
  };
  ChartInternal.prototype.hasPositiveValueInTargets = function (targets) {
      return this.checkValueInTargets(targets, function (v) {
          return v > 0;
      });
  };
  ChartInternal.prototype.isOrderDesc = function () {
      var config = this.config;
      return (typeof config.data_order === 'string' &&
          config.data_order.toLowerCase() === 'desc');
  };
  ChartInternal.prototype.isOrderAsc = function () {
      var config = this.config;
      return (typeof config.data_order === 'string' &&
          config.data_order.toLowerCase() === 'asc');
  };
  ChartInternal.prototype.getOrderFunction = function () {
      var $$ = this, config = $$.config, orderAsc = $$.isOrderAsc(), orderDesc = $$.isOrderDesc();
      if (orderAsc || orderDesc) {
          var reducer = function (p, c) {
              return p + Math.abs(c.value);
          };
          return function (t1, t2) {
              var t1Sum = t1.values.reduce(reducer, 0), t2Sum = t2.values.reduce(reducer, 0);
              return orderAsc ? t2Sum - t1Sum : t1Sum - t2Sum;
          };
      }
      else if (isFunction(config.data_order)) {
          return config.data_order;
      }
      else if (isArray(config.data_order)) {
          var order = config.data_order;
          return function (t1, t2) {
              return order.indexOf(t1.id) - order.indexOf(t2.id);
          };
      }
  };
  ChartInternal.prototype.orderTargets = function (targets) {
      var fct = this.getOrderFunction();
      if (fct) {
          targets.sort(fct);
      }
      return targets;
  };
  /**
   * Returns all the values from the given targets at the given index.
   *
   * @param {Array} targets
   * @param {Number} index
   * @return {Array}
   */
  ChartInternal.prototype.filterByIndex = function (targets, index) {
      return this.d3.merge(targets.map(function (t) { return t.values.filter(function (v) { return v.index === index; }); }));
  };
  ChartInternal.prototype.filterByX = function (targets, x) {
      return this.d3
          .merge(targets.map(function (t) {
          return t.values;
      }))
          .filter(function (v) {
          return v.x - x === 0;
      });
  };
  ChartInternal.prototype.filterRemoveNull = function (data) {
      return data.filter(function (d) {
          return isValue(d.value);
      });
  };
  ChartInternal.prototype.filterByXDomain = function (targets, xDomain) {
      return targets.map(function (t) {
          return {
              id: t.id,
              id_org: t.id_org,
              values: t.values.filter(function (v) {
                  return xDomain[0] <= v.x && v.x <= xDomain[1];
              })
          };
      });
  };
  ChartInternal.prototype.hasDataLabel = function () {
      var config = this.config;
      if (typeof config.data_labels === 'boolean' && config.data_labels) {
          return true;
      }
      else if (typeof config.data_labels === 'object' &&
          notEmpty(config.data_labels)) {
          return true;
      }
      return false;
  };
  ChartInternal.prototype.getDataLabelLength = function (min, max, key) {
      var $$ = this, lengths = [0, 0], paddingCoef = 1.3;
      $$.selectChart
          .select('svg')
          .selectAll('.dummy')
          .data([min, max])
          .enter()
          .append('text')
          .text(function (d) {
          return $$.dataLabelFormat(d.id)(d);
      })
          .each(function (d, i) {
          lengths[i] = getBBox(this)[key] * paddingCoef;
      })
          .remove();
      return lengths;
  };
  /**
   * Returns true if the given data point is not arc type, otherwise false.
   * @param {Object} d The data point
   * @return {boolean}
   */
  ChartInternal.prototype.isNoneArc = function (d) {
      return this.hasTarget(this.data.targets, d.id);
  };
  /**
   * Returns true if the given data point is arc type, otherwise false.
   * @param {Object} d The data point
   * @return {boolean}
   */
  ChartInternal.prototype.isArc = function (d) {
      return 'data' in d && this.hasTarget(this.data.targets, d.data.id);
  };
  /**
   * Find the closest point from the given pos among the given targets or
   * undefined if none satisfies conditions.
   *
   * @param {Array} targets
   * @param {Array} pos An [x,y] coordinate
   * @return {Object|undefined}
   */
  ChartInternal.prototype.findClosestFromTargets = function (targets, pos) {
      var $$ = this;
      // for each target, find the closest point
      var candidates = targets
          .map(function (t) {
          return $$.findClosest(t.values, pos, $$.config.tooltip_horizontal
              ? $$.horizontalDistance.bind($$)
              : $$.dist.bind($$), $$.config.point_sensitivity);
      })
          .filter(function (v) { return v; });
      // returns the closest of candidates
      if (candidates.length === 0) {
          return undefined;
      }
      else if (candidates.length === 1) {
          return candidates[0];
      }
      else {
          return $$.findClosest(candidates, pos, $$.dist.bind($$));
      }
  };
  /**
   * Find the closest point from the x value or undefined if none satisfies conditions.
   *
   * @param {Array} targets
   * @param {Array} x A value on X axis
   * @return {Object|undefined}
   */
  ChartInternal.prototype.findClosestFromTargetsByX = function (targets, x) {
      var closest;
      var diff;
      targets.forEach(function (t) {
          t.values.forEach(function (d) {
              var newDiff = Math.abs(x - d.x);
              if (diff === undefined || newDiff < diff) {
                  closest = d;
                  diff = newDiff;
              }
          });
      });
      return closest;
  };
  /**
   * Using given compute distance method, returns the closest data point from the
   * given position.
   *
   * Giving optionally a minimum distance to satisfy.
   *
   * @param {Array} dataPoints List of DataPoints
   * @param {Array} pos An [x,y] coordinate
   * @param {Function} computeDist Function to compute distance between 2 points
   * @param {Number} minDist Minimal distance to satisfy
   * @return {Object|undefined} Closest data point
   */
  ChartInternal.prototype.findClosest = function (dataPoints, pos, computeDist, minDist) {
      if (minDist === void 0) { minDist = Infinity; }
      var $$ = this;
      var closest;
      // find closest bar
      dataPoints
          .filter(function (v) { return v && $$.isBarType(v.id); })
          .forEach(function (v) {
          if (!closest) {
              var shape = $$.main
                  .select('.' +
                  CLASS.bars +
                  $$.getTargetSelectorSuffix(v.id) +
                  ' .' +
                  CLASS.bar +
                  '-' +
                  v.index)
                  .node();
              if ($$.isWithinBar(pos, shape)) {
                  closest = v;
              }
          }
      });
      // find closest point from non-bar
      dataPoints
          .filter(function (v) { return v && !$$.isBarType(v.id); })
          .forEach(function (v) {
          var d = computeDist(v, pos);
          if (d < minDist) {
              minDist = d;
              closest = v;
          }
      });
      return closest;
  };
  ChartInternal.prototype.dist = function (data, pos) {
      var $$ = this, config = $$.config, xIndex = config.axis_rotated ? 1 : 0, yIndex = config.axis_rotated ? 0 : 1, y = $$.circleY(data, data.index), x = $$.x(data.x);
      return Math.sqrt(Math.pow(x - pos[xIndex], 2) + Math.pow(y - pos[yIndex], 2));
  };
  ChartInternal.prototype.horizontalDistance = function (data, pos) {
      var $$ = this, config = $$.config, xIndex = config.axis_rotated ? 1 : 0, x = $$.x(data.x);
      return Math.abs(x - pos[xIndex]);
  };
  ChartInternal.prototype.convertValuesToStep = function (values) {
      var converted = [].concat(values), i;
      if (!this.isCategorized()) {
          return values;
      }
      for (i = values.length + 1; 0 < i; i--) {
          converted[i] = converted[i - 1];
      }
      converted[0] = {
          x: converted[0].x - 1,
          value: converted[0].value,
          id: converted[0].id
      };
      converted[values.length + 1] = {
          x: converted[values.length].x + 1,
          value: converted[values.length].value,
          id: converted[values.length].id
      };
      return converted;
  };
  /**
   * Get ratio value
   *
   * @param {String} type Ratio for given type
   * @param {Object} d Data value object
   * @param {Boolean} asPercent Convert the return as percent or not
   * @return {Number} Ratio value
   * @private
   */
  ChartInternal.prototype.getRatio = function (type, d, asPercent) {
      if (asPercent === void 0) { asPercent = false; }
      var $$ = this;
      var api = $$.api;
      var ratio = 0;
      if (d && api.data.shown.call(api).length) {
          ratio = d.ratio || d.value;
          if (type === 'arc') {
              if ($$.hasType('gauge')) {
                  ratio =
                      (d.endAngle - d.startAngle) /
                          (Math.PI * ($$.config.gauge_fullCircle ? 2 : 1));
              }
              else {
                  var total = $$.getTotalDataSum();
                  ratio = d.value / total;
              }
          }
          else if (type === 'index') {
              var total = $$.getTotalPerIndex($$.axis.getId(d.id));
              d.ratio =
                  isNumber(d.value) && total && total[d.index] > 0
                      ? d.value / total[d.index]
                      : 0;
              ratio = d.ratio;
          }
      }
      return asPercent && ratio ? ratio * 100 : ratio;
  };
  ChartInternal.prototype.updateDataAttributes = function (name, attrs) {
      var $$ = this, config = $$.config, current = config['data_' + name];
      if (typeof attrs === 'undefined') {
          return current;
      }
      Object.keys(attrs).forEach(function (id) {
          current[id] = attrs[id];
      });
      $$.redraw({
          withLegend: true
      });
      return current;
  };

  ChartInternal.prototype.load = function (targets, args) {
      var $$ = this;
      if (targets) {
          // filter loading targets if needed
          if (args.filter) {
              targets = targets.filter(args.filter);
          }
          // set type if args.types || args.type specified
          if (args.type || args.types) {
              targets.forEach(function (t) {
                  var type = args.types && args.types[t.id] ? args.types[t.id] : args.type;
                  $$.setTargetType(t.id, type);
              });
          }
          // Update/Add data
          $$.data.targets.forEach(function (d) {
              for (var i = 0; i < targets.length; i++) {
                  if (d.id === targets[i].id) {
                      d.values = targets[i].values;
                      targets.splice(i, 1);
                      break;
                  }
              }
          });
          $$.data.targets = $$.data.targets.concat(targets); // add remained
      }
      // Set targets
      $$.updateTargets($$.data.targets);
      // Redraw with new targets
      $$.redraw({
          withUpdateOrgXDomain: true,
          withUpdateXDomain: true,
          withLegend: true
      });
      if (args.done) {
          args.done();
      }
  };
  ChartInternal.prototype.loadFromArgs = function (args) {
      var $$ = this;
      $$.resetCache();
      if (args.data) {
          $$.load($$.convertDataToTargets(args.data), args);
      }
      else if (args.url) {
          $$.convertUrlToData(args.url, args.mimeType, args.headers, args.keys, function (data) {
              $$.load($$.convertDataToTargets(data), args);
          });
      }
      else if (args.json) {
          $$.load($$.convertDataToTargets($$.convertJsonToData(args.json, args.keys)), args);
      }
      else if (args.rows) {
          $$.load($$.convertDataToTargets($$.convertRowsToData(args.rows)), args);
      }
      else if (args.columns) {
          $$.load($$.convertDataToTargets($$.convertColumnsToData(args.columns)), args);
      }
      else {
          $$.load(null, args);
      }
  };
  ChartInternal.prototype.unload = function (targetIds, done) {
      var $$ = this;
      $$.resetCache();
      if (!done) {
          done = function () { };
      }
      // filter existing target
      targetIds = targetIds.filter(function (id) {
          return $$.hasTarget($$.data.targets, id);
      });
      // If no target, call done and return
      if (!targetIds || targetIds.length === 0) {
          done();
          return;
      }
      $$.svg
          .selectAll(targetIds.map(function (id) {
          return $$.selectorTarget(id);
      }))
          .transition()
          .style('opacity', 0)
          .remove()
          .call($$.endall, done);
      targetIds.forEach(function (id) {
          // Reset fadein for future load
          $$.withoutFadeIn[id] = false;
          // Remove target's elements
          if ($$.legend) {
              $$.legend
                  .selectAll('.' + CLASS.legendItem + $$.getTargetSelectorSuffix(id))
                  .remove();
          }
          // Remove target
          $$.data.targets = $$.data.targets.filter(function (t) {
              return t.id !== id;
          });
      });
  };

  ChartInternal.prototype.getYDomainMin = function (targets) {
      var $$ = this, config = $$.config, ids = $$.mapToIds(targets), ys = $$.getValuesAsIdKeyed(targets), j, k, baseId, idsInGroup, id, hasNegativeValue;
      if (config.data_groups.length > 0) {
          hasNegativeValue = $$.hasNegativeValueInTargets(targets);
          for (j = 0; j < config.data_groups.length; j++) {
              // Determine baseId
              idsInGroup = config.data_groups[j].filter(function (id) {
                  return ids.indexOf(id) >= 0;
              });
              if (idsInGroup.length === 0) {
                  continue;
              }
              baseId = idsInGroup[0];
              // Consider negative values
              if (hasNegativeValue && ys[baseId]) {
                  ys[baseId].forEach(function (v, i) {
                      ys[baseId][i] = v < 0 ? v : 0;
                  });
              }
              // Compute min
              for (k = 1; k < idsInGroup.length; k++) {
                  id = idsInGroup[k];
                  if (!ys[id]) {
                      continue;
                  }
                  ys[id].forEach(function (v, i) {
                      if ($$.axis.getId(id) === $$.axis.getId(baseId) &&
                          ys[baseId] &&
                          !(hasNegativeValue && +v > 0)) {
                          ys[baseId][i] += +v;
                      }
                  });
              }
          }
      }
      return $$.d3.min(Object.keys(ys).map(function (key) {
          return $$.d3.min(ys[key]);
      }));
  };
  ChartInternal.prototype.getYDomainMax = function (targets) {
      var $$ = this, config = $$.config, ids = $$.mapToIds(targets), ys = $$.getValuesAsIdKeyed(targets), j, k, baseId, idsInGroup, id, hasPositiveValue;
      if (config.data_groups.length > 0) {
          hasPositiveValue = $$.hasPositiveValueInTargets(targets);
          for (j = 0; j < config.data_groups.length; j++) {
              // Determine baseId
              idsInGroup = config.data_groups[j].filter(function (id) {
                  return ids.indexOf(id) >= 0;
              });
              if (idsInGroup.length === 0) {
                  continue;
              }
              baseId = idsInGroup[0];
              // Consider positive values
              if (hasPositiveValue && ys[baseId]) {
                  ys[baseId].forEach(function (v, i) {
                      ys[baseId][i] = v > 0 ? v : 0;
                  });
              }
              // Compute max
              for (k = 1; k < idsInGroup.length; k++) {
                  id = idsInGroup[k];
                  if (!ys[id]) {
                      continue;
                  }
                  ys[id].forEach(function (v, i) {
                      if ($$.axis.getId(id) === $$.axis.getId(baseId) &&
                          ys[baseId] &&
                          !(hasPositiveValue && +v < 0)) {
                          ys[baseId][i] += +v;
                      }
                  });
              }
          }
      }
      return $$.d3.max(Object.keys(ys).map(function (key) {
          return $$.d3.max(ys[key]);
      }));
  };
  ChartInternal.prototype.getYDomain = function (targets, axisId, xDomain) {
      var $$ = this, config = $$.config;
      if ($$.isAxisNormalized(axisId)) {
          return [0, 100];
      }
      var targetsByAxisId = targets.filter(function (t) {
          return $$.axis.getId(t.id) === axisId;
      }), yTargets = xDomain
          ? $$.filterByXDomain(targetsByAxisId, xDomain)
          : targetsByAxisId, yMin = axisId === 'y2' ? config.axis_y2_min : config.axis_y_min, yMax = axisId === 'y2' ? config.axis_y2_max : config.axis_y_max, yDomainMin = $$.getYDomainMin(yTargets), yDomainMax = $$.getYDomainMax(yTargets), domain, domainLength, padding_top, padding_bottom, center = axisId === 'y2' ? config.axis_y2_center : config.axis_y_center, yDomainAbs, lengths, diff, ratio, isAllPositive, isAllNegative, isZeroBased = ($$.hasType('bar', yTargets) && config.bar_zerobased) ||
          ($$.hasType('area', yTargets) && config.area_zerobased), isInverted = axisId === 'y2' ? config.axis_y2_inverted : config.axis_y_inverted, showHorizontalDataLabel = $$.hasDataLabel() && config.axis_rotated, showVerticalDataLabel = $$.hasDataLabel() && !config.axis_rotated;
      // MEMO: avoid inverting domain unexpectedly
      yDomainMin = isValue(yMin)
          ? yMin
          : isValue(yMax)
              ? yDomainMin < yMax
                  ? yDomainMin
                  : yMax - 10
              : yDomainMin;
      yDomainMax = isValue(yMax)
          ? yMax
          : isValue(yMin)
              ? yMin < yDomainMax
                  ? yDomainMax
                  : yMin + 10
              : yDomainMax;
      if (yTargets.length === 0) {
          // use current domain if target of axisId is none
          return axisId === 'y2' ? $$.y2.domain() : $$.y.domain();
      }
      if (isNaN(yDomainMin)) {
          // set minimum to zero when not number
          yDomainMin = 0;
      }
      if (isNaN(yDomainMax)) {
          // set maximum to have same value as yDomainMin
          yDomainMax = yDomainMin;
      }
      if (yDomainMin === yDomainMax) {
          yDomainMin < 0 ? (yDomainMax = 0) : (yDomainMin = 0);
      }
      isAllPositive = yDomainMin >= 0 && yDomainMax >= 0;
      isAllNegative = yDomainMin <= 0 && yDomainMax <= 0;
      // Cancel zerobased if axis_*_min / axis_*_max specified
      if ((isValue(yMin) && isAllPositive) || (isValue(yMax) && isAllNegative)) {
          isZeroBased = false;
      }
      // Bar/Area chart should be 0-based if all positive|negative
      if (isZeroBased) {
          if (isAllPositive) {
              yDomainMin = 0;
          }
          if (isAllNegative) {
              yDomainMax = 0;
          }
      }
      domainLength = Math.abs(yDomainMax - yDomainMin);
      padding_top = padding_bottom = domainLength * 0.1;
      if (typeof center !== 'undefined') {
          yDomainAbs = Math.max(Math.abs(yDomainMin), Math.abs(yDomainMax));
          yDomainMax = center + yDomainAbs;
          yDomainMin = center - yDomainAbs;
      }
      // add padding for data label
      if (showHorizontalDataLabel) {
          lengths = $$.getDataLabelLength(yDomainMin, yDomainMax, 'width');
          diff = diffDomain($$.y.range());
          ratio = [lengths[0] / diff, lengths[1] / diff];
          padding_top += domainLength * (ratio[1] / (1 - ratio[0] - ratio[1]));
          padding_bottom += domainLength * (ratio[0] / (1 - ratio[0] - ratio[1]));
      }
      else if (showVerticalDataLabel) {
          lengths = $$.getDataLabelLength(yDomainMin, yDomainMax, 'height');
          var pixelsToAxisPadding = $$.getY(config["axis_" + axisId + "_type"], 
          // input domain as pixels
          [0, config.axis_rotated ? $$.width : $$.height], 
          // output range as axis padding
          [0, domainLength]);
          padding_top += pixelsToAxisPadding(lengths[1]);
          padding_bottom += pixelsToAxisPadding(lengths[0]);
      }
      if (axisId === 'y' && notEmpty(config.axis_y_padding)) {
          padding_top = $$.axis.getPadding(config.axis_y_padding, 'top', padding_top, domainLength);
          padding_bottom = $$.axis.getPadding(config.axis_y_padding, 'bottom', padding_bottom, domainLength);
      }
      if (axisId === 'y2' && notEmpty(config.axis_y2_padding)) {
          padding_top = $$.axis.getPadding(config.axis_y2_padding, 'top', padding_top, domainLength);
          padding_bottom = $$.axis.getPadding(config.axis_y2_padding, 'bottom', padding_bottom, domainLength);
      }
      // Bar/Area chart should be 0-based if all positive|negative
      if (isZeroBased) {
          if (isAllPositive) {
              padding_bottom = yDomainMin;
          }
          if (isAllNegative) {
              padding_top = -yDomainMax;
          }
      }
      domain = [yDomainMin - padding_bottom, yDomainMax + padding_top];
      return isInverted ? domain.reverse() : domain;
  };
  ChartInternal.prototype.getXDomainMin = function (targets) {
      var $$ = this, config = $$.config;
      return isDefined(config.axis_x_min)
          ? $$.isTimeSeries()
              ? this.parseDate(config.axis_x_min)
              : config.axis_x_min
          : $$.d3.min(targets, function (t) {
              return $$.d3.min(t.values, function (v) {
                  return v.x;
              });
          });
  };
  ChartInternal.prototype.getXDomainMax = function (targets) {
      var $$ = this, config = $$.config;
      return isDefined(config.axis_x_max)
          ? $$.isTimeSeries()
              ? this.parseDate(config.axis_x_max)
              : config.axis_x_max
          : $$.d3.max(targets, function (t) {
              return $$.d3.max(t.values, function (v) {
                  return v.x;
              });
          });
  };
  ChartInternal.prototype.getXDomainPadding = function (domain) {
      var $$ = this, config = $$.config, diff = domain[1] - domain[0], maxDataCount, padding, paddingLeft, paddingRight;
      if ($$.isCategorized()) {
          padding = 0;
      }
      else if ($$.hasType('bar')) {
          maxDataCount = $$.getMaxDataCount();
          padding = maxDataCount > 1 ? diff / (maxDataCount - 1) / 2 : 0.5;
      }
      else {
          padding = diff * 0.01;
      }
      if (typeof config.axis_x_padding === 'object' &&
          notEmpty(config.axis_x_padding)) {
          paddingLeft = isValue(config.axis_x_padding.left)
              ? config.axis_x_padding.left
              : padding;
          paddingRight = isValue(config.axis_x_padding.right)
              ? config.axis_x_padding.right
              : padding;
      }
      else if (typeof config.axis_x_padding === 'number') {
          paddingLeft = paddingRight = config.axis_x_padding;
      }
      else {
          paddingLeft = paddingRight = padding;
      }
      return { left: paddingLeft, right: paddingRight };
  };
  ChartInternal.prototype.getXDomain = function (targets) {
      var $$ = this, xDomain = [$$.getXDomainMin(targets), $$.getXDomainMax(targets)], firstX = xDomain[0], lastX = xDomain[1], padding = $$.getXDomainPadding(xDomain), min = 0, max = 0;
      // show center of x domain if min and max are the same
      if (firstX - lastX === 0 && !$$.isCategorized()) {
          if ($$.isTimeSeries()) {
              firstX = new Date(firstX.getTime() * 0.5);
              lastX = new Date(lastX.getTime() * 1.5);
          }
          else {
              firstX = firstX === 0 ? 1 : firstX * 0.5;
              lastX = lastX === 0 ? -1 : lastX * 1.5;
          }
      }
      if (firstX || firstX === 0) {
          min = $$.isTimeSeries()
              ? new Date(firstX.getTime() - padding.left)
              : firstX - padding.left;
      }
      if (lastX || lastX === 0) {
          max = $$.isTimeSeries()
              ? new Date(lastX.getTime() + padding.right)
              : lastX + padding.right;
      }
      return [min, max];
  };
  ChartInternal.prototype.updateXDomain = function (targets, withUpdateXDomain, withUpdateOrgXDomain, withTrim, domain) {
      var $$ = this, config = $$.config;
      if (withUpdateOrgXDomain) {
          $$.x.domain(domain ? domain : $$.d3.extent($$.getXDomain(targets)));
          $$.orgXDomain = $$.x.domain();
          if (config.zoom_enabled) {
              $$.zoom.update();
          }
          $$.subX.domain($$.x.domain());
          if ($$.brush) {
              $$.brush.updateScale($$.subX);
          }
      }
      if (withUpdateXDomain) {
          $$.x.domain(domain
              ? domain
              : !$$.brush || $$.brush.empty()
                  ? $$.orgXDomain
                  : $$.brush.selectionAsValue());
      }
      // Trim domain when too big by zoom mousemove event
      if (withTrim) {
          $$.x.domain($$.trimXDomain($$.x.orgDomain()));
      }
      return $$.x.domain();
  };
  ChartInternal.prototype.trimXDomain = function (domain) {
      var zoomDomain = this.getZoomDomain(), min = zoomDomain[0], max = zoomDomain[1];
      if (domain[0] <= min) {
          domain[1] = +domain[1] + (min - domain[0]);
          domain[0] = min;
      }
      if (max <= domain[1]) {
          domain[0] = +domain[0] - (domain[1] - max);
          domain[1] = max;
      }
      return domain;
  };

  ChartInternal.prototype.drag = function (mouse) {
      var $$ = this, config = $$.config, main = $$.main, d3 = $$.d3;
      var sx, sy, mx, my, minX, maxX, minY, maxY;
      if ($$.hasArcType()) {
          return;
      }
      if (!config.data_selection_enabled) {
          return;
      } // do nothing if not selectable
      if (!config.data_selection_multiple) {
          return;
      } // skip when single selection because drag is used for multiple selection
      sx = $$.dragStart[0];
      sy = $$.dragStart[1];
      mx = mouse[0];
      my = mouse[1];
      minX = Math.min(sx, mx);
      maxX = Math.max(sx, mx);
      minY = config.data_selection_grouped ? $$.margin.top : Math.min(sy, my);
      maxY = config.data_selection_grouped ? $$.height : Math.max(sy, my);
      main
          .select('.' + CLASS.dragarea)
          .attr('x', minX)
          .attr('y', minY)
          .attr('width', maxX - minX)
          .attr('height', maxY - minY);
      // TODO: binary search when multiple xs
      main
          .selectAll('.' + CLASS.shapes)
          .selectAll('.' + CLASS.shape)
          .each(function (d, i) {
          if (!config.data_selection_isselectable(d)) {
              return;
          }
          var shape = d3.select(this), isSelected = shape.classed(CLASS.SELECTED), isIncluded = shape.classed(CLASS.INCLUDED), _x, _y, _w, _h, toggle, isWithin = false, box;
          if (shape.classed(CLASS.circle)) {
              _x = shape.attr('cx') * 1;
              _y = shape.attr('cy') * 1;
              toggle = $$.togglePoint;
              isWithin = minX < _x && _x < maxX && minY < _y && _y < maxY;
          }
          else if (shape.classed(CLASS.bar)) {
              box = getPathBox(this);
              _x = box.x;
              _y = box.y;
              _w = box.width;
              _h = box.height;
              toggle = $$.togglePath;
              isWithin =
                  !(maxX < _x || _x + _w < minX) && !(maxY < _y || _y + _h < minY);
          }
          else {
              // line/area selection not supported yet
              return;
          }
          if (isWithin ^ isIncluded) {
              shape.classed(CLASS.INCLUDED, !isIncluded);
              // TODO: included/unincluded callback here
              shape.classed(CLASS.SELECTED, !isSelected);
              toggle.call($$, !isSelected, shape, d, i);
          }
      });
  };
  ChartInternal.prototype.dragstart = function (mouse) {
      var $$ = this, config = $$.config;
      if ($$.hasArcType()) {
          return;
      }
      if (!config.data_selection_enabled) {
          return;
      } // do nothing if not selectable
      $$.dragStart = mouse;
      $$.main
          .select('.' + CLASS.chart)
          .append('rect')
          .attr('class', CLASS.dragarea)
          .style('opacity', 0.1);
      $$.dragging = true;
  };
  ChartInternal.prototype.dragend = function () {
      var $$ = this, config = $$.config;
      if ($$.hasArcType()) {
          return;
      }
      if (!config.data_selection_enabled) {
          return;
      } // do nothing if not selectable
      $$.main
          .select('.' + CLASS.dragarea)
          .transition()
          .duration(100)
          .style('opacity', 0)
          .remove();
      $$.main.selectAll('.' + CLASS.shape).classed(CLASS.INCLUDED, false);
      $$.dragging = false;
  };

  ChartInternal.prototype.getYFormat = function (forArc) {
      var $$ = this, formatForY = forArc && !$$.hasType('gauge') ? $$.defaultArcValueFormat : $$.yFormat, formatForY2 = forArc && !$$.hasType('gauge') ? $$.defaultArcValueFormat : $$.y2Format;
      return function (v, ratio, id) {
          var format = $$.axis.getId(id) === 'y2' ? formatForY2 : formatForY;
          return format.call($$, v, ratio);
      };
  };
  ChartInternal.prototype.yFormat = function (v) {
      var $$ = this, config = $$.config, format = config.axis_y_tick_format
          ? config.axis_y_tick_format
          : $$.defaultValueFormat;
      return format(v);
  };
  ChartInternal.prototype.y2Format = function (v) {
      var $$ = this, config = $$.config, format = config.axis_y2_tick_format
          ? config.axis_y2_tick_format
          : $$.defaultValueFormat;
      return format(v);
  };
  ChartInternal.prototype.defaultValueFormat = function (v) {
      return isValue(v) ? +v : '';
  };
  ChartInternal.prototype.defaultArcValueFormat = function (v, ratio) {
      return (ratio * 100).toFixed(1) + '%';
  };
  ChartInternal.prototype.dataLabelFormat = function (targetId) {
      var $$ = this, data_labels = $$.config.data_labels, format, defaultFormat = function (v) {
          return isValue(v) ? +v : '';
      };
      // find format according to axis id
      if (typeof data_labels.format === 'function') {
          format = data_labels.format;
      }
      else if (typeof data_labels.format === 'object') {
          if (data_labels.format[targetId]) {
              format =
                  data_labels.format[targetId] === true
                      ? defaultFormat
                      : data_labels.format[targetId];
          }
          else {
              format = function () {
                  return '';
              };
          }
      }
      else {
          format = defaultFormat;
      }
      return format;
  };

  ChartInternal.prototype.initGrid = function () {
      var $$ = this, config = $$.config, d3 = $$.d3;
      $$.grid = $$.main
          .append('g')
          .attr('clip-path', $$.clipPathForGrid)
          .attr('class', CLASS.grid);
      if (config.grid_x_show) {
          $$.grid.append('g').attr('class', CLASS.xgrids);
      }
      if (config.grid_y_show) {
          $$.grid.append('g').attr('class', CLASS.ygrids);
      }
      if (config.grid_focus_show) {
          $$.grid
              .append('g')
              .attr('class', CLASS.xgridFocus)
              .append('line')
              .attr('class', CLASS.xgridFocus);
      }
      $$.xgrid = d3.selectAll([]);
      if (!config.grid_lines_front) {
          $$.initGridLines();
      }
  };
  ChartInternal.prototype.initGridLines = function () {
      var $$ = this, d3 = $$.d3;
      $$.gridLines = $$.main
          .append('g')
          .attr('clip-path', $$.clipPathForGrid)
          .attr('class', CLASS.grid + ' ' + CLASS.gridLines);
      $$.gridLines.append('g').attr('class', CLASS.xgridLines);
      $$.gridLines.append('g').attr('class', CLASS.ygridLines);
      $$.xgridLines = d3.selectAll([]);
  };
  ChartInternal.prototype.updateXGrid = function (withoutUpdate) {
      var $$ = this, config = $$.config, d3 = $$.d3, xgridData = $$.generateGridData(config.grid_x_type, $$.x), tickOffset = $$.isCategorized() ? $$.xAxis.tickOffset() : 0;
      $$.xgridAttr = config.axis_rotated
          ? {
              x1: 0,
              x2: $$.width,
              y1: function (d) {
                  return $$.x(d) - tickOffset;
              },
              y2: function (d) {
                  return $$.x(d) - tickOffset;
              }
          }
          : {
              x1: function (d) {
                  return $$.x(d) + tickOffset;
              },
              x2: function (d) {
                  return $$.x(d) + tickOffset;
              },
              y1: 0,
              y2: $$.height
          };
      $$.xgridAttr.opacity = function () {
          var pos = +d3.select(this).attr(config.axis_rotated ? 'y1' : 'x1');
          return pos === (config.axis_rotated ? $$.height : 0) ? 0 : 1;
      };
      var xgrid = $$.main
          .select('.' + CLASS.xgrids)
          .selectAll('.' + CLASS.xgrid)
          .data(xgridData);
      var xgridEnter = xgrid
          .enter()
          .append('line')
          .attr('class', CLASS.xgrid)
          .attr('x1', $$.xgridAttr.x1)
          .attr('x2', $$.xgridAttr.x2)
          .attr('y1', $$.xgridAttr.y1)
          .attr('y2', $$.xgridAttr.y2)
          .style('opacity', 0);
      $$.xgrid = xgridEnter.merge(xgrid);
      if (!withoutUpdate) {
          $$.xgrid
              .attr('x1', $$.xgridAttr.x1)
              .attr('x2', $$.xgridAttr.x2)
              .attr('y1', $$.xgridAttr.y1)
              .attr('y2', $$.xgridAttr.y2)
              .style('opacity', $$.xgridAttr.opacity);
      }
      xgrid.exit().remove();
  };
  ChartInternal.prototype.updateYGrid = function () {
      var $$ = this, config = $$.config, gridValues = $$.yAxis.tickValues() || $$.y.ticks(config.grid_y_ticks);
      var ygrid = $$.main
          .select('.' + CLASS.ygrids)
          .selectAll('.' + CLASS.ygrid)
          .data(gridValues);
      var ygridEnter = ygrid
          .enter()
          .append('line')
          // TODO: x1, x2, y1, y2, opacity need to be set here maybe
          .attr('class', CLASS.ygrid);
      $$.ygrid = ygridEnter.merge(ygrid);
      $$.ygrid
          .attr('x1', config.axis_rotated ? $$.y : 0)
          .attr('x2', config.axis_rotated ? $$.y : $$.width)
          .attr('y1', config.axis_rotated ? 0 : $$.y)
          .attr('y2', config.axis_rotated ? $$.height : $$.y);
      ygrid.exit().remove();
      $$.smoothLines($$.ygrid, 'grid');
  };
  ChartInternal.prototype.gridTextAnchor = function (d) {
      return d.position ? d.position : 'end';
  };
  ChartInternal.prototype.gridTextDx = function (d) {
      return d.position === 'start' ? 4 : d.position === 'middle' ? 0 : -4;
  };
  ChartInternal.prototype.xGridTextX = function (d) {
      return d.position === 'start'
          ? -this.height
          : d.position === 'middle'
              ? -this.height / 2
              : 0;
  };
  ChartInternal.prototype.yGridTextX = function (d) {
      return d.position === 'start'
          ? 0
          : d.position === 'middle'
              ? this.width / 2
              : this.width;
  };
  ChartInternal.prototype.updateGrid = function (duration) {
      var $$ = this, main = $$.main, config = $$.config, xgridLine, xgridLineEnter, ygridLine, ygridLineEnter, xv = $$.xv.bind($$), yv = $$.yv.bind($$), xGridTextX = $$.xGridTextX.bind($$), yGridTextX = $$.yGridTextX.bind($$);
      // hide if arc type
      $$.grid.style('visibility', $$.hasArcType() ? 'hidden' : 'visible');
      main.select('line.' + CLASS.xgridFocus).style('visibility', 'hidden');
      if (config.grid_x_show) {
          $$.updateXGrid();
      }
      xgridLine = main
          .select('.' + CLASS.xgridLines)
          .selectAll('.' + CLASS.xgridLine)
          .data(config.grid_x_lines);
      // enter
      xgridLineEnter = xgridLine
          .enter()
          .append('g')
          .attr('class', function (d) {
          return CLASS.xgridLine + (d['class'] ? ' ' + d['class'] : '');
      });
      xgridLineEnter
          .append('line')
          .attr('x1', config.axis_rotated ? 0 : xv)
          .attr('x2', config.axis_rotated ? $$.width : xv)
          .attr('y1', config.axis_rotated ? xv : 0)
          .attr('y2', config.axis_rotated ? xv : $$.height)
          .style('opacity', 0);
      xgridLineEnter
          .append('text')
          .attr('text-anchor', $$.gridTextAnchor)
          .attr('transform', config.axis_rotated ? '' : 'rotate(-90)')
          .attr('x', config.axis_rotated ? yGridTextX : xGridTextX)
          .attr('y', xv)
          .attr('dx', $$.gridTextDx)
          .attr('dy', -5)
          .style('opacity', 0);
      // udpate
      $$.xgridLines = xgridLineEnter.merge(xgridLine);
      // done in d3.transition() of the end of this function
      // exit
      xgridLine
          .exit()
          .transition()
          .duration(duration)
          .style('opacity', 0)
          .remove();
      // Y-Grid
      if (config.grid_y_show) {
          $$.updateYGrid();
      }
      ygridLine = main
          .select('.' + CLASS.ygridLines)
          .selectAll('.' + CLASS.ygridLine)
          .data(config.grid_y_lines);
      // enter
      ygridLineEnter = ygridLine
          .enter()
          .append('g')
          .attr('class', function (d) {
          return CLASS.ygridLine + (d['class'] ? ' ' + d['class'] : '');
      });
      ygridLineEnter
          .append('line')
          .attr('x1', config.axis_rotated ? yv : 0)
          .attr('x2', config.axis_rotated ? yv : $$.width)
          .attr('y1', config.axis_rotated ? 0 : yv)
          .attr('y2', config.axis_rotated ? $$.height : yv)
          .style('opacity', 0);
      ygridLineEnter
          .append('text')
          .attr('text-anchor', $$.gridTextAnchor)
          .attr('transform', config.axis_rotated ? 'rotate(-90)' : '')
          .attr('x', config.axis_rotated ? xGridTextX : yGridTextX)
          .attr('y', yv)
          .attr('dx', $$.gridTextDx)
          .attr('dy', -5)
          .style('opacity', 0);
      // update
      $$.ygridLines = ygridLineEnter.merge(ygridLine);
      $$.ygridLines
          .select('line')
          .transition()
          .duration(duration)
          .attr('x1', config.axis_rotated ? yv : 0)
          .attr('x2', config.axis_rotated ? yv : $$.width)
          .attr('y1', config.axis_rotated ? 0 : yv)
          .attr('y2', config.axis_rotated ? $$.height : yv)
          .style('opacity', 1);
      $$.ygridLines
          .select('text')
          .transition()
          .duration(duration)
          .attr('x', config.axis_rotated ? $$.xGridTextX.bind($$) : $$.yGridTextX.bind($$))
          .attr('y', yv)
          .text(function (d) {
          return d.text;
      })
          .style('opacity', 1);
      // exit
      ygridLine
          .exit()
          .transition()
          .duration(duration)
          .style('opacity', 0)
          .remove();
  };
  ChartInternal.prototype.redrawGrid = function (withTransition, transition) {
      var $$ = this, config = $$.config, xv = $$.xv.bind($$), lines = $$.xgridLines.select('line'), texts = $$.xgridLines.select('text');
      return [
          (withTransition ? lines.transition(transition) : lines)
              .attr('x1', config.axis_rotated ? 0 : xv)
              .attr('x2', config.axis_rotated ? $$.width : xv)
              .attr('y1', config.axis_rotated ? xv : 0)
              .attr('y2', config.axis_rotated ? xv : $$.height)
              .style('opacity', 1),
          (withTransition ? texts.transition(transition) : texts)
              .attr('x', config.axis_rotated ? $$.yGridTextX.bind($$) : $$.xGridTextX.bind($$))
              .attr('y', xv)
              .text(function (d) {
              return d.text;
          })
              .style('opacity', 1)
      ];
  };
  ChartInternal.prototype.showXGridFocus = function (selectedData) {
      var $$ = this, config = $$.config, dataToShow = selectedData.filter(function (d) {
          return d && isValue(d.value);
      }), focusEl = $$.main.selectAll('line.' + CLASS.xgridFocus), xx = $$.xx.bind($$);
      if (!config.tooltip_show) {
          return;
      }
      // Hide when stanford plot exists
      if ($$.hasType('stanford') || $$.hasArcType()) {
          return;
      }
      focusEl
          .style('visibility', 'visible')
          .data([dataToShow[0]])
          .attr(config.axis_rotated ? 'y1' : 'x1', xx)
          .attr(config.axis_rotated ? 'y2' : 'x2', xx);
      $$.smoothLines(focusEl, 'grid');
  };
  ChartInternal.prototype.hideXGridFocus = function () {
      this.main.select('line.' + CLASS.xgridFocus).style('visibility', 'hidden');
  };
  ChartInternal.prototype.updateXgridFocus = function () {
      var $$ = this, config = $$.config;
      $$.main
          .select('line.' + CLASS.xgridFocus)
          .attr('x1', config.axis_rotated ? 0 : -10)
          .attr('x2', config.axis_rotated ? $$.width : -10)
          .attr('y1', config.axis_rotated ? -10 : 0)
          .attr('y2', config.axis_rotated ? -10 : $$.height);
  };
  ChartInternal.prototype.generateGridData = function (type, scale) {
      var $$ = this, gridData = [], xDomain, firstYear, lastYear, i, tickNum = $$.main
          .select('.' + CLASS.axisX)
          .selectAll('.tick')
          .size();
      if (type === 'year') {
          xDomain = $$.getXDomain();
          firstYear = xDomain[0].getFullYear();
          lastYear = xDomain[1].getFullYear();
          for (i = firstYear; i <= lastYear; i++) {
              gridData.push(new Date(i + '-01-01 00:00:00'));
          }
      }
      else {
          gridData = scale.ticks(10);
          if (gridData.length > tickNum) {
              // use only int
              gridData = gridData.filter(function (d) {
                  return ('' + d).indexOf('.') < 0;
              });
          }
      }
      return gridData;
  };
  ChartInternal.prototype.getGridFilterToRemove = function (params) {
      return params
          ? function (line) {
              var found = false;
              [].concat(params).forEach(function (param) {
                  if (('value' in param && line.value === param.value) ||
                      ('class' in param && line['class'] === param['class'])) {
                      found = true;
                  }
              });
              return found;
          }
          : function () {
              return true;
          };
  };
  ChartInternal.prototype.removeGridLines = function (params, forX) {
      var $$ = this, config = $$.config, toRemove = $$.getGridFilterToRemove(params), toShow = function (line) {
          return !toRemove(line);
      }, classLines = forX ? CLASS.xgridLines : CLASS.ygridLines, classLine = forX ? CLASS.xgridLine : CLASS.ygridLine;
      $$.main
          .select('.' + classLines)
          .selectAll('.' + classLine)
          .filter(toRemove)
          .transition()
          .duration(config.transition_duration)
          .style('opacity', 0)
          .remove();
      if (forX) {
          config.grid_x_lines = config.grid_x_lines.filter(toShow);
      }
      else {
          config.grid_y_lines = config.grid_y_lines.filter(toShow);
      }
  };

  ChartInternal.prototype.initEventRect = function () {
      var $$ = this, config = $$.config;
      $$.main
          .select('.' + CLASS.chart)
          .append('g')
          .attr('class', CLASS.eventRects)
          .style('fill-opacity', 0);
      $$.eventRect = $$.main
          .select('.' + CLASS.eventRects)
          .append('rect')
          .attr('class', CLASS.eventRect);
      // event rect handle zoom event as well
      if (config.zoom_enabled && $$.zoom) {
          $$.eventRect.call($$.zoom).on('dblclick.zoom', null);
          if (config.zoom_initialRange) {
              // WORKAROUND: Add transition to apply transform immediately when no subchart
              $$.eventRect
                  .transition()
                  .duration(0)
                  .call($$.zoom.transform, $$.zoomTransform(config.zoom_initialRange));
          }
      }
  };
  ChartInternal.prototype.redrawEventRect = function () {
      var $$ = this, d3 = $$.d3, config = $$.config;
      function mouseout() {
          $$.svg.select('.' + CLASS.eventRect).style('cursor', null);
          $$.hideXGridFocus();
          $$.hideTooltip();
          $$.unexpandCircles();
          $$.unexpandBars();
      }
      var isHoveringDataPoint = function (mouse, closest) {
          return closest &&
              ($$.isBarType(closest.id) ||
                  $$.dist(closest, mouse) < config.point_sensitivity);
      };
      var withName = function (d) { return (d ? $$.addName(Object.assign({}, d)) : null); };
      // rects for mouseover
      $$.main
          .select('.' + CLASS.eventRects)
          .style('cursor', config.zoom_enabled
          ? config.axis_rotated
              ? 'ns-resize'
              : 'ew-resize'
          : null);
      $$.eventRect
          .attr('x', 0)
          .attr('y', 0)
          .attr('width', $$.width)
          .attr('height', $$.height)
          .on('mouseout', config.interaction_enabled
          ? function () {
              if (!config) {
                  return;
              } // chart is destroyed
              if ($$.hasArcType()) {
                  return;
              }
              if ($$.mouseover) {
                  config.data_onmouseout.call($$.api, $$.mouseover);
                  $$.mouseover = undefined;
              }
              mouseout();
          }
          : null)
          .on('mousemove', config.interaction_enabled
          ? function () {
              // do nothing when dragging
              if ($$.dragging) {
                  return;
              }
              var targetsToShow = $$.getTargetsToShow();
              // do nothing if arc type
              if ($$.hasArcType(targetsToShow)) {
                  return;
              }
              var mouse = d3.mouse(this);
              var closest = withName($$.findClosestFromTargets(targetsToShow, mouse));
              var isMouseCloseToDataPoint = isHoveringDataPoint(mouse, closest);
              // ensure onmouseout is always called if mousemove switch between 2 targets
              if ($$.mouseover &&
                  (!closest ||
                      closest.id !== $$.mouseover.id ||
                      closest.index !== $$.mouseover.index)) {
                  config.data_onmouseout.call($$.api, $$.mouseover);
                  $$.mouseover = undefined;
              }
              if (closest && !$$.mouseover) {
                  config.data_onmouseover.call($$.api, closest);
                  $$.mouseover = closest;
              }
              // show cursor as pointer if we're hovering a data point close enough
              $$.svg
                  .select('.' + CLASS.eventRect)
                  .style('cursor', isMouseCloseToDataPoint ? 'pointer' : null);
              // if tooltip not grouped, we want to display only data from closest data point
              var showSingleDataPoint = !config.tooltip_grouped || $$.hasType('stanford', targetsToShow);
              // find data to highlight
              var selectedData;
              if (showSingleDataPoint) {
                  if (closest) {
                      selectedData = [closest];
                  }
              }
              else {
                  var closestByX = void 0;
                  if (closest) {
                      // reuse closest value
                      closestByX = closest;
                  }
                  else {
                      // try to find the closest value by X values from the mouse position
                      var mouseX = config.axis_rotated ? mouse[1] : mouse[0];
                      closestByX = $$.findClosestFromTargetsByX(targetsToShow, $$.x.invert(mouseX));
                  }
                  // highlight all data for this 'x' value
                  if (closestByX) {
                      selectedData = $$.filterByX(targetsToShow, closestByX.x);
                  }
              }
              // ensure we have data to show
              if (!selectedData || selectedData.length === 0) {
                  return mouseout();
              }
              // inject names for each point
              selectedData = selectedData.map(withName);
              // show tooltip
              $$.showTooltip(selectedData, this);
              // expand points
              if (config.point_focus_expand_enabled) {
                  $$.unexpandCircles();
                  selectedData.forEach(function (d) {
                      $$.expandCircles(d.index, d.id, false);
                  });
              }
              // expand bars
              $$.unexpandBars();
              selectedData.forEach(function (d) {
                  $$.expandBars(d.index, d.id, false);
              });
              // Show xgrid focus line
              $$.showXGridFocus(selectedData);
          }
          : null)
          .on('click', config.interaction_enabled
          ? function () {
              var targetsToShow = $$.getTargetsToShow();
              if ($$.hasArcType(targetsToShow)) {
                  return;
              }
              var mouse = d3.mouse(this);
              var closest = withName($$.findClosestFromTargets(targetsToShow, mouse));
              if (!isHoveringDataPoint(mouse, closest)) {
                  return;
              }
              // select if selection enabled
              var sameXData;
              if (!config.data_selection_grouped || $$.isStanfordType(closest)) {
                  sameXData = [closest];
              }
              else {
                  sameXData = $$.filterByX(targetsToShow, closest.x);
              }
              // toggle selected state
              sameXData.forEach(function (d) {
                  $$.main
                      .selectAll('.' + CLASS.shapes + $$.getTargetSelectorSuffix(d.id))
                      .selectAll('.' + CLASS.shape + '-' + d.index)
                      .each(function () {
                      if (config.data_selection_grouped ||
                          $$.isWithinShape(this, d)) {
                          $$.toggleShape(this, d, d.index);
                      }
                  });
              });
              // call data_onclick on the closest data point
              if (closest) {
                  var shape = $$.main
                      .selectAll('.' + CLASS.shapes + $$.getTargetSelectorSuffix(closest.id))
                      .select('.' + CLASS.shape + '-' + closest.index);
                  config.data_onclick.call($$.api, closest, shape.node());
              }
          }
          : null)
          .call(config.interaction_enabled && config.data_selection_draggable && $$.drag
          ? d3
              .drag()
              .on('drag', function () {
              $$.drag(d3.mouse(this));
          })
              .on('start', function () {
              $$.dragstart(d3.mouse(this));
          })
              .on('end', function () {
              $$.dragend();
          })
          : function () { });
  };
  ChartInternal.prototype.getMousePosition = function (data) {
      var $$ = this;
      return [$$.x(data.x), $$.getYScale(data.id)(data.value)];
  };
  ChartInternal.prototype.dispatchEvent = function (type, mouse) {
      var $$ = this, selector = '.' + CLASS.eventRect, eventRect = $$.main.select(selector).node(), box = eventRect.getBoundingClientRect(), x = box.left + (mouse ? mouse[0] : 0), y = box.top + (mouse ? mouse[1] : 0), event = document.createEvent('MouseEvents');
      event.initMouseEvent(type, true, true, window, 0, x, y, x, y, false, false, false, false, 0, null);
      eventRect.dispatchEvent(event);
  };

  ChartInternal.prototype.initLegend = function () {
      var $$ = this;
      $$.legendItemTextBox = {};
      $$.legendHasRendered = false;
      $$.legend = $$.svg.append('g').attr('transform', $$.getTranslate('legend'));
      if (!$$.config.legend_show) {
          $$.legend.style('visibility', 'hidden');
          $$.hiddenLegendIds = $$.mapToIds($$.data.targets);
          return;
      }
      // MEMO: call here to update legend box and tranlate for all
      // MEMO: translate will be updated by this, so transform not needed in updateLegend()
      $$.updateLegendWithDefaults();
  };
  ChartInternal.prototype.updateLegendWithDefaults = function () {
      var $$ = this;
      $$.updateLegend($$.mapToIds($$.data.targets), {
          withTransform: false,
          withTransitionForTransform: false,
          withTransition: false
      });
  };
  ChartInternal.prototype.updateSizeForLegend = function (legendHeight, legendWidth) {
      var $$ = this, config = $$.config, insetLegendPosition = {
          top: $$.isLegendTop
              ? $$.getCurrentPaddingTop() + config.legend_inset_y + 5.5
              : $$.currentHeight -
                  legendHeight -
                  $$.getCurrentPaddingBottom() -
                  config.legend_inset_y,
          left: $$.isLegendLeft
              ? $$.getCurrentPaddingLeft() + config.legend_inset_x + 0.5
              : $$.currentWidth -
                  legendWidth -
                  $$.getCurrentPaddingRight() -
                  config.legend_inset_x +
                  0.5
      };
      $$.margin3 = {
          top: $$.isLegendRight
              ? 0
              : $$.isLegendInset
                  ? insetLegendPosition.top
                  : $$.currentHeight - legendHeight,
          right: NaN,
          bottom: 0,
          left: $$.isLegendRight
              ? $$.currentWidth - legendWidth
              : $$.isLegendInset
                  ? insetLegendPosition.left
                  : 0
      };
  };
  ChartInternal.prototype.transformLegend = function (withTransition) {
      var $$ = this;
      (withTransition ? $$.legend.transition() : $$.legend).attr('transform', $$.getTranslate('legend'));
  };
  ChartInternal.prototype.updateLegendStep = function (step) {
      this.legendStep = step;
  };
  ChartInternal.prototype.updateLegendItemWidth = function (w) {
      this.legendItemWidth = w;
  };
  ChartInternal.prototype.updateLegendItemHeight = function (h) {
      this.legendItemHeight = h;
  };
  ChartInternal.prototype.getLegendWidth = function () {
      var $$ = this;
      return $$.config.legend_show
          ? $$.isLegendRight || $$.isLegendInset
              ? $$.legendItemWidth * ($$.legendStep + 1)
              : $$.currentWidth
          : 0;
  };
  ChartInternal.prototype.getLegendHeight = function () {
      var $$ = this, h = 0;
      if ($$.config.legend_show) {
          if ($$.isLegendRight) {
              h = $$.currentHeight;
          }
          else {
              h = Math.max(20, $$.legendItemHeight) * ($$.legendStep + 1);
          }
      }
      return h;
  };
  ChartInternal.prototype.opacityForLegend = function (legendItem) {
      return legendItem.classed(CLASS.legendItemHidden) ? null : 1;
  };
  ChartInternal.prototype.opacityForUnfocusedLegend = function (legendItem) {
      return legendItem.classed(CLASS.legendItemHidden) ? null : 0.3;
  };
  ChartInternal.prototype.toggleFocusLegend = function (targetIds, focus) {
      var $$ = this;
      targetIds = $$.mapToTargetIds(targetIds);
      $$.legend
          .selectAll('.' + CLASS.legendItem)
          .filter(function (id) {
          return targetIds.indexOf(id) >= 0;
      })
          .classed(CLASS.legendItemFocused, focus)
          .transition()
          .duration(100)
          .style('opacity', function () {
          var opacity = focus ? $$.opacityForLegend : $$.opacityForUnfocusedLegend;
          return opacity.call($$, $$.d3.select(this));
      });
  };
  ChartInternal.prototype.revertLegend = function () {
      var $$ = this, d3 = $$.d3;
      $$.legend
          .selectAll('.' + CLASS.legendItem)
          .classed(CLASS.legendItemFocused, false)
          .transition()
          .duration(100)
          .style('opacity', function () {
          return $$.opacityForLegend(d3.select(this));
      });
  };
  ChartInternal.prototype.showLegend = function (targetIds) {
      var $$ = this, config = $$.config;
      if (!config.legend_show) {
          config.legend_show = true;
          $$.legend.style('visibility', 'visible');
          if (!$$.legendHasRendered) {
              $$.updateLegendWithDefaults();
          }
      }
      $$.removeHiddenLegendIds(targetIds);
      $$.legend
          .selectAll($$.selectorLegends(targetIds))
          .style('visibility', 'visible')
          .transition()
          .style('opacity', function () {
          return $$.opacityForLegend($$.d3.select(this));
      });
  };
  ChartInternal.prototype.hideLegend = function (targetIds) {
      var $$ = this, config = $$.config;
      if (config.legend_show && isEmpty(targetIds)) {
          config.legend_show = false;
          $$.legend.style('visibility', 'hidden');
      }
      $$.addHiddenLegendIds(targetIds);
      $$.legend
          .selectAll($$.selectorLegends(targetIds))
          .style('opacity', 0)
          .style('visibility', 'hidden');
  };
  ChartInternal.prototype.clearLegendItemTextBoxCache = function () {
      this.legendItemTextBox = {};
  };
  ChartInternal.prototype.updateLegend = function (targetIds, options, transitions) {
      var $$ = this, config = $$.config;
      var xForLegend, xForLegendText, xForLegendRect, yForLegend, yForLegendText, yForLegendRect, x1ForLegendTile, x2ForLegendTile, yForLegendTile;
      var paddingTop = 4, paddingRight = 10, maxWidth = 0, maxHeight = 0, posMin = 10, tileWidth = config.legend_item_tile_width + 5;
      var l, totalLength = 0, offsets = {}, widths = {}, heights = {}, margins = [0], steps = {}, step = 0;
      var withTransition, withTransitionForTransform;
      var texts, rects, tiles, background;
      // Skip elements when their name is set to null
      targetIds = targetIds.filter(function (id) {
          return !isDefined(config.data_names[id]) || config.data_names[id] !== null;
      });
      options = options || {};
      withTransition = getOption(options, 'withTransition', true);
      withTransitionForTransform = getOption(options, 'withTransitionForTransform', true);
      function getTextBox(textElement, id) {
          if (!$$.legendItemTextBox[id]) {
              $$.legendItemTextBox[id] = $$.getTextRect(textElement.textContent, CLASS.legendItem, textElement);
          }
          return $$.legendItemTextBox[id];
      }
      function updatePositions(textElement, id, index) {
          var reset = index === 0, isLast = index === targetIds.length - 1, box = getTextBox(textElement, id), itemWidth = box.width +
              tileWidth +
              (isLast && !($$.isLegendRight || $$.isLegendInset) ? 0 : paddingRight) +
              config.legend_padding, itemHeight = box.height + paddingTop, itemLength = $$.isLegendRight || $$.isLegendInset ? itemHeight : itemWidth, areaLength = $$.isLegendRight || $$.isLegendInset
              ? $$.getLegendHeight()
              : $$.getLegendWidth(), margin, maxLength;
          // MEMO: care about condifion of step, totalLength
          function updateValues(id, withoutStep) {
              if (!withoutStep) {
                  margin = (areaLength - totalLength - itemLength) / 2;
                  if (margin < posMin) {
                      margin = (areaLength - itemLength) / 2;
                      totalLength = 0;
                      step++;
                  }
              }
              steps[id] = step;
              margins[step] = $$.isLegendInset ? 10 : margin;
              offsets[id] = totalLength;
              totalLength += itemLength;
          }
          if (reset) {
              totalLength = 0;
              step = 0;
              maxWidth = 0;
              maxHeight = 0;
          }
          if (config.legend_show && !$$.isLegendToShow(id)) {
              widths[id] = heights[id] = steps[id] = offsets[id] = 0;
              return;
          }
          widths[id] = itemWidth;
          heights[id] = itemHeight;
          if (!maxWidth || itemWidth >= maxWidth) {
              maxWidth = itemWidth;
          }
          if (!maxHeight || itemHeight >= maxHeight) {
              maxHeight = itemHeight;
          }
          maxLength = $$.isLegendRight || $$.isLegendInset ? maxHeight : maxWidth;
          if (config.legend_equally) {
              Object.keys(widths).forEach(function (id) {
                  widths[id] = maxWidth;
              });
              Object.keys(heights).forEach(function (id) {
                  heights[id] = maxHeight;
              });
              margin = (areaLength - maxLength * targetIds.length) / 2;
              if (margin < posMin) {
                  totalLength = 0;
                  step = 0;
                  targetIds.forEach(function (id) {
                      updateValues(id);
                  });
              }
              else {
                  updateValues(id, true);
              }
          }
          else {
              updateValues(id);
          }
      }
      if ($$.isLegendInset) {
          step = config.legend_inset_step
              ? config.legend_inset_step
              : targetIds.length;
          $$.updateLegendStep(step);
      }
      if ($$.isLegendRight) {
          xForLegend = function (id) {
              return maxWidth * steps[id];
          };
          yForLegend = function (id) {
              return margins[steps[id]] + offsets[id];
          };
      }
      else if ($$.isLegendInset) {
          xForLegend = function (id) {
              return maxWidth * steps[id] + 10;
          };
          yForLegend = function (id) {
              return margins[steps[id]] + offsets[id];
          };
      }
      else {
          xForLegend = function (id) {
              return margins[steps[id]] + offsets[id];
          };
          yForLegend = function (id) {
              return maxHeight * steps[id];
          };
      }
      xForLegendText = function (id, i) {
          return xForLegend(id, i) + 4 + config.legend_item_tile_width;
      };
      yForLegendText = function (id, i) {
          return yForLegend(id, i) + 9;
      };
      xForLegendRect = function (id, i) {
          return xForLegend(id, i);
      };
      yForLegendRect = function (id, i) {
          return yForLegend(id, i) - 5;
      };
      x1ForLegendTile = function (id, i) {
          return xForLegend(id, i) - 2;
      };
      x2ForLegendTile = function (id, i) {
          return xForLegend(id, i) - 2 + config.legend_item_tile_width;
      };
      yForLegendTile = function (id, i) {
          return yForLegend(id, i) + 4;
      };
      // Define g for legend area
      l = $$.legend
          .selectAll('.' + CLASS.legendItem)
          .data(targetIds)
          .enter()
          .append('g')
          .attr('class', function (id) {
          return $$.generateClass(CLASS.legendItem, id);
      })
          .style('visibility', function (id) {
          return $$.isLegendToShow(id) ? 'visible' : 'hidden';
      })
          .style('cursor', function () {
          return config.interaction_enabled ? 'pointer' : 'auto';
      })
          .on('click', config.interaction_enabled
          ? function (id) {
              if (config.legend_item_onclick) {
                  config.legend_item_onclick.call($$, id);
              }
              else {
                  if ($$.d3.event.altKey) {
                      $$.api.hide();
                      $$.api.show(id);
                  }
                  else {
                      $$.api.toggle(id);
                      $$.isTargetToShow(id) ? $$.api.focus(id) : $$.api.revert();
                  }
              }
          }
          : null)
          .on('mouseover', config.interaction_enabled
          ? function (id) {
              if (config.legend_item_onmouseover) {
                  config.legend_item_onmouseover.call($$, id);
              }
              else {
                  $$.d3.select(this).classed(CLASS.legendItemFocused, true);
                  if (!$$.transiting && $$.isTargetToShow(id)) {
                      $$.api.focus(id);
                  }
              }
          }
          : null)
          .on('mouseout', config.interaction_enabled
          ? function (id) {
              if (config.legend_item_onmouseout) {
                  config.legend_item_onmouseout.call($$, id);
              }
              else {
                  $$.d3.select(this).classed(CLASS.legendItemFocused, false);
                  $$.api.revert();
              }
          }
          : null);
      l.append('text')
          .text(function (id) {
          return isDefined(config.data_names[id]) ? config.data_names[id] : id;
      })
          .each(function (id, i) {
          updatePositions(this, id, i);
      })
          .style('pointer-events', 'none')
          .attr('x', $$.isLegendRight || $$.isLegendInset ? xForLegendText : -200)
          .attr('y', $$.isLegendRight || $$.isLegendInset ? -200 : yForLegendText);
      l.append('rect')
          .attr('class', CLASS.legendItemEvent)
          .style('fill-opacity', 0)
          .attr('x', $$.isLegendRight || $$.isLegendInset ? xForLegendRect : -200)
          .attr('y', $$.isLegendRight || $$.isLegendInset ? -200 : yForLegendRect);
      l.append('line')
          .attr('class', CLASS.legendItemTile)
          .style('stroke', $$.color)
          .style('pointer-events', 'none')
          .attr('x1', $$.isLegendRight || $$.isLegendInset ? x1ForLegendTile : -200)
          .attr('y1', $$.isLegendRight || $$.isLegendInset ? -200 : yForLegendTile)
          .attr('x2', $$.isLegendRight || $$.isLegendInset ? x2ForLegendTile : -200)
          .attr('y2', $$.isLegendRight || $$.isLegendInset ? -200 : yForLegendTile)
          .attr('stroke-width', config.legend_item_tile_height);
      // Set background for inset legend
      background = $$.legend.select('.' + CLASS.legendBackground + ' rect');
      if ($$.isLegendInset && maxWidth > 0 && background.size() === 0) {
          background = $$.legend
              .insert('g', '.' + CLASS.legendItem)
              .attr('class', CLASS.legendBackground)
              .append('rect');
      }
      texts = $$.legend
          .selectAll('text')
          .data(targetIds)
          .text(function (id) {
          return isDefined(config.data_names[id]) ? config.data_names[id] : id;
      }) // MEMO: needed for update
          .each(function (id, i) {
          updatePositions(this, id, i);
      });
      (withTransition ? texts.transition() : texts)
          .attr('x', xForLegendText)
          .attr('y', yForLegendText);
      rects = $$.legend.selectAll('rect.' + CLASS.legendItemEvent).data(targetIds);
      (withTransition ? rects.transition() : rects)
          .attr('width', function (id) {
          return widths[id];
      })
          .attr('height', function (id) {
          return heights[id];
      })
          .attr('x', xForLegendRect)
          .attr('y', yForLegendRect);
      tiles = $$.legend.selectAll('line.' + CLASS.legendItemTile).data(targetIds);
      (withTransition ? tiles.transition() : tiles)
          .style('stroke', $$.levelColor
          ? function (id) {
              return $$.levelColor($$.cache[id].values.reduce(function (total, item) {
                  return total + item.value;
              }, 0));
          }
          : $$.color)
          .attr('x1', x1ForLegendTile)
          .attr('y1', yForLegendTile)
          .attr('x2', x2ForLegendTile)
          .attr('y2', yForLegendTile);
      if (background) {
          (withTransition ? background.transition() : background)
              .attr('height', $$.getLegendHeight() - 12)
              .attr('width', maxWidth * (step + 1) + 10);
      }
      // toggle legend state
      $$.legend
          .selectAll('.' + CLASS.legendItem)
          .classed(CLASS.legendItemHidden, function (id) {
          return !$$.isTargetToShow(id);
      });
      // Update all to reflect change of legend
      $$.updateLegendItemWidth(maxWidth);
      $$.updateLegendItemHeight(maxHeight);
      $$.updateLegendStep(step);
      // Update size and scale
      $$.updateSizes();
      $$.updateScales();
      $$.updateSvgSize();
      // Update g positions
      $$.transformAll(withTransitionForTransform, transitions);
      $$.legendHasRendered = true;
  };

  ChartInternal.prototype.initRegion = function () {
      var $$ = this;
      $$.region = $$.main
          .append('g')
          .attr('clip-path', $$.clipPath)
          .attr('class', CLASS.regions);
  };
  ChartInternal.prototype.updateRegion = function (duration) {
      var $$ = this, config = $$.config;
      // hide if arc type
      $$.region.style('visibility', $$.hasArcType() ? 'hidden' : 'visible');
      var mainRegion = $$.main
          .select('.' + CLASS.regions)
          .selectAll('.' + CLASS.region)
          .data(config.regions);
      var g = mainRegion.enter().append('g');
      g.append('rect')
          .attr('x', $$.regionX.bind($$))
          .attr('y', $$.regionY.bind($$))
          .attr('width', $$.regionWidth.bind($$))
          .attr('height', $$.regionHeight.bind($$))
          .style('fill-opacity', function (d) {
          return isValue(d.opacity) ? d.opacity : 0.1;
      });
      g.append('text').text($$.labelRegion.bind($$));
      $$.mainRegion = g.merge(mainRegion).attr('class', $$.classRegion.bind($$));
      mainRegion
          .exit()
          .transition()
          .duration(duration)
          .style('opacity', 0)
          .remove();
  };
  ChartInternal.prototype.redrawRegion = function (withTransition, transition) {
      var $$ = this, regions = $$.mainRegion, regionLabels = $$.mainRegion.selectAll('text');
      return [
          (withTransition ? regions.transition(transition) : regions)
              .attr('x', $$.regionX.bind($$))
              .attr('y', $$.regionY.bind($$))
              .attr('width', $$.regionWidth.bind($$))
              .attr('height', $$.regionHeight.bind($$))
              .style('fill-opacity', function (d) {
              return isValue(d.opacity) ? d.opacity : 0.1;
          }),
          (withTransition ? regionLabels.transition(transition) : regionLabels)
              .attr('x', $$.labelOffsetX.bind($$))
              .attr('y', $$.labelOffsetY.bind($$))
              .attr('transform', $$.labelTransform.bind($$))
              .attr('style', 'text-anchor: left;')
      ];
  };
  ChartInternal.prototype.regionX = function (d) {
      var $$ = this, config = $$.config, xPos, yScale = d.axis === 'y' ? $$.y : $$.y2;
      if (d.axis === 'y' || d.axis === 'y2') {
          xPos = config.axis_rotated ? ('start' in d ? yScale(d.start) : 0) : 0;
      }
      else {
          xPos = config.axis_rotated
              ? 0
              : 'start' in d
                  ? $$.x($$.isTimeSeries() ? $$.parseDate(d.start) : d.start)
                  : 0;
      }
      return xPos;
  };
  ChartInternal.prototype.regionY = function (d) {
      var $$ = this, config = $$.config, yPos, yScale = d.axis === 'y' ? $$.y : $$.y2;
      if (d.axis === 'y' || d.axis === 'y2') {
          yPos = config.axis_rotated ? 0 : 'end' in d ? yScale(d.end) : 0;
      }
      else {
          yPos = config.axis_rotated
              ? 'start' in d
                  ? $$.x($$.isTimeSeries() ? $$.parseDate(d.start) : d.start)
                  : 0
              : 0;
      }
      return yPos;
  };
  ChartInternal.prototype.regionWidth = function (d) {
      var $$ = this, config = $$.config, start = $$.regionX(d), end, yScale = d.axis === 'y' ? $$.y : $$.y2;
      if (d.axis === 'y' || d.axis === 'y2') {
          end = config.axis_rotated
              ? 'end' in d
                  ? yScale(d.end)
                  : $$.width
              : $$.width;
      }
      else {
          end = config.axis_rotated
              ? $$.width
              : 'end' in d
                  ? $$.x($$.isTimeSeries() ? $$.parseDate(d.end) : d.end)
                  : $$.width;
      }
      return end < start ? 0 : end - start;
  };
  ChartInternal.prototype.regionHeight = function (d) {
      var $$ = this, config = $$.config, start = this.regionY(d), end, yScale = d.axis === 'y' ? $$.y : $$.y2;
      if (d.axis === 'y' || d.axis === 'y2') {
          end = config.axis_rotated
              ? $$.height
              : 'start' in d
                  ? yScale(d.start)
                  : $$.height;
      }
      else {
          end = config.axis_rotated
              ? 'end' in d
                  ? $$.x($$.isTimeSeries() ? $$.parseDate(d.end) : d.end)
                  : $$.height
              : $$.height;
      }
      return end < start ? 0 : end - start;
  };
  ChartInternal.prototype.isRegionOnX = function (d) {
      return !d.axis || d.axis === 'x';
  };
  ChartInternal.prototype.labelRegion = function (d) {
      return 'label' in d ? d.label : '';
  };
  ChartInternal.prototype.labelTransform = function (d) {
      return 'vertical' in d && d.vertical ? 'rotate(90)' : '';
  };
  ChartInternal.prototype.labelOffsetX = function (d) {
      var paddingX = 'paddingX' in d ? d.paddingX : 3;
      var paddingY = 'paddingY' in d ? d.paddingY : 3;
      return 'vertical' in d && d.vertical
          ? this.regionY(d) + paddingY
          : this.regionX(d) + paddingX;
  };
  ChartInternal.prototype.labelOffsetY = function (d) {
      var paddingX = 'paddingX' in d ? d.paddingX : 3;
      var paddingY = 'paddingY' in d ? d.paddingY : 3;
      return 'vertical' in d && d.vertical
          ? -(this.regionX(d) + paddingX)
          : this.regionY(d) + 10 + paddingY;
  };

  function c3LogScale(d3, linearScale, logScale) {
      var PROJECTION = [0.01, 10];
      if (!linearScale) {
          linearScale = d3.scaleLinear();
          linearScale.range(PROJECTION);
      }
      if (!logScale) {
          logScale = d3.scaleLog();
          logScale.domain(PROJECTION);
          logScale.nice();
      }
      // copied from https://github.com/compute-io/logspace
      function logspace(a, b, len) {
          var arr, end, tmp, d;
          if (arguments.length < 3) {
              len = 10;
          }
          else {
              if (len === 0) {
                  return [];
              }
          }
          // Calculate the increment:
          end = len - 1;
          d = (b - a) / end;
          // Build the output array...
          arr = new Array(len);
          tmp = a;
          arr[0] = Math.pow(10, tmp);
          for (var i = 1; i < end; i++) {
              tmp += d;
              arr[i] = Math.pow(10, tmp);
          }
          arr[end] = Math.pow(10, b);
          return arr;
      }
      function scale(x) {
          return logScale(linearScale(x));
      }
      scale.domain = function (x) {
          if (!arguments.length) {
              return linearScale.domain();
          }
          linearScale.domain(x);
          return scale;
      };
      scale.range = function (x) {
          if (!arguments.length) {
              return logScale.range();
          }
          logScale.range(x);
          return scale;
      };
      scale.ticks = function (m) {
          return logspace(-2, 1, m || 10).map(function (v) {
              return linearScale.invert(v);
          });
      };
      scale.copy = function () {
          return c3LogScale(d3, linearScale.copy(), logScale.copy());
      };
      return scale;
  }
  ChartInternal.prototype.getScale = function (min, max, forTimeseries) {
      return (forTimeseries ? this.d3.scaleTime() : this.d3.scaleLinear()).range([
          min,
          max
      ]);
  };
  ChartInternal.prototype.getX = function (min, max, domain, offset) {
      var $$ = this, scale = $$.getScale(min, max, $$.isTimeSeries()), _scale = domain ? scale.domain(domain) : scale, key;
      // Define customized scale if categorized axis
      if ($$.isCategorized()) {
          offset =
              offset ||
                  function () {
                      return 0;
                  };
          scale = function (d, raw) {
              var v = _scale(d) + offset(d);
              return raw ? v : Math.ceil(v);
          };
      }
      else {
          scale = function (d, raw) {
              var v = _scale(d);
              return raw ? v : Math.ceil(v);
          };
      }
      // define functions
      for (key in _scale) {
          scale[key] = _scale[key];
      }
      scale.orgDomain = function () {
          return _scale.domain();
      };
      // define custom domain() for categorized axis
      if ($$.isCategorized()) {
          scale.domain = function (domain) {
              if (!arguments.length) {
                  domain = this.orgDomain();
                  return [domain[0], domain[1] + 1];
              }
              _scale.domain(domain);
              return scale;
          };
      }
      return scale;
  };
  /**
   * Creates and configures a D3 scale instance for the given type.
   *
   * By defaults it returns a Linear scale.
   *
   * @param {String} type Type of d3-scale to create. Type can be 'linear', 'time', 'timeseries' or 'log'.
   * @param {Array} domain The scale domain such as [from, to]
   * @param {Array} range The scale's range such as [from, to]
   *
   * @return A d3-scale instance
   */
  ChartInternal.prototype.getY = function (type, domain, range) {
      var scale;
      if (type === 'timeseries' || type === 'time') {
          scale = this.d3.scaleTime();
      }
      else if (type === 'log') {
          scale = c3LogScale(this.d3);
      }
      else if (type === 'linear' || type === undefined) {
          scale = this.d3.scaleLinear();
      }
      else {
          throw new Error("Invalid Y axis type: \"" + type + "\"");
      }
      if (domain) {
          scale.domain(domain);
      }
      if (range) {
          scale.range(range);
      }
      return scale;
  };
  ChartInternal.prototype.getYScale = function (id) {
      return this.axis.getId(id) === 'y2' ? this.y2 : this.y;
  };
  ChartInternal.prototype.getSubYScale = function (id) {
      return this.axis.getId(id) === 'y2' ? this.subY2 : this.subY;
  };
  ChartInternal.prototype.updateScales = function () {
      var $$ = this, config = $$.config, forInit = !$$.x;
      // update edges
      $$.xMin = config.axis_rotated ? 1 : 0;
      $$.xMax = config.axis_rotated ? $$.height : $$.width;
      $$.yMin = config.axis_rotated ? 0 : $$.height;
      $$.yMax = config.axis_rotated ? $$.width : 1;
      $$.subXMin = $$.xMin;
      $$.subXMax = $$.xMax;
      $$.subYMin = config.axis_rotated ? 0 : $$.height2;
      $$.subYMax = config.axis_rotated ? $$.width2 : 1;
      // update scales
      $$.x = $$.getX($$.xMin, $$.xMax, forInit ? undefined : $$.x.orgDomain(), function () {
          return $$.xAxis.tickOffset();
      });
      $$.y = $$.getY(config.axis_y_type, forInit ? config.axis_y_default : $$.y.domain(), [$$.yMin, $$.yMax]);
      $$.y2 = $$.getY(config.axis_y2_type, forInit ? config.axis_y2_default : $$.y2.domain(), [$$.yMin, $$.yMax]);
      $$.subX = $$.getX($$.xMin, $$.xMax, $$.orgXDomain, function (d) {
          return d % 1 ? 0 : $$.subXAxis.tickOffset();
      });
      $$.subY = $$.getY(config.axis_y_type, forInit ? config.axis_y_default : $$.subY.domain(), [$$.subYMin, $$.subYMax]);
      $$.subY2 = $$.getY(config.axis_y2_type, forInit ? config.axis_y2_default : $$.subY2.domain(), [$$.subYMin, $$.subYMax]);
      // update axes
      $$.xAxisTickFormat = $$.axis.getXAxisTickFormat();
      $$.xAxisTickValues = $$.axis.getXAxisTickValues();
      $$.yAxisTickValues = $$.axis.getYAxisTickValues();
      $$.y2AxisTickValues = $$.axis.getY2AxisTickValues();
      $$.xAxis = $$.axis.getXAxis($$.x, $$.xOrient, $$.xAxisTickFormat, $$.xAxisTickValues, config.axis_x_tick_outer);
      $$.subXAxis = $$.axis.getXAxis($$.subX, $$.subXOrient, $$.xAxisTickFormat, $$.xAxisTickValues, config.axis_x_tick_outer);
      $$.yAxis = $$.axis.getYAxis('y', $$.y, $$.yOrient, $$.yAxisTickValues, config.axis_y_tick_outer);
      $$.y2Axis = $$.axis.getYAxis('y2', $$.y2, $$.y2Orient, $$.y2AxisTickValues, config.axis_y2_tick_outer);
      // Set initialized scales to brush and zoom
      if (!forInit) {
          if ($$.brush) {
              $$.brush.updateScale($$.subX);
          }
      }
      // update for arc
      if ($$.updateArc) {
          $$.updateArc();
      }
  };

  ChartInternal.prototype.selectPoint = function (target, d, i) {
      var $$ = this, config = $$.config, cx = (config.axis_rotated ? $$.circleY : $$.circleX).bind($$), cy = (config.axis_rotated ? $$.circleX : $$.circleY).bind($$), r = $$.pointSelectR.bind($$);
      config.data_onselected.call($$.api, d, target.node());
      // add selected-circle on low layer g
      $$.main
          .select('.' + CLASS.selectedCircles + $$.getTargetSelectorSuffix(d.id))
          .selectAll('.' + CLASS.selectedCircle + '-' + i)
          .data([d])
          .enter()
          .append('circle')
          .attr('class', function () {
          return $$.generateClass(CLASS.selectedCircle, i);
      })
          .attr('cx', cx)
          .attr('cy', cy)
          .attr('stroke', function () {
          return $$.color(d);
      })
          .attr('r', function (d) {
          return $$.pointSelectR(d) * 1.4;
      })
          .transition()
          .duration(100)
          .attr('r', r);
  };
  ChartInternal.prototype.unselectPoint = function (target, d, i) {
      var $$ = this;
      $$.config.data_onunselected.call($$.api, d, target.node());
      // remove selected-circle from low layer g
      $$.main
          .select('.' + CLASS.selectedCircles + $$.getTargetSelectorSuffix(d.id))
          .selectAll('.' + CLASS.selectedCircle + '-' + i)
          .transition()
          .duration(100)
          .attr('r', 0)
          .remove();
  };
  ChartInternal.prototype.togglePoint = function (selected, target, d, i) {
      selected ? this.selectPoint(target, d, i) : this.unselectPoint(target, d, i);
  };
  ChartInternal.prototype.selectPath = function (target, d) {
      var $$ = this;
      $$.config.data_onselected.call($$, d, target.node());
      if ($$.config.interaction_brighten) {
          target
              .transition()
              .duration(100)
              .style('fill', function () {
              return $$.d3.rgb($$.color(d)).brighter(0.75);
          });
      }
  };
  ChartInternal.prototype.unselectPath = function (target, d) {
      var $$ = this;
      $$.config.data_onunselected.call($$, d, target.node());
      if ($$.config.interaction_brighten) {
          target
              .transition()
              .duration(100)
              .style('fill', function () {
              return $$.color(d);
          });
      }
  };
  ChartInternal.prototype.togglePath = function (selected, target, d, i) {
      selected ? this.selectPath(target, d, i) : this.unselectPath(target, d, i);
  };
  ChartInternal.prototype.getToggle = function (that, d) {
      var $$ = this, toggle;
      if (that.nodeName === 'circle') {
          if ($$.isStepType(d)) {
              // circle is hidden in step chart, so treat as within the click area
              toggle = function () { }; // TODO: how to select step chart?
          }
          else {
              toggle = $$.togglePoint;
          }
      }
      else if (that.nodeName === 'path') {
          toggle = $$.togglePath;
      }
      return toggle;
  };
  ChartInternal.prototype.toggleShape = function (that, d, i) {
      var $$ = this, d3 = $$.d3, config = $$.config, shape = d3.select(that), isSelected = shape.classed(CLASS.SELECTED), toggle = $$.getToggle(that, d).bind($$);
      if (config.data_selection_enabled && config.data_selection_isselectable(d)) {
          if (!config.data_selection_multiple) {
              $$.main
                  .selectAll('.' +
                  CLASS.shapes +
                  (config.data_selection_grouped
                      ? $$.getTargetSelectorSuffix(d.id)
                      : ''))
                  .selectAll('.' + CLASS.shape)
                  .each(function (d, i) {
                  var shape = d3.select(this);
                  if (shape.classed(CLASS.SELECTED)) {
                      toggle(false, shape.classed(CLASS.SELECTED, false), d, i);
                  }
              });
          }
          shape.classed(CLASS.SELECTED, !isSelected);
          toggle(!isSelected, shape, d, i);
      }
  };

  ChartInternal.prototype.initBar = function () {
      var $$ = this;
      $$.main
          .select('.' + CLASS.chart)
          .append('g')
          .attr('class', CLASS.chartBars);
  };
  ChartInternal.prototype.updateTargetsForBar = function (targets) {
      var $$ = this, config = $$.config, mainBars, mainBarEnter, classChartBar = $$.classChartBar.bind($$), classBars = $$.classBars.bind($$), classFocus = $$.classFocus.bind($$);
      mainBars = $$.main
          .select('.' + CLASS.chartBars)
          .selectAll('.' + CLASS.chartBar)
          .data(targets)
          .attr('class', function (d) {
          return classChartBar(d) + classFocus(d);
      });
      mainBarEnter = mainBars
          .enter()
          .append('g')
          .attr('class', classChartBar)
          .style('pointer-events', 'none');
      // Bars for each data
      mainBarEnter
          .append('g')
          .attr('class', classBars)
          .style('cursor', function (d) {
          return config.data_selection_isselectable(d) ? 'pointer' : null;
      });
  };
  ChartInternal.prototype.updateBar = function (durationForExit) {
      var $$ = this, barData = $$.barData.bind($$), classBar = $$.classBar.bind($$), initialOpacity = $$.initialOpacity.bind($$), color = function (d) {
          return $$.color(d.id);
      };
      var mainBar = $$.main
          .selectAll('.' + CLASS.bars)
          .selectAll('.' + CLASS.bar)
          .data(barData);
      var mainBarEnter = mainBar
          .enter()
          .append('path')
          .attr('class', classBar)
          .style('stroke', color)
          .style('fill', color);
      $$.mainBar = mainBarEnter.merge(mainBar).style('opacity', initialOpacity);
      mainBar
          .exit()
          .transition()
          .duration(durationForExit)
          .style('opacity', 0);
  };
  ChartInternal.prototype.redrawBar = function (drawBar, withTransition, transition) {
      var $$ = this;
      return [
          (withTransition ? this.mainBar.transition(transition) : this.mainBar)
              .attr('d', drawBar)
              .style('stroke', this.color)
              .style('fill', this.color)
              .style('opacity', function (d) { return ($$.isTargetToShow(d.id) ? 1 : 0); })
      ];
  };
  ChartInternal.prototype.getBarW = function (axis, barTargetsNum) {
      var $$ = this, config = $$.config, w = typeof config.bar_width === 'number'
          ? config.bar_width
          : barTargetsNum
              ? (axis.tickInterval() * config.bar_width_ratio) / barTargetsNum
              : 0;
      return config.bar_width_max && w > config.bar_width_max
          ? config.bar_width_max
          : w;
  };
  ChartInternal.prototype.getBars = function (i, id) {
      var $$ = this;
      return (id
          ? $$.main.selectAll('.' + CLASS.bars + $$.getTargetSelectorSuffix(id))
          : $$.main).selectAll('.' + CLASS.bar + (isValue(i) ? '-' + i : ''));
  };
  ChartInternal.prototype.expandBars = function (i, id, reset) {
      var $$ = this;
      if (reset) {
          $$.unexpandBars();
      }
      $$.getBars(i, id).classed(CLASS.EXPANDED, true);
  };
  ChartInternal.prototype.unexpandBars = function (i) {
      var $$ = this;
      $$.getBars(i).classed(CLASS.EXPANDED, false);
  };
  ChartInternal.prototype.generateDrawBar = function (barIndices, isSub) {
      var $$ = this, config = $$.config, getPoints = $$.generateGetBarPoints(barIndices, isSub);
      return function (d, i) {
          // 4 points that make a bar
          var points = getPoints(d, i);
          // switch points if axis is rotated, not applicable for sub chart
          var indexX = config.axis_rotated ? 1 : 0;
          var indexY = config.axis_rotated ? 0 : 1;
          var path = 'M ' +
              points[0][indexX] +
              ',' +
              points[0][indexY] +
              ' ' +
              'L' +
              points[1][indexX] +
              ',' +
              points[1][indexY] +
              ' ' +
              'L' +
              points[2][indexX] +
              ',' +
              points[2][indexY] +
              ' ' +
              'L' +
              points[3][indexX] +
              ',' +
              points[3][indexY] +
              ' ' +
              'z';
          return path;
      };
  };
  ChartInternal.prototype.generateGetBarPoints = function (barIndices, isSub) {
      var $$ = this, axis = isSub ? $$.subXAxis : $$.xAxis, barTargetsNum = barIndices.__max__ + 1, barW = $$.getBarW(axis, barTargetsNum), barX = $$.getShapeX(barW, barTargetsNum, barIndices, !!isSub), barY = $$.getShapeY(!!isSub), barOffset = $$.getShapeOffset($$.isBarType, barIndices, !!isSub), barSpaceOffset = barW * ($$.config.bar_space / 2), yScale = isSub ? $$.getSubYScale : $$.getYScale;
      return function (d, i) {
          var y0 = yScale.call($$, d.id)(0), offset = barOffset(d, i) || y0, // offset is for stacked bar chart
          posX = barX(d), posY = barY(d);
          // fix posY not to overflow opposite quadrant
          if ($$.config.axis_rotated) {
              if ((0 < d.value && posY < y0) || (d.value < 0 && y0 < posY)) {
                  posY = y0;
              }
          }
          posY -= y0 - offset;
          // 4 points that make a bar
          return [
              [posX + barSpaceOffset, offset],
              [posX + barSpaceOffset, posY],
              [posX + barW - barSpaceOffset, posY],
              [posX + barW - barSpaceOffset, offset]
          ];
      };
  };
  /**
   * Returns whether the data point is within the given bar shape.
   *
   * @param mouse
   * @param barShape
   * @return {boolean}
   */
  ChartInternal.prototype.isWithinBar = function (mouse, barShape) {
      return isWithinBox(mouse, getBBox(barShape), 2);
  };

  ChartInternal.prototype.getShapeIndices = function (typeFilter) {
      var $$ = this, config = $$.config, indices = {}, i = 0, j, k;
      $$.filterTargetsToShow($$.data.targets.filter(typeFilter, $$)).forEach(function (d) {
          for (j = 0; j < config.data_groups.length; j++) {
              if (config.data_groups[j].indexOf(d.id) < 0) {
                  continue;
              }
              for (k = 0; k < config.data_groups[j].length; k++) {
                  if (config.data_groups[j][k] in indices) {
                      indices[d.id] = indices[config.data_groups[j][k]];
                      break;
                  }
              }
          }
          if (isUndefined(indices[d.id])) {
              indices[d.id] = i++;
          }
      });
      indices.__max__ = i - 1;
      return indices;
  };
  ChartInternal.prototype.getShapeX = function (offset, targetsNum, indices, isSub) {
      var $$ = this, scale = isSub ? $$.subX : $$.x;
      return function (d) {
          var index = d.id in indices ? indices[d.id] : 0;
          return d.x || d.x === 0 ? scale(d.x) - offset * (targetsNum / 2 - index) : 0;
      };
  };
  ChartInternal.prototype.getShapeY = function (isSub) {
      var $$ = this;
      return function (d) {
          var scale = isSub ? $$.getSubYScale(d.id) : $$.getYScale(d.id);
          return scale($$.isTargetNormalized(d.id) ? $$.getRatio('index', d, true) : d.value);
      };
  };
  ChartInternal.prototype.getShapeOffset = function (typeFilter, indices, isSub) {
      var $$ = this, targets = $$.orderTargets($$.filterTargetsToShow($$.data.targets.filter(typeFilter, $$))), targetIds = targets.map(function (t) {
          return t.id;
      });
      return function (d, i) {
          var scale = isSub ? $$.getSubYScale(d.id) : $$.getYScale(d.id), y0 = scale(0), offset = y0;
          targets.forEach(function (t) {
              var rowValues = $$.isStepType(d)
                  ? $$.convertValuesToStep(t.values)
                  : t.values;
              var isTargetNormalized = $$.isTargetNormalized(d.id);
              var values = rowValues.map(function (v) {
                  return isTargetNormalized ? $$.getRatio('index', v, true) : v.value;
              });
              if (t.id === d.id || indices[t.id] !== indices[d.id]) {
                  return;
              }
              if (targetIds.indexOf(t.id) < targetIds.indexOf(d.id)) {
                  // check if the x values line up
                  if (isUndefined(rowValues[i]) || +rowValues[i].x !== +d.x) {
                      // "+" for timeseries
                      // if not, try to find the value that does line up
                      i = -1;
                      rowValues.forEach(function (v, j) {
                          var x1 = v.x.constructor === Date ? +v.x : v.x;
                          var x2 = d.x.constructor === Date ? +d.x : d.x;
                          if (x1 === x2) {
                              i = j;
                          }
                      });
                  }
                  if (i in rowValues && rowValues[i].value * d.value >= 0) {
                      offset += scale(values[i]) - y0;
                  }
              }
          });
          return offset;
      };
  };
  ChartInternal.prototype.isWithinShape = function (that, d) {
      var $$ = this, shape = $$.d3.select(that), isWithin;
      if (!$$.isTargetToShow(d.id)) {
          isWithin = false;
      }
      else if (that.nodeName === 'circle') {
          isWithin = $$.isStepType(d)
              ? $$.isWithinStep(that, $$.getYScale(d.id)(d.value))
              : $$.isWithinCircle(that, $$.pointSelectR(d) * 1.5);
      }
      else if (that.nodeName === 'path') {
          isWithin = shape.classed(CLASS.bar)
              ? $$.isWithinBar($$.d3.mouse(that), that)
              : true;
      }
      return isWithin;
  };
  ChartInternal.prototype.getInterpolate = function (d) {
      var $$ = this, d3 = $$.d3, types = {
          linear: d3.curveLinear,
          'linear-closed': d3.curveLinearClosed,
          basis: d3.curveBasis,
          'basis-open': d3.curveBasisOpen,
          'basis-closed': d3.curveBasisClosed,
          bundle: d3.curveBundle,
          cardinal: d3.curveCardinal,
          'cardinal-open': d3.curveCardinalOpen,
          'cardinal-closed': d3.curveCardinalClosed,
          monotone: d3.curveMonotoneX,
          step: d3.curveStep,
          'step-before': d3.curveStepBefore,
          'step-after': d3.curveStepAfter
      }, type;
      if ($$.isSplineType(d)) {
          type = types[$$.config.spline_interpolation_type] || types.cardinal;
      }
      else if ($$.isStepType(d)) {
          type = types[$$.config.line_step_type];
      }
      else {
          type = types.linear;
      }
      return type;
  };

  ChartInternal.prototype.initLine = function () {
      var $$ = this;
      $$.main
          .select('.' + CLASS.chart)
          .append('g')
          .attr('class', CLASS.chartLines);
  };
  ChartInternal.prototype.updateTargetsForLine = function (targets) {
      var $$ = this, config = $$.config, mainLines, mainLineEnter, classChartLine = $$.classChartLine.bind($$), classLines = $$.classLines.bind($$), classAreas = $$.classAreas.bind($$), classCircles = $$.classCircles.bind($$), classFocus = $$.classFocus.bind($$);
      mainLines = $$.main
          .select('.' + CLASS.chartLines)
          .selectAll('.' + CLASS.chartLine)
          .data(targets)
          .attr('class', function (d) {
          return classChartLine(d) + classFocus(d);
      });
      mainLineEnter = mainLines
          .enter()
          .append('g')
          .attr('class', classChartLine)
          .style('opacity', 0)
          .style('pointer-events', 'none');
      // Lines for each data
      mainLineEnter.append('g').attr('class', classLines);
      // Areas
      mainLineEnter.append('g').attr('class', classAreas);
      // Circles for each data point on lines
      mainLineEnter.append('g').attr('class', function (d) {
          return $$.generateClass(CLASS.selectedCircles, d.id);
      });
      mainLineEnter
          .append('g')
          .attr('class', classCircles)
          .style('cursor', function (d) {
          return config.data_selection_isselectable(d) ? 'pointer' : null;
      });
      // Update date for selected circles
      targets.forEach(function (t) {
          $$.main
              .selectAll('.' + CLASS.selectedCircles + $$.getTargetSelectorSuffix(t.id))
              .selectAll('.' + CLASS.selectedCircle)
              .each(function (d) {
              d.value = t.values[d.index].value;
          });
      });
      // MEMO: can not keep same color...
      //mainLineUpdate.exit().remove();
  };
  ChartInternal.prototype.updateLine = function (durationForExit) {
      var $$ = this;
      var mainLine = $$.main
          .selectAll('.' + CLASS.lines)
          .selectAll('.' + CLASS.line)
          .data($$.lineData.bind($$));
      var mainLineEnter = mainLine
          .enter()
          .append('path')
          .attr('class', $$.classLine.bind($$))
          .style('stroke', $$.color);
      $$.mainLine = mainLineEnter
          .merge(mainLine)
          .style('opacity', $$.initialOpacity.bind($$))
          .style('shape-rendering', function (d) {
          return $$.isStepType(d) ? 'crispEdges' : '';
      })
          .attr('transform', null);
      mainLine
          .exit()
          .transition()
          .duration(durationForExit)
          .style('opacity', 0);
  };
  ChartInternal.prototype.redrawLine = function (drawLine, withTransition, transition) {
      return [
          (withTransition ? this.mainLine.transition(transition) : this.mainLine)
              .attr('d', drawLine)
              .style('stroke', this.color)
              .style('opacity', 1)
      ];
  };
  ChartInternal.prototype.generateDrawLine = function (lineIndices, isSub) {
      var $$ = this, config = $$.config, line = $$.d3.line(), getPoints = $$.generateGetLinePoints(lineIndices, isSub), yScaleGetter = isSub ? $$.getSubYScale : $$.getYScale, xValue = function (d) {
          return (isSub ? $$.subxx : $$.xx).call($$, d);
      }, yValue = function (d, i) {
          return config.data_groups.length > 0
              ? getPoints(d, i)[0][1]
              : yScaleGetter.call($$, d.id)(d.value);
      };
      line = config.axis_rotated
          ? line.x(yValue).y(xValue)
          : line.x(xValue).y(yValue);
      if (!config.line_connectNull) {
          line = line.defined(function (d) {
              return d.value != null;
          });
      }
      return function (d) {
          var values = config.line_connectNull
              ? $$.filterRemoveNull(d.values)
              : d.values, x = isSub ? $$.subX : $$.x, y = yScaleGetter.call($$, d.id), x0 = 0, y0 = 0, path;
          if ($$.isLineType(d)) {
              if (config.data_regions[d.id]) {
                  path = $$.lineWithRegions(values, x, y, config.data_regions[d.id]);
              }
              else {
                  if ($$.isStepType(d)) {
                      values = $$.convertValuesToStep(values);
                  }
                  path = line.curve($$.getInterpolate(d))(values);
              }
          }
          else {
              if (values[0]) {
                  x0 = x(values[0].x);
                  y0 = y(values[0].value);
              }
              path = config.axis_rotated ? 'M ' + y0 + ' ' + x0 : 'M ' + x0 + ' ' + y0;
          }
          return path ? path : 'M 0 0';
      };
  };
  ChartInternal.prototype.generateGetLinePoints = function (lineIndices, isSub) {
      // partial duplication of generateGetBarPoints
      var $$ = this, config = $$.config, lineTargetsNum = lineIndices.__max__ + 1, x = $$.getShapeX(0, lineTargetsNum, lineIndices, !!isSub), y = $$.getShapeY(!!isSub), lineOffset = $$.getShapeOffset($$.isLineType, lineIndices, !!isSub), yScale = isSub ? $$.getSubYScale : $$.getYScale;
      return function (d, i) {
          var y0 = yScale.call($$, d.id)(0), offset = lineOffset(d, i) || y0, // offset is for stacked area chart
          posX = x(d), posY = y(d);
          // fix posY not to overflow opposite quadrant
          if (config.axis_rotated) {
              if ((0 < d.value && posY < y0) || (d.value < 0 && y0 < posY)) {
                  posY = y0;
              }
          }
          // 1 point that marks the line position
          return [
              [posX, posY - (y0 - offset)],
              [posX, posY - (y0 - offset)],
              [posX, posY - (y0 - offset)],
              [posX, posY - (y0 - offset)] // needed for compatibility
          ];
      };
  };
  ChartInternal.prototype.lineWithRegions = function (d, x, y, _regions) {
      var $$ = this, config = $$.config, prev = -1, i, j, s = 'M', sWithRegion, xp, yp, dx, dy, dd, diff, diffx2, xOffset = $$.isCategorized() ? 0.5 : 0, xValue, yValue, regions = [];
      function isWithinRegions(x, regions) {
          var i;
          for (i = 0; i < regions.length; i++) {
              if (regions[i].start < x && x <= regions[i].end) {
                  return true;
              }
          }
          return false;
      }
      // Check start/end of regions
      if (isDefined(_regions)) {
          for (i = 0; i < _regions.length; i++) {
              regions[i] = {};
              if (isUndefined(_regions[i].start)) {
                  regions[i].start = d[0].x;
              }
              else {
                  regions[i].start = $$.isTimeSeries()
                      ? $$.parseDate(_regions[i].start)
                      : _regions[i].start;
              }
              if (isUndefined(_regions[i].end)) {
                  regions[i].end = d[d.length - 1].x;
              }
              else {
                  regions[i].end = $$.isTimeSeries()
                      ? $$.parseDate(_regions[i].end)
                      : _regions[i].end;
              }
          }
      }
      // Set scales
      xValue = config.axis_rotated
          ? function (d) {
              return y(d.value);
          }
          : function (d) {
              return x(d.x);
          };
      yValue = config.axis_rotated
          ? function (d) {
              return x(d.x);
          }
          : function (d) {
              return y(d.value);
          };
      // Define svg generator function for region
      function generateM(points) {
          return ('M' +
              points[0][0] +
              ' ' +
              points[0][1] +
              ' ' +
              points[1][0] +
              ' ' +
              points[1][1]);
      }
      if ($$.isTimeSeries()) {
          sWithRegion = function (d0, d1, j, diff) {
              var x0 = d0.x.getTime(), x_diff = d1.x - d0.x, xv0 = new Date(x0 + x_diff * j), xv1 = new Date(x0 + x_diff * (j + diff)), points;
              if (config.axis_rotated) {
                  points = [
                      [y(yp(j)), x(xv0)],
                      [y(yp(j + diff)), x(xv1)]
                  ];
              }
              else {
                  points = [
                      [x(xv0), y(yp(j))],
                      [x(xv1), y(yp(j + diff))]
                  ];
              }
              return generateM(points);
          };
      }
      else {
          sWithRegion = function (d0, d1, j, diff) {
              var points;
              if (config.axis_rotated) {
                  points = [
                      [y(yp(j), true), x(xp(j))],
                      [y(yp(j + diff), true), x(xp(j + diff))]
                  ];
              }
              else {
                  points = [
                      [x(xp(j), true), y(yp(j))],
                      [x(xp(j + diff), true), y(yp(j + diff))]
                  ];
              }
              return generateM(points);
          };
      }
      // Generate
      for (i = 0; i < d.length; i++) {
          // Draw as normal
          if (isUndefined(regions) || !isWithinRegions(d[i].x, regions)) {
              s += ' ' + xValue(d[i]) + ' ' + yValue(d[i]);
          }
          // Draw with region // TODO: Fix for horizotal charts
          else {
              xp = $$.getScale(d[i - 1].x + xOffset, d[i].x + xOffset, $$.isTimeSeries());
              yp = $$.getScale(d[i - 1].value, d[i].value);
              dx = x(d[i].x) - x(d[i - 1].x);
              dy = y(d[i].value) - y(d[i - 1].value);
              dd = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
              diff = 2 / dd;
              diffx2 = diff * 2;
              for (j = diff; j <= 1; j += diffx2) {
                  s += sWithRegion(d[i - 1], d[i], j, diff);
              }
          }
          prev = d[i].x;
      }
      return s;
  };
  ChartInternal.prototype.updateArea = function (durationForExit) {
      var $$ = this, d3 = $$.d3;
      var mainArea = $$.main
          .selectAll('.' + CLASS.areas)
          .selectAll('.' + CLASS.area)
          .data($$.lineData.bind($$));
      var mainAreaEnter = mainArea
          .enter()
          .append('path')
          .attr('class', $$.classArea.bind($$))
          .style('fill', $$.color)
          .style('opacity', function () {
          $$.orgAreaOpacity = +d3.select(this).style('opacity');
          return 0;
      });
      $$.mainArea = mainAreaEnter
          .merge(mainArea)
          .style('opacity', $$.orgAreaOpacity);
      mainArea
          .exit()
          .transition()
          .duration(durationForExit)
          .style('opacity', 0);
  };
  ChartInternal.prototype.redrawArea = function (drawArea, withTransition, transition) {
      return [
          (withTransition ? this.mainArea.transition(transition) : this.mainArea)
              .attr('d', drawArea)
              .style('fill', this.color)
              .style('opacity', this.orgAreaOpacity)
      ];
  };
  ChartInternal.prototype.generateDrawArea = function (areaIndices, isSub) {
      var $$ = this, config = $$.config, area = $$.d3.area(), getPoints = $$.generateGetAreaPoints(areaIndices, isSub), yScaleGetter = isSub ? $$.getSubYScale : $$.getYScale, xValue = function (d) {
          return (isSub ? $$.subxx : $$.xx).call($$, d);
      }, value0 = function (d, i) {
          return config.data_groups.length > 0
              ? getPoints(d, i)[0][1]
              : yScaleGetter.call($$, d.id)($$.getAreaBaseValue(d.id));
      }, value1 = function (d, i) {
          return config.data_groups.length > 0
              ? getPoints(d, i)[1][1]
              : yScaleGetter.call($$, d.id)(d.value);
      };
      area = config.axis_rotated
          ? area
              .x0(value0)
              .x1(value1)
              .y(xValue)
          : area
              .x(xValue)
              .y0(config.area_above ? 0 : value0)
              .y1(value1);
      if (!config.line_connectNull) {
          area = area.defined(function (d) {
              return d.value !== null;
          });
      }
      return function (d) {
          var values = config.line_connectNull
              ? $$.filterRemoveNull(d.values)
              : d.values, x0 = 0, y0 = 0, path;
          if ($$.isAreaType(d)) {
              if ($$.isStepType(d)) {
                  values = $$.convertValuesToStep(values);
              }
              path = area.curve($$.getInterpolate(d))(values);
          }
          else {
              if (values[0]) {
                  x0 = $$.x(values[0].x);
                  y0 = $$.getYScale(d.id)(values[0].value);
              }
              path = config.axis_rotated ? 'M ' + y0 + ' ' + x0 : 'M ' + x0 + ' ' + y0;
          }
          return path ? path : 'M 0 0';
      };
  };
  ChartInternal.prototype.getAreaBaseValue = function () {
      return 0;
  };
  ChartInternal.prototype.generateGetAreaPoints = function (areaIndices, isSub) {
      // partial duplication of generateGetBarPoints
      var $$ = this, config = $$.config, areaTargetsNum = areaIndices.__max__ + 1, x = $$.getShapeX(0, areaTargetsNum, areaIndices, !!isSub), y = $$.getShapeY(!!isSub), areaOffset = $$.getShapeOffset($$.isAreaType, areaIndices, !!isSub), yScale = isSub ? $$.getSubYScale : $$.getYScale;
      return function (d, i) {
          var y0 = yScale.call($$, d.id)(0), offset = areaOffset(d, i) || y0, // offset is for stacked area chart
          posX = x(d), posY = y(d);
          // fix posY not to overflow opposite quadrant
          if (config.axis_rotated) {
              if ((0 < d.value && posY < y0) || (d.value < 0 && y0 < posY)) {
                  posY = y0;
              }
          }
          // 1 point that marks the area position
          return [
              [posX, offset],
              [posX, posY - (y0 - offset)],
              [posX, posY - (y0 - offset)],
              [posX, offset] // needed for compatibility
          ];
      };
  };
  ChartInternal.prototype.updateCircle = function (cx, cy) {
      var $$ = this;
      var mainCircle = $$.main
          .selectAll('.' + CLASS.circles)
          .selectAll('.' + CLASS.circle)
          .data($$.lineOrScatterOrStanfordData.bind($$));
      var mainCircleEnter = mainCircle
          .enter()
          .append('circle')
          .attr('shape-rendering', $$.isStanfordGraphType() ? 'crispEdges' : '')
          .attr('class', $$.classCircle.bind($$))
          .attr('cx', cx)
          .attr('cy', cy)
          .attr('r', $$.pointR.bind($$))
          .style('color', $$.isStanfordGraphType() ? $$.getStanfordPointColor.bind($$) : $$.color);
      $$.mainCircle = mainCircleEnter
          .merge(mainCircle)
          .style('opacity', $$.isStanfordGraphType() ? 1 : $$.initialOpacityForCircle.bind($$));
      mainCircle.exit().style('opacity', 0);
  };
  ChartInternal.prototype.redrawCircle = function (cx, cy, withTransition, transition) {
      var $$ = this, selectedCircles = $$.main.selectAll('.' + CLASS.selectedCircle);
      return [
          (withTransition ? $$.mainCircle.transition(transition) : $$.mainCircle)
              .style('opacity', this.opacityForCircle.bind($$))
              .style('color', $$.isStanfordGraphType() ? $$.getStanfordPointColor.bind($$) : $$.color)
              .attr('cx', cx)
              .attr('cy', cy),
          (withTransition ? selectedCircles.transition(transition) : selectedCircles)
              .attr('cx', cx)
              .attr('cy', cy)
      ];
  };
  ChartInternal.prototype.circleX = function (d) {
      return d.x || d.x === 0 ? this.x(d.x) : null;
  };
  ChartInternal.prototype.updateCircleY = function () {
      var $$ = this, lineIndices, getPoints;
      if ($$.config.data_groups.length > 0) {
          (lineIndices = $$.getShapeIndices($$.isLineType)),
              (getPoints = $$.generateGetLinePoints(lineIndices));
          $$.circleY = function (d, i) {
              return getPoints(d, i)[0][1];
          };
      }
      else {
          $$.circleY = function (d) {
              return $$.getYScale(d.id)(d.value);
          };
      }
  };
  ChartInternal.prototype.getCircles = function (i, id) {
      var $$ = this;
      return (id
          ? $$.main.selectAll('.' + CLASS.circles + $$.getTargetSelectorSuffix(id))
          : $$.main).selectAll('.' + CLASS.circle + (isValue(i) ? '-' + i : ''));
  };
  ChartInternal.prototype.expandCircles = function (i, id, reset) {
      var $$ = this, r = $$.pointExpandedR.bind($$);
      if (reset) {
          $$.unexpandCircles();
      }
      $$.getCircles(i, id)
          .classed(CLASS.EXPANDED, true)
          .attr('r', r);
  };
  ChartInternal.prototype.unexpandCircles = function (i) {
      var $$ = this, r = $$.pointR.bind($$);
      $$.getCircles(i)
          .filter(function () {
          return $$.d3.select(this).classed(CLASS.EXPANDED);
      })
          .classed(CLASS.EXPANDED, false)
          .attr('r', r);
  };
  ChartInternal.prototype.pointR = function (d) {
      var $$ = this, config = $$.config;
      return $$.isStepType(d)
          ? 0
          : isFunction(config.point_r)
              ? config.point_r(d)
              : config.point_r;
  };
  ChartInternal.prototype.pointExpandedR = function (d) {
      var $$ = this, config = $$.config;
      if (config.point_focus_expand_enabled) {
          return isFunction(config.point_focus_expand_r)
              ? config.point_focus_expand_r(d)
              : config.point_focus_expand_r
                  ? config.point_focus_expand_r
                  : $$.pointR(d) * 1.75;
      }
      else {
          return $$.pointR(d);
      }
  };
  ChartInternal.prototype.pointSelectR = function (d) {
      var $$ = this, config = $$.config;
      return isFunction(config.point_select_r)
          ? config.point_select_r(d)
          : config.point_select_r
              ? config.point_select_r
              : $$.pointR(d) * 4;
  };
  ChartInternal.prototype.isWithinCircle = function (that, r) {
      var d3 = this.d3, mouse = d3.mouse(that), d3_this = d3.select(that), cx = +d3_this.attr('cx'), cy = +d3_this.attr('cy');
      return Math.sqrt(Math.pow(cx - mouse[0], 2) + Math.pow(cy - mouse[1], 2)) < r;
  };
  ChartInternal.prototype.isWithinStep = function (that, y) {
      return Math.abs(y - this.d3.mouse(that)[1]) < 30;
  };

  ChartInternal.prototype.getCurrentWidth = function () {
      var $$ = this, config = $$.config;
      return config.size_width ? config.size_width : $$.getParentWidth();
  };
  ChartInternal.prototype.getCurrentHeight = function () {
      var $$ = this, config = $$.config, h = config.size_height ? config.size_height : $$.getParentHeight();
      return h > 0
          ? h
          : 320 / ($$.hasType('gauge') && !config.gauge_fullCircle ? 2 : 1);
  };
  ChartInternal.prototype.getCurrentPaddingTop = function () {
      var $$ = this, config = $$.config, padding = isValue(config.padding_top) ? config.padding_top : 0;
      if ($$.title && $$.title.node()) {
          padding += $$.getTitlePadding();
      }
      return padding;
  };
  ChartInternal.prototype.getCurrentPaddingBottom = function () {
      var config = this.config;
      return isValue(config.padding_bottom) ? config.padding_bottom : 0;
  };
  ChartInternal.prototype.getCurrentPaddingLeft = function (withoutRecompute) {
      var $$ = this, config = $$.config;
      if (isValue(config.padding_left)) {
          return config.padding_left;
      }
      else if (config.axis_rotated) {
          return !config.axis_x_show || config.axis_x_inner
              ? 1
              : Math.max(ceil10($$.getAxisWidthByAxisId('x', withoutRecompute)), 40);
      }
      else if (!config.axis_y_show || config.axis_y_inner) {
          // && !config.axis_rotated
          return $$.axis.getYAxisLabelPosition().isOuter ? 30 : 1;
      }
      else {
          return ceil10($$.getAxisWidthByAxisId('y', withoutRecompute));
      }
  };
  ChartInternal.prototype.getCurrentPaddingRight = function () {
      var $$ = this, config = $$.config, padding = 0, defaultPadding = 10, legendWidthOnRight = $$.isLegendRight ? $$.getLegendWidth() + 20 : 0;
      if (isValue(config.padding_right)) {
          padding = config.padding_right + 1; // 1 is needed not to hide tick line
      }
      else if (config.axis_rotated) {
          padding = defaultPadding + legendWidthOnRight;
      }
      else if (!config.axis_y2_show || config.axis_y2_inner) {
          // && !config.axis_rotated
          padding =
              2 +
                  legendWidthOnRight +
                  ($$.axis.getY2AxisLabelPosition().isOuter ? 20 : 0);
      }
      else {
          padding = ceil10($$.getAxisWidthByAxisId('y2')) + legendWidthOnRight;
      }
      if ($$.colorScale && $$.colorScale.node()) {
          padding += $$.getColorScalePadding();
      }
      return padding;
  };
  ChartInternal.prototype.getParentRectValue = function (key) {
      var parent = this.selectChart.node(), v;
      while (parent && parent.tagName !== 'BODY') {
          try {
              v = parent.getBoundingClientRect()[key];
          }
          catch (e) {
              if (key === 'width') {
                  // In IE in certain cases getBoundingClientRect
                  // will cause an "unspecified error"
                  v = parent.offsetWidth;
              }
          }
          if (v) {
              break;
          }
          parent = parent.parentNode;
      }
      return v;
  };
  ChartInternal.prototype.getParentWidth = function () {
      return this.getParentRectValue('width');
  };
  ChartInternal.prototype.getParentHeight = function () {
      var h = this.selectChart.style('height');
      return h.indexOf('px') > 0 ? +h.replace('px', '') : 0;
  };
  ChartInternal.prototype.getSvgLeft = function (withoutRecompute) {
      var $$ = this, config = $$.config, hasLeftAxisRect = config.axis_rotated || (!config.axis_rotated && !config.axis_y_inner), leftAxisClass = config.axis_rotated ? CLASS.axisX : CLASS.axisY, leftAxis = $$.main.select('.' + leftAxisClass).node(), svgRect = leftAxis && hasLeftAxisRect
          ? leftAxis.getBoundingClientRect()
          : { right: 0 }, chartRect = $$.selectChart.node().getBoundingClientRect(), hasArc = $$.hasArcType(), svgLeft = svgRect.right -
          chartRect.left -
          (hasArc ? 0 : $$.getCurrentPaddingLeft(withoutRecompute));
      return svgLeft > 0 ? svgLeft : 0;
  };
  ChartInternal.prototype.getAxisWidthByAxisId = function (id, withoutRecompute) {
      var $$ = this, position = $$.axis.getLabelPositionById(id);
      return ($$.axis.getMaxTickWidth(id, withoutRecompute) + (position.isInner ? 20 : 40));
  };
  ChartInternal.prototype.getHorizontalAxisHeight = function (axisId, isSubchart) {
      var $$ = this, config = $$.config, h = 30;
      if (axisId === 'x' && !(isDefined(isSubchart) && isSubchart ? config.subchart_axis_x_show : config.axis_x_show)) {
          return 8;
      }
      if (axisId === 'x' && config.axis_x_height) {
          return config.axis_x_height;
      }
      if (axisId === 'y' && !config.axis_y_show) {
          return config.legend_show && !$$.isLegendRight && !$$.isLegendInset ? 10 : 1;
      }
      if (axisId === 'y2' && !config.axis_y2_show) {
          return $$.rotated_padding_top;
      }
      // Calculate x axis height when tick rotated
      if (axisId === 'x' && !config.axis_rotated && config.axis_x_tick_rotate) {
          h =
              30 +
                  $$.axis.getMaxTickWidth(axisId) *
                      Math.cos((Math.PI * (90 - Math.abs(config.axis_x_tick_rotate))) / 180);
      }
      // Calculate y axis height when tick rotated
      if (axisId === 'y' && config.axis_rotated && config.axis_y_tick_rotate) {
          h =
              30 +
                  $$.axis.getMaxTickWidth(axisId) *
                      Math.cos((Math.PI * (90 - Math.abs(config.axis_y_tick_rotate))) / 180);
      }
      return (h +
          ($$.axis.getLabelPositionById(axisId).isInner ? 0 : 10) +
          (axisId === 'y2' ? -10 : 0));
  };

  ChartInternal.prototype.initBrush = function (scale) {
      var $$ = this, d3 = $$.d3;
      // TODO: dynamically change brushY/brushX according to axis_rotated.
      $$.brush = ($$.config.axis_rotated ? d3.brushY() : d3.brushX())
          .on('brush', function () {
          var event = d3.event.sourceEvent;
          if (event && event.type === 'zoom') {
              return;
          }
          $$.redrawForBrush();
      })
          .on('end', function () {
          var event = d3.event.sourceEvent;
          if (event && event.type === 'zoom') {
              return;
          }
          if ($$.brush.empty() && event && event.type !== 'end') {
              $$.brush.clear();
          }
      });
      $$.brush.updateExtent = function () {
          var range = this.scale.range(), extent;
          if ($$.config.axis_rotated) {
              extent = [
                  [0, range[0]],
                  [$$.width2, range[1]]
              ];
          }
          else {
              extent = [
                  [range[0], 0],
                  [range[1], $$.height2]
              ];
          }
          this.extent(extent);
          return this;
      };
      $$.brush.updateScale = function (scale) {
          this.scale = scale;
          return this;
      };
      $$.brush.update = function (scale) {
          this.updateScale(scale || $$.subX).updateExtent();
          $$.context.select('.' + CLASS.brush).call(this);
      };
      $$.brush.clear = function () {
          $$.context.select('.' + CLASS.brush).call($$.brush.move, null);
      };
      $$.brush.selection = function () {
          return d3.brushSelection($$.context.select('.' + CLASS.brush).node());
      };
      $$.brush.selectionAsValue = function (selectionAsValue, withTransition) {
          var selection, brush;
          if (selectionAsValue) {
              if ($$.context) {
                  selection = [
                      this.scale(selectionAsValue[0]),
                      this.scale(selectionAsValue[1])
                  ];
                  brush = $$.context.select('.' + CLASS.brush);
                  if (withTransition) {
                      brush = brush.transition();
                  }
                  $$.brush.move(brush, selection);
              }
              return [];
          }
          selection = $$.brush.selection() || [0, 0];
          return [this.scale.invert(selection[0]), this.scale.invert(selection[1])];
      };
      $$.brush.empty = function () {
          var selection = $$.brush.selection();
          return !selection || selection[0] === selection[1];
      };
      return $$.brush.updateScale(scale);
  };
  ChartInternal.prototype.initSubchart = function () {
      var $$ = this, config = $$.config, context = ($$.context = $$.svg
          .append('g')
          .attr('transform', $$.getTranslate('context')));
      // set style
      context.style('visibility', 'visible');
      // Define g for chart area
      context
          .append('g')
          .attr('clip-path', $$.clipPathForSubchart)
          .attr('class', CLASS.chart);
      // Define g for bar chart area
      context
          .select('.' + CLASS.chart)
          .append('g')
          .attr('class', CLASS.chartBars);
      // Define g for line chart area
      context
          .select('.' + CLASS.chart)
          .append('g')
          .attr('class', CLASS.chartLines);
      // Add extent rect for Brush
      context
          .append('g')
          .attr('clip-path', $$.clipPath)
          .attr('class', CLASS.brush);
      // ATTENTION: This must be called AFTER chart added
      // Add Axis
      $$.axes.subx = context
          .append('g')
          .attr('class', CLASS.axisX)
          .attr('transform', $$.getTranslate('subx'))
          .attr('clip-path', config.axis_rotated ? '' : $$.clipPathForXAxis)
          .style('visibility', config.subchart_axis_x_show ? 'visible' : 'hidden');
  };
  ChartInternal.prototype.initSubchartBrush = function () {
      var $$ = this;
      // Add extent rect for Brush
      $$.initBrush($$.subX).updateExtent();
      $$.context.select('.' + CLASS.brush).call($$.brush);
  };
  ChartInternal.prototype.updateTargetsForSubchart = function (targets) {
      var $$ = this, context = $$.context, config = $$.config, contextLineEnter, contextLine, contextBarEnter, contextBar, classChartBar = $$.classChartBar.bind($$), classBars = $$.classBars.bind($$), classChartLine = $$.classChartLine.bind($$), classLines = $$.classLines.bind($$), classAreas = $$.classAreas.bind($$);
      //-- Bar --//
      contextBar = context
          .select('.' + CLASS.chartBars)
          .selectAll('.' + CLASS.chartBar)
          .data(targets);
      contextBarEnter = contextBar
          .enter()
          .append('g')
          .style('opacity', 0);
      contextBarEnter.merge(contextBar).attr('class', classChartBar);
      // Bars for each data
      contextBarEnter.append('g').attr('class', classBars);
      //-- Line --//
      contextLine = context
          .select('.' + CLASS.chartLines)
          .selectAll('.' + CLASS.chartLine)
          .data(targets);
      contextLineEnter = contextLine
          .enter()
          .append('g')
          .style('opacity', 0);
      contextLineEnter.merge(contextLine).attr('class', classChartLine);
      // Lines for each data
      contextLineEnter.append('g').attr('class', classLines);
      // Area
      contextLineEnter.append('g').attr('class', classAreas);
      //-- Brush --//
      context
          .selectAll('.' + CLASS.brush + ' rect')
          .attr(config.axis_rotated ? 'width' : 'height', config.axis_rotated ? $$.width2 : $$.height2);
  };
  ChartInternal.prototype.updateBarForSubchart = function (durationForExit) {
      var $$ = this;
      var contextBar = $$.context
          .selectAll('.' + CLASS.bars)
          .selectAll('.' + CLASS.bar)
          .data($$.barData.bind($$));
      var contextBarEnter = contextBar
          .enter()
          .append('path')
          .attr('class', $$.classBar.bind($$))
          .style('stroke', 'none')
          .style('fill', $$.color);
      contextBar
          .exit()
          .transition()
          .duration(durationForExit)
          .style('opacity', 0)
          .remove();
      $$.contextBar = contextBarEnter
          .merge(contextBar)
          .style('opacity', $$.initialOpacity.bind($$));
  };
  ChartInternal.prototype.redrawBarForSubchart = function (drawBarOnSub, withTransition, duration) {
      (withTransition
          ? this.contextBar.transition(Math.random().toString()).duration(duration)
          : this.contextBar)
          .attr('d', drawBarOnSub)
          .style('opacity', 1);
  };
  ChartInternal.prototype.updateLineForSubchart = function (durationForExit) {
      var $$ = this;
      var contextLine = $$.context
          .selectAll('.' + CLASS.lines)
          .selectAll('.' + CLASS.line)
          .data($$.lineData.bind($$));
      var contextLineEnter = contextLine
          .enter()
          .append('path')
          .attr('class', $$.classLine.bind($$))
          .style('stroke', $$.color);
      contextLine
          .exit()
          .transition()
          .duration(durationForExit)
          .style('opacity', 0)
          .remove();
      $$.contextLine = contextLineEnter
          .merge(contextLine)
          .style('opacity', $$.initialOpacity.bind($$));
  };
  ChartInternal.prototype.redrawLineForSubchart = function (drawLineOnSub, withTransition, duration) {
      (withTransition
          ? this.contextLine.transition(Math.random().toString()).duration(duration)
          : this.contextLine)
          .attr('d', drawLineOnSub)
          .style('opacity', 1);
  };
  ChartInternal.prototype.updateAreaForSubchart = function (durationForExit) {
      var $$ = this, d3 = $$.d3;
      var contextArea = $$.context
          .selectAll('.' + CLASS.areas)
          .selectAll('.' + CLASS.area)
          .data($$.lineData.bind($$));
      var contextAreaEnter = contextArea
          .enter()
          .append('path')
          .attr('class', $$.classArea.bind($$))
          .style('fill', $$.color)
          .style('opacity', function () {
          $$.orgAreaOpacity = +d3.select(this).style('opacity');
          return 0;
      });
      contextArea
          .exit()
          .transition()
          .duration(durationForExit)
          .style('opacity', 0)
          .remove();
      $$.contextArea = contextAreaEnter.merge(contextArea).style('opacity', 0);
  };
  ChartInternal.prototype.redrawAreaForSubchart = function (drawAreaOnSub, withTransition, duration) {
      (withTransition
          ? this.contextArea.transition(Math.random().toString()).duration(duration)
          : this.contextArea)
          .attr('d', drawAreaOnSub)
          .style('fill', this.color)
          .style('opacity', this.orgAreaOpacity);
  };
  ChartInternal.prototype.redrawSubchart = function (withSubchart, transitions, duration, durationForExit, areaIndices, barIndices, lineIndices) {
      var $$ = this, d3 = $$.d3, drawAreaOnSub, drawBarOnSub, drawLineOnSub;
      // reflect main chart to extent on subchart if zoomed
      if (d3.event && d3.event.type === 'zoom') {
          $$.brush.selectionAsValue($$.x.orgDomain());
      }
      // update subchart elements if needed
      if (withSubchart) {
          // extent rect
          if (!$$.brush.empty()) {
              $$.brush.selectionAsValue($$.x.orgDomain());
          }
          // setup drawer - MEMO: this must be called after axis updated
          drawAreaOnSub = $$.generateDrawArea(areaIndices, true);
          drawBarOnSub = $$.generateDrawBar(barIndices, true);
          drawLineOnSub = $$.generateDrawLine(lineIndices, true);
          $$.updateBarForSubchart(duration);
          $$.updateLineForSubchart(duration);
          $$.updateAreaForSubchart(duration);
          $$.redrawBarForSubchart(drawBarOnSub, duration, duration);
          $$.redrawLineForSubchart(drawLineOnSub, duration, duration);
          $$.redrawAreaForSubchart(drawAreaOnSub, duration, duration);
      }
  };
  ChartInternal.prototype.redrawForBrush = function () {
      var $$ = this, x = $$.x, d3 = $$.d3, s;
      $$.redraw({
          withTransition: false,
          withY: $$.config.zoom_rescale,
          withSubchart: false,
          withUpdateXDomain: true,
          withEventRect: false,
          withDimension: false
      });
      // update zoom transation binded to event rect
      s = d3.event.selection || $$.brush.scale.range();
      $$.main
          .select('.' + CLASS.eventRect)
          .call($$.zoom.transform, d3.zoomIdentity.scale($$.width / (s[1] - s[0])).translate(-s[0], 0));
      $$.config.subchart_onbrush.call($$.api, x.orgDomain());
  };
  ChartInternal.prototype.transformContext = function (withTransition, transitions) {
      var $$ = this, subXAxis;
      if (transitions && transitions.axisSubX) {
          subXAxis = transitions.axisSubX;
      }
      else {
          subXAxis = $$.context.select('.' + CLASS.axisX);
          if (withTransition) {
              subXAxis = subXAxis.transition();
          }
      }
      $$.context.attr('transform', $$.getTranslate('context'));
      subXAxis.attr('transform', $$.getTranslate('subx'));
  };
  ChartInternal.prototype.getDefaultSelection = function () {
      var $$ = this, config = $$.config, selection = isFunction(config.axis_x_selection)
          ? config.axis_x_selection($$.getXDomain($$.data.targets))
          : config.axis_x_selection;
      if ($$.isTimeSeries()) {
          selection = [$$.parseDate(selection[0]), $$.parseDate(selection[1])];
      }
      return selection;
  };
  ChartInternal.prototype.removeSubchart = function () {
      var $$ = this;
      $$.brush = null;
      $$.context.remove();
      $$.context = null;
  };

  ChartInternal.prototype.initText = function () {
      var $$ = this;
      $$.main
          .select('.' + CLASS.chart)
          .append('g')
          .attr('class', CLASS.chartTexts);
      $$.mainText = $$.d3.selectAll([]);
  };
  ChartInternal.prototype.updateTargetsForText = function (targets) {
      var $$ = this, classChartText = $$.classChartText.bind($$), classTexts = $$.classTexts.bind($$), classFocus = $$.classFocus.bind($$);
      var mainText = $$.main
          .select('.' + CLASS.chartTexts)
          .selectAll('.' + CLASS.chartText)
          .data(targets);
      var mainTextEnter = mainText
          .enter()
          .append('g')
          .attr('class', classChartText)
          .style('opacity', 0)
          .style('pointer-events', 'none');
      mainTextEnter.append('g').attr('class', classTexts);
      mainTextEnter.merge(mainText).attr('class', function (d) {
          return classChartText(d) + classFocus(d);
      });
  };
  ChartInternal.prototype.updateText = function (xForText, yForText, durationForExit) {
      var $$ = this, config = $$.config, barOrLineData = $$.barOrLineData.bind($$), classText = $$.classText.bind($$);
      var mainText = $$.main
          .selectAll('.' + CLASS.texts)
          .selectAll('.' + CLASS.text)
          .data(barOrLineData);
      var mainTextEnter = mainText
          .enter()
          .append('text')
          .attr('class', classText)
          .attr('text-anchor', function (d) {
          return config.axis_rotated ? (d.value < 0 ? 'end' : 'start') : 'middle';
      })
          .style('stroke', 'none')
          .attr('x', xForText)
          .attr('y', yForText)
          .style('fill', function (d) {
          return $$.color(d);
      })
          .style('fill-opacity', 0);
      $$.mainText = mainTextEnter.merge(mainText).text(function (d, i, j) {
          return $$.dataLabelFormat(d.id)(d.value, d.id, i, j);
      });
      mainText
          .exit()
          .transition()
          .duration(durationForExit)
          .style('fill-opacity', 0)
          .remove();
  };
  ChartInternal.prototype.redrawText = function (xForText, yForText, forFlow, withTransition, transition) {
      return [
          (withTransition ? this.mainText.transition(transition) : this.mainText)
              .attr('x', xForText)
              .attr('y', yForText)
              .style('fill', this.color)
              .style('fill-opacity', forFlow ? 0 : this.opacityForText.bind(this))
      ];
  };
  ChartInternal.prototype.getTextRect = function (text, cls, element) {
      var dummy = this.d3
          .select('body')
          .append('div')
          .classed('c3', true), svg = dummy
          .append('svg')
          .style('visibility', 'hidden')
          .style('position', 'fixed')
          .style('top', 0)
          .style('left', 0), font = this.d3.select(element).style('font'), rect;
      svg
          .selectAll('.dummy')
          .data([text])
          .enter()
          .append('text')
          .classed(cls ? cls : '', true)
          .style('font', font)
          .text(text)
          .each(function () {
          rect = getBBox(this);
      });
      dummy.remove();
      return rect;
  };
  ChartInternal.prototype.generateXYForText = function (areaIndices, barIndices, lineIndices, forX) {
      var $$ = this, getAreaPoints = $$.generateGetAreaPoints(areaIndices, false), getBarPoints = $$.generateGetBarPoints(barIndices, false), getLinePoints = $$.generateGetLinePoints(lineIndices, false), getter = forX ? $$.getXForText : $$.getYForText;
      return function (d, i) {
          var getPoints = $$.isAreaType(d)
              ? getAreaPoints
              : $$.isBarType(d)
                  ? getBarPoints
                  : getLinePoints;
          return getter.call($$, getPoints(d, i), d, this);
      };
  };
  ChartInternal.prototype.getXForText = function (points, d, textElement) {
      var $$ = this, box = getBBox(textElement), xPos, padding;
      if ($$.config.axis_rotated) {
          padding = $$.isBarType(d) ? 4 : 6;
          xPos = points[2][1] + padding * (d.value < 0 ? -1 : 1);
      }
      else {
          xPos = $$.hasType('bar') ? (points[2][0] + points[0][0]) / 2 : points[0][0];
      }
      // show labels regardless of the domain if value is null
      if (d.value === null) {
          if (xPos > $$.width) {
              xPos = $$.width - box.width;
          }
          else if (xPos < 0) {
              xPos = 4;
          }
      }
      return xPos;
  };
  ChartInternal.prototype.getYForText = function (points, d, textElement) {
      var $$ = this, box = getBBox(textElement), yPos;
      if ($$.config.axis_rotated) {
          yPos = (points[0][0] + points[2][0] + box.height * 0.6) / 2;
      }
      else {
          yPos = points[2][1];
          if (d.value < 0 || (d.value === 0 && !$$.hasPositiveValue)) {
              yPos += box.height;
              if ($$.isBarType(d) && $$.isSafari()) {
                  yPos -= 3;
              }
              else if (!$$.isBarType(d) && $$.isChrome()) {
                  yPos += 3;
              }
          }
          else {
              yPos += $$.isBarType(d) ? -3 : -6;
          }
      }
      // show labels regardless of the domain if value is null
      if (d.value === null && !$$.config.axis_rotated) {
          if (yPos < box.height) {
              yPos = box.height;
          }
          else if (yPos > this.height) {
              yPos = this.height - 4;
          }
      }
      return yPos;
  };

  ChartInternal.prototype.initTitle = function () {
      var $$ = this;
      $$.title = $$.svg
          .append('text')
          .text($$.config.title_text)
          .attr('class', $$.CLASS.title);
  };
  ChartInternal.prototype.redrawTitle = function () {
      var $$ = this;
      $$.title.attr('x', $$.xForTitle.bind($$)).attr('y', $$.yForTitle.bind($$));
  };
  ChartInternal.prototype.xForTitle = function () {
      var $$ = this, config = $$.config, position = config.title_position || 'left', x;
      if (position.indexOf('right') >= 0) {
          x =
              $$.currentWidth -
                  $$.getTextRect($$.title.node().textContent, $$.CLASS.title, $$.title.node()).width -
                  config.title_padding.right;
      }
      else if (position.indexOf('center') >= 0) {
          x = Math.max(($$.currentWidth -
              $$.getTextRect($$.title.node().textContent, $$.CLASS.title, $$.title.node()).width) /
              2, 0);
      }
      else {
          // left
          x = config.title_padding.left;
      }
      return x;
  };
  ChartInternal.prototype.yForTitle = function () {
      var $$ = this;
      return ($$.config.title_padding.top +
          $$.getTextRect($$.title.node().textContent, $$.CLASS.title, $$.title.node())
              .height);
  };
  ChartInternal.prototype.getTitlePadding = function () {
      var $$ = this;
      return $$.yForTitle() + $$.config.title_padding.bottom;
  };

  function powerOfTen(d) {
      return d / Math.pow(10, Math.ceil(Math.log(d) / Math.LN10 - 1e-12)) === 1;
  }
  ChartInternal.prototype.drawColorScale = function () {
      var $$ = this, d3 = $$.d3, config = $$.config, target = $$.data.targets[0], barWidth, barHeight, axis, points, legendAxis, axisScale, inverseScale, height;
      barWidth = !isNaN(config.stanford_scaleWidth)
          ? config.stanford_scaleWidth
          : 20;
      barHeight = 5;
      if (barHeight < 0 || barWidth < 0) {
          throw Error("Colorscale's barheight and barwidth must be greater than 0.");
      }
      height =
          $$.height - config.stanford_padding.bottom - config.stanford_padding.top;
      points = d3.range(config.stanford_padding.bottom, height, barHeight);
      inverseScale = d3
          .scaleSequential(target.colors)
          .domain([points[points.length - 1], points[0]]);
      if ($$.colorScale) {
          $$.colorScale.remove();
      }
      $$.colorScale = $$.svg
          .append('g')
          .attr('width', 50)
          .attr('height', height)
          .attr('class', CLASS.colorScale);
      $$.colorScale
          .append('g')
          .attr('transform', "translate(0, " + config.stanford_padding.top + ")")
          .selectAll('bars')
          .data(points)
          .enter()
          .append('rect')
          .attr('y', function (d, i) { return i * barHeight; })
          .attr('x', 0)
          .attr('width', barWidth)
          .attr('height', barHeight)
          .attr('fill', function (d) {
          return inverseScale(d);
      });
      // Legend Axis
      axisScale = d3
          .scaleLog()
          .domain([target.minEpochs, target.maxEpochs])
          .range([
          points[0] +
              config.stanford_padding.top +
              points[points.length - 1] +
              barHeight -
              1,
          points[0] + config.stanford_padding.top
      ]);
      legendAxis = d3.axisRight(axisScale);
      if (config.stanford_scaleFormat === 'pow10') {
          legendAxis.tickValues([1, 10, 100, 1000, 10000, 100000, 1000000, 10000000]);
      }
      else if (isFunction(config.stanford_scaleFormat)) {
          legendAxis.tickFormat(config.stanford_scaleFormat);
      }
      else {
          legendAxis.tickFormat(d3.format('d'));
      }
      if (isFunction(config.stanford_scaleValues)) {
          legendAxis.tickValues(config.stanford_scaleValues(target.minEpochs, target.maxEpochs));
      }
      // Draw Axis
      axis = $$.colorScale
          .append('g')
          .attr('class', 'legend axis')
          .attr('transform', "translate(" + barWidth + ",0)")
          .call(legendAxis);
      if (config.stanford_scaleFormat === 'pow10') {
          axis
              .selectAll('.tick text')
              .text(null)
              .filter(powerOfTen)
              .text(10)
              .append('tspan')
              .attr('dy', '-.7em') // https://bl.ocks.org/mbostock/6738229
              .text(function (d) {
              return Math.round(Math.log(d) / Math.LN10);
          });
      }
      $$.colorScale.attr('transform', "translate(" + ($$.currentWidth - $$.xForColorScale()) + ", 0)");
  };
  ChartInternal.prototype.xForColorScale = function () {
      var $$ = this;
      return $$.config.stanford_padding.right + getBBox($$.colorScale.node()).width;
  };
  ChartInternal.prototype.getColorScalePadding = function () {
      var $$ = this;
      return $$.xForColorScale() + $$.config.stanford_padding.left + 20;
  };

  ChartInternal.prototype.isStanfordGraphType = function () {
      var $$ = this;
      return $$.config.data_type === 'stanford';
  };
  ChartInternal.prototype.initStanfordData = function () {
      var $$ = this, d3 = $$.d3, config = $$.config, target = $$.data.targets[0], epochs, maxEpochs, minEpochs;
      // Make larger values appear on top
      target.values.sort(compareEpochs);
      // Get array of epochs
      epochs = target.values.map(function (a) { return a.epochs; });
      minEpochs = !isNaN(config.stanford_scaleMin)
          ? config.stanford_scaleMin
          : d3.min(epochs);
      maxEpochs = !isNaN(config.stanford_scaleMax)
          ? config.stanford_scaleMax
          : d3.max(epochs);
      if (minEpochs > maxEpochs) {
          throw Error('Number of minEpochs has to be smaller than maxEpochs');
      }
      target.colors = isFunction(config.stanford_colors)
          ? config.stanford_colors
          : d3.interpolateHslLong(d3.hsl(250, 1, 0.5), d3.hsl(0, 1, 0.5));
      target.colorscale = d3
          .scaleSequentialLog(target.colors)
          .domain([minEpochs, maxEpochs]);
      target.minEpochs = minEpochs;
      target.maxEpochs = maxEpochs;
  };
  ChartInternal.prototype.getStanfordPointColor = function (d) {
      var $$ = this, target = $$.data.targets[0];
      return target.colorscale(d.epochs);
  };
  // http://jsfiddle.net/Xotic750/KtzLq/
  ChartInternal.prototype.getCentroid = function (points) {
      var area = getRegionArea(points);
      var x = 0, y = 0, i, j, f, point1, point2;
      for (i = 0, j = points.length - 1; i < points.length; j = i, i += 1) {
          point1 = points[i];
          point2 = points[j];
          f = point1.x * point2.y - point2.x * point1.y;
          x += (point1.x + point2.x) * f;
          y += (point1.y + point2.y) * f;
      }
      f = area * 6;
      return {
          x: x / f,
          y: y / f
      };
  };
  ChartInternal.prototype.getStanfordTooltipTitle = function (d) {
      var $$ = this, labelX = $$.axis.getLabelText('x'), labelY = $$.axis.getLabelText('y');
      return "\n      <tr><th>" + (labelX ? sanitise(labelX) : 'x') + "</th><th class='value'>" + d.x + "</th></tr>\n      <tr><th>" + (labelY ? sanitise(labelY) : 'y') + "</th><th class='value'>" + d.value + "</th></tr>\n    ";
  };
  ChartInternal.prototype.countEpochsInRegion = function (region) {
      var $$ = this, target = $$.data.targets[0], total, count;
      total = target.values.reduce(function (accumulator, currentValue) { return accumulator + Number(currentValue.epochs); }, 0);
      count = target.values.reduce(function (accumulator, currentValue) {
          if (pointInRegion(currentValue, region)) {
              return accumulator + Number(currentValue.epochs);
          }
          return accumulator;
      }, 0);
      return {
          value: count,
          percentage: count !== 0 ? ((count / total) * 100).toFixed(1) : 0
      };
  };
  var getRegionArea = function (points) {
      // thanks to: https://stackoverflow.com/questions/16282330/find-centerpoint-of-polygon-in-javascript
      var area = 0, i, j, point1, point2;
      for (i = 0, j = points.length - 1; i < points.length; j = i, i += 1) {
          point1 = points[i];
          point2 = points[j];
          area += point1.x * point2.y;
          area -= point1.y * point2.x;
      }
      area /= 2;
      return area;
  };
  var pointInRegion = function (point, region) {
      // thanks to: http://bl.ocks.org/bycoffe/5575904
      // ray-casting algorithm based on
      // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
      var xi, yi, yj, xj, intersect, x = point.x, y = point.value, inside = false;
      for (var i = 0, j = region.length - 1; i < region.length; j = i++) {
          xi = region[i].x;
          yi = region[i].y;
          xj = region[j].x;
          yj = region[j].y;
          intersect = yi > y !== yj > y && x < ((xj - xi) * (y - yi)) / (yj - yi) + xi;
          if (intersect) {
              inside = !inside;
          }
      }
      return inside;
  };
  var compareEpochs = function (a, b) {
      if (a.epochs < b.epochs) {
          return -1;
      }
      if (a.epochs > b.epochs) {
          return 1;
      }
      return 0;
  };

  ChartInternal.prototype.initStanfordElements = function () {
      var $$ = this;
      // Avoid blocking eventRect
      $$.stanfordElements = $$.main
          .select('.' + CLASS.chart)
          .append('g')
          .attr('class', CLASS.stanfordElements);
      $$.stanfordElements.append('g').attr('class', CLASS.stanfordLines);
      $$.stanfordElements.append('g').attr('class', CLASS.stanfordTexts);
      $$.stanfordElements.append('g').attr('class', CLASS.stanfordRegions);
  };
  ChartInternal.prototype.updateStanfordElements = function (duration) {
      var $$ = this, main = $$.main, config = $$.config, stanfordLine, stanfordLineEnter, stanfordRegion, stanfordRegionEnter, stanfordText, stanfordTextEnter, xvCustom = $$.xvCustom.bind($$), yvCustom = $$.yvCustom.bind($$), countPointsInRegion = $$.countEpochsInRegion.bind($$);
      // Stanford-Lines
      stanfordLine = main
          .select('.' + CLASS.stanfordLines)
          .style('shape-rendering', 'geometricprecision')
          .selectAll('.' + CLASS.stanfordLine)
          .data(config.stanford_lines);
      // enter
      stanfordLineEnter = stanfordLine
          .enter()
          .append('g')
          .attr('class', function (d) {
          return CLASS.stanfordLine + (d['class'] ? ' ' + d['class'] : '');
      });
      stanfordLineEnter
          .append('line')
          .attr('x1', function (d) {
          return config.axis_rotated ? yvCustom(d, 'value_y1') : xvCustom(d, 'value_x1');
      })
          .attr('x2', function (d) {
          return config.axis_rotated ? yvCustom(d, 'value_y2') : xvCustom(d, 'value_x2');
      })
          .attr('y1', function (d) {
          return config.axis_rotated ? xvCustom(d, 'value_x1') : yvCustom(d, 'value_y1');
      })
          .attr('y2', function (d) {
          return config.axis_rotated ? xvCustom(d, 'value_x2') : yvCustom(d, 'value_y2');
      })
          .style('opacity', 0);
      // update
      $$.stanfordLines = stanfordLineEnter.merge(stanfordLine);
      $$.stanfordLines
          .select('line')
          .transition()
          .duration(duration)
          .attr('x1', function (d) {
          return config.axis_rotated ? yvCustom(d, 'value_y1') : xvCustom(d, 'value_x1');
      })
          .attr('x2', function (d) {
          return config.axis_rotated ? yvCustom(d, 'value_y2') : xvCustom(d, 'value_x2');
      })
          .attr('y1', function (d) {
          return config.axis_rotated ? xvCustom(d, 'value_x1') : yvCustom(d, 'value_y1');
      })
          .attr('y2', function (d) {
          return config.axis_rotated ? xvCustom(d, 'value_x2') : yvCustom(d, 'value_y2');
      })
          .style('opacity', 1);
      // exit
      stanfordLine
          .exit()
          .transition()
          .duration(duration)
          .style('opacity', 0)
          .remove();
      // Stanford-Text
      stanfordText = main
          .select('.' + CLASS.stanfordTexts)
          .selectAll('.' + CLASS.stanfordText)
          .data(config.stanford_texts);
      // enter
      stanfordTextEnter = stanfordText
          .enter()
          .append('g')
          .attr('class', function (d) {
          return CLASS.stanfordText + (d['class'] ? ' ' + d['class'] : '');
      });
      stanfordTextEnter
          .append('text')
          .attr('x', function (d) { return (config.axis_rotated ? yvCustom(d, 'y') : xvCustom(d, 'x')); })
          .attr('y', function (d) { return (config.axis_rotated ? xvCustom(d, 'x') : yvCustom(d, 'y')); })
          .style('opacity', 0);
      // update
      $$.stanfordTexts = stanfordTextEnter.merge(stanfordText);
      $$.stanfordTexts
          .select('text')
          .transition()
          .duration(duration)
          .attr('x', function (d) { return (config.axis_rotated ? yvCustom(d, 'y') : xvCustom(d, 'x')); })
          .attr('y', function (d) { return (config.axis_rotated ? xvCustom(d, 'x') : yvCustom(d, 'y')); })
          .text(function (d) {
          return d.content;
      })
          .style('opacity', 1);
      // exit
      stanfordText
          .exit()
          .transition()
          .duration(duration)
          .style('opacity', 0)
          .remove();
      // Stanford-Regions
      stanfordRegion = main
          .select('.' + CLASS.stanfordRegions)
          .selectAll('.' + CLASS.stanfordRegion)
          .data(config.stanford_regions);
      // enter
      stanfordRegionEnter = stanfordRegion
          .enter()
          .append('g')
          .attr('class', function (d) {
          return CLASS.stanfordRegion + (d['class'] ? ' ' + d['class'] : '');
      });
      stanfordRegionEnter
          .append('polygon')
          .attr('points', function (d) {
          return d.points
              .map(function (value) {
              return [
                  config.axis_rotated ? yvCustom(value, 'y') : xvCustom(value, 'x'),
                  config.axis_rotated ? xvCustom(value, 'x') : yvCustom(value, 'y')
              ].join(',');
          })
              .join(' ');
      })
          .style('opacity', 0);
      stanfordRegionEnter
          .append('text')
          .attr('x', function (d) { return $$.getCentroid(d.points).x; })
          .attr('y', function (d) { return $$.getCentroid(d.points).y; })
          .style('opacity', 0);
      // update
      $$.stanfordRegions = stanfordRegionEnter.merge(stanfordRegion);
      $$.stanfordRegions
          .select('polygon')
          .transition()
          .duration(duration)
          .attr('points', function (d) {
          return d.points
              .map(function (value) {
              return [
                  config.axis_rotated ? yvCustom(value, 'y') : xvCustom(value, 'x'),
                  config.axis_rotated ? xvCustom(value, 'x') : yvCustom(value, 'y')
              ].join(',');
          })
              .join(' ');
      })
          .style('opacity', function (d) {
          return d.opacity ? d.opacity : 0.2;
      });
      $$.stanfordRegions
          .select('text')
          .transition()
          .duration(duration)
          .attr('x', function (d) {
          return config.axis_rotated
              ? yvCustom($$.getCentroid(d.points), 'y')
              : xvCustom($$.getCentroid(d.points), 'x');
      })
          .attr('y', function (d) {
          return config.axis_rotated
              ? xvCustom($$.getCentroid(d.points), 'x')
              : yvCustom($$.getCentroid(d.points), 'y');
      })
          .text(function (d) {
          if (d.text) {
              var value, percentage, temp;
              if ($$.isStanfordGraphType()) {
                  temp = countPointsInRegion(d.points);
                  value = temp.value;
                  percentage = temp.percentage;
              }
              return d.text(value, percentage);
          }
          return '';
      })
          .attr('text-anchor', 'middle')
          .attr('dominant-baseline', 'middle')
          .style('opacity', 1);
      // exit
      stanfordRegion
          .exit()
          .transition()
          .duration(duration)
          .style('opacity', 0)
          .remove();
  };

  ChartInternal.prototype.initTooltip = function () {
      var $$ = this, config = $$.config, i;
      $$.tooltip = $$.selectChart
          .style('position', 'relative')
          .append('div')
          .attr('class', CLASS.tooltipContainer)
          .style('position', 'absolute')
          .style('pointer-events', 'none')
          .style('display', 'none');
      // Show tooltip if needed
      if (config.tooltip_init_show) {
          if ($$.isTimeSeries() && isString(config.tooltip_init_x)) {
              config.tooltip_init_x = $$.parseDate(config.tooltip_init_x);
              for (i = 0; i < $$.data.targets[0].values.length; i++) {
                  if ($$.data.targets[0].values[i].x - config.tooltip_init_x === 0) {
                      break;
                  }
              }
              config.tooltip_init_x = i;
          }
          $$.tooltip.html(config.tooltip_contents.call($$, $$.data.targets.map(function (d) {
              return $$.addName(d.values[config.tooltip_init_x]);
          }), $$.axis.getXAxisTickFormat(), $$.getYFormat($$.hasArcType()), $$.color));
          $$.tooltip
              .style('top', config.tooltip_init_position.top)
              .style('left', config.tooltip_init_position.left)
              .style('display', 'block');
      }
  };
  ChartInternal.prototype.getTooltipSortFunction = function () {
      var $$ = this, config = $$.config;
      if (config.data_groups.length === 0 || config.tooltip_order !== undefined) {
          // if data are not grouped or if an order is specified
          // for the tooltip values we sort them by their values
          var order = config.tooltip_order;
          if (order === undefined) {
              order = config.data_order;
          }
          var valueOf = function (obj) {
              return obj ? obj.value : null;
          };
          // if data are not grouped, we sort them by their value
          if (isString(order) && order.toLowerCase() === 'asc') {
              return function (a, b) {
                  return valueOf(a) - valueOf(b);
              };
          }
          else if (isString(order) && order.toLowerCase() === 'desc') {
              return function (a, b) {
                  return valueOf(b) - valueOf(a);
              };
          }
          else if (isFunction(order)) {
              // if the function is from data_order we need
              // to wrap the returned function in order to format
              // the sorted value to the expected format
              var sortFunction = order;
              if (config.tooltip_order === undefined) {
                  sortFunction = function (a, b) {
                      return order(a
                          ? {
                              id: a.id,
                              values: [a]
                          }
                          : null, b
                          ? {
                              id: b.id,
                              values: [b]
                          }
                          : null);
                  };
              }
              return sortFunction;
          }
          else if (isArray(order)) {
              return function (a, b) {
                  return order.indexOf(a.id) - order.indexOf(b.id);
              };
          }
      }
      else {
          // if data are grouped, we follow the order of grouped targets
          var ids = $$.orderTargets($$.data.targets).map(function (i) {
              return i.id;
          });
          // if it was either asc or desc we need to invert the order
          // returned by orderTargets
          if ($$.isOrderAsc() || $$.isOrderDesc()) {
              ids = ids.reverse();
          }
          return function (a, b) {
              return ids.indexOf(a.id) - ids.indexOf(b.id);
          };
      }
  };
  ChartInternal.prototype.getTooltipContent = function (d, defaultTitleFormat, defaultValueFormat, color) {
      var $$ = this, config = $$.config, titleFormat = config.tooltip_format_title || defaultTitleFormat, nameFormat = config.tooltip_format_name ||
          function (name) {
              return name;
          }, text, i, title, value, name, bgcolor;
      var valueFormat = config.tooltip_format_value;
      if (!valueFormat) {
          valueFormat = $$.isTargetNormalized(d.id)
              ? function (v, ratio) { return (ratio * 100).toFixed(2) + "%"; }
              : defaultValueFormat;
      }
      var tooltipSortFunction = this.getTooltipSortFunction();
      if (tooltipSortFunction) {
          d.sort(tooltipSortFunction);
      }
      for (i = 0; i < d.length; i++) {
          if (!(d[i] && (d[i].value || d[i].value === 0))) {
              continue;
          }
          if ($$.isStanfordGraphType()) {
              // Custom tooltip for stanford plots
              if (!text) {
                  title = $$.getStanfordTooltipTitle(d[i]);
                  text = "<table class='" + $$.CLASS.tooltip + "'>" + title;
              }
              bgcolor = $$.getStanfordPointColor(d[i]);
              name = sanitise(config.data_epochs); // Epochs key name
              value = d[i].epochs;
          }
          else {
              // Regular tooltip
              if (!text) {
                  title = sanitise(titleFormat ? titleFormat(d[i].x, d[i].index) : d[i].x);
                  text =
                      "<table class='" +
                          $$.CLASS.tooltip +
                          "'>" +
                          (title || title === 0
                              ? "<tr><th colspan='2'>" + title + '</th></tr>'
                              : '');
              }
              value = sanitise(valueFormat(d[i].value, d[i].ratio, d[i].id, d[i].index, d));
              if (value !== undefined) {
                  // Skip elements when their name is set to null
                  if (d[i].name === null) {
                      continue;
                  }
                  name = sanitise(nameFormat(d[i].name, d[i].ratio, d[i].id, d[i].index));
                  bgcolor = $$.levelColor ? $$.levelColor(d[i].value) : color(d[i].id);
              }
          }
          if (value !== undefined) {
              text +=
                  "<tr class='" +
                      $$.CLASS.tooltipName +
                      '-' +
                      $$.getTargetSelectorSuffix(d[i].id) +
                      "'>";
              text +=
                  "<td class='name'><span style='background-color:" +
                      bgcolor +
                      "'></span>" +
                      name +
                      '</td>';
              text += "<td class='value'>" + value + '</td>';
              text += '</tr>';
          }
      }
      return text + '</table>';
  };
  ChartInternal.prototype.tooltipPosition = function (dataToShow, tWidth, tHeight, element) {
      var $$ = this, config = $$.config, d3 = $$.d3;
      var svgLeft, tooltipLeft, tooltipRight, tooltipTop, chartRight;
      var forArc = $$.hasArcType(), mouse = d3.mouse(element);
      // Determin tooltip position
      if (forArc) {
          tooltipLeft =
              ($$.width - ($$.isLegendRight ? $$.getLegendWidth() : 0)) / 2 + mouse[0];
          tooltipTop =
              ($$.hasType('gauge') ? $$.height : $$.height / 2) + mouse[1] + 20;
      }
      else {
          svgLeft = $$.getSvgLeft(true);
          if (config.axis_rotated) {
              tooltipLeft = svgLeft + mouse[0] + 100;
              tooltipRight = tooltipLeft + tWidth;
              chartRight = $$.currentWidth - $$.getCurrentPaddingRight();
              tooltipTop = $$.x(dataToShow[0].x) + 20;
          }
          else {
              tooltipLeft =
                  svgLeft + $$.getCurrentPaddingLeft(true) + $$.x(dataToShow[0].x) + 20;
              tooltipRight = tooltipLeft + tWidth;
              chartRight = svgLeft + $$.currentWidth - $$.getCurrentPaddingRight();
              tooltipTop = mouse[1] + 15;
          }
          if (tooltipRight > chartRight) {
              // 20 is needed for Firefox to keep tooltip width
              tooltipLeft -= tooltipRight - chartRight + 20;
          }
          if (tooltipTop + tHeight > $$.currentHeight) {
              tooltipTop -= tHeight + 30;
          }
      }
      if (tooltipTop < 0) {
          tooltipTop = 0;
      }
      return {
          top: tooltipTop,
          left: tooltipLeft
      };
  };
  ChartInternal.prototype.showTooltip = function (selectedData, element) {
      var $$ = this, config = $$.config;
      var tWidth, tHeight, position;
      var forArc = $$.hasArcType(), dataToShow = selectedData.filter(function (d) {
          return d && isValue(d.value);
      }), positionFunction = config.tooltip_position || ChartInternal.prototype.tooltipPosition;
      if (dataToShow.length === 0 || !config.tooltip_show) {
          $$.hideTooltip();
          return;
      }
      $$.tooltip
          .html(config.tooltip_contents.call($$, selectedData, $$.axis.getXAxisTickFormat(), $$.getYFormat(forArc), $$.color))
          .style('display', 'block');
      // Get tooltip dimensions
      tWidth = $$.tooltip.property('offsetWidth');
      tHeight = $$.tooltip.property('offsetHeight');
      position = positionFunction.call(this, dataToShow, tWidth, tHeight, element);
      // Set tooltip
      $$.tooltip
          .style('top', position.top + 'px')
          .style('left', position.left + 'px');
  };
  ChartInternal.prototype.hideTooltip = function () {
      this.tooltip.style('display', 'none');
  };

  ChartInternal.prototype.setTargetType = function (targetIds, type) {
      var $$ = this, config = $$.config;
      $$.mapToTargetIds(targetIds).forEach(function (id) {
          $$.withoutFadeIn[id] = type === config.data_types[id];
          config.data_types[id] = type;
      });
      if (!targetIds) {
          config.data_type = type;
      }
  };
  ChartInternal.prototype.hasType = function (type, targets) {
      var $$ = this, types = $$.config.data_types, has = false;
      targets = targets || $$.data.targets;
      if (targets && targets.length) {
          targets.forEach(function (target) {
              var t = types[target.id];
              if ((t && t.indexOf(type) >= 0) || (!t && type === 'line')) {
                  has = true;
              }
          });
      }
      else if (Object.keys(types).length) {
          Object.keys(types).forEach(function (id) {
              if (types[id] === type) {
                  has = true;
              }
          });
      }
      else {
          has = $$.config.data_type === type;
      }
      return has;
  };
  ChartInternal.prototype.hasArcType = function (targets) {
      return (this.hasType('pie', targets) ||
          this.hasType('donut', targets) ||
          this.hasType('gauge', targets));
  };
  ChartInternal.prototype.isLineType = function (d) {
      var config = this.config, id = isString(d) ? d : d.id;
      return (!config.data_types[id] ||
          ['line', 'spline', 'area', 'area-spline', 'step', 'area-step'].indexOf(config.data_types[id]) >= 0);
  };
  ChartInternal.prototype.isStepType = function (d) {
      var id = isString(d) ? d : d.id;
      return ['step', 'area-step'].indexOf(this.config.data_types[id]) >= 0;
  };
  ChartInternal.prototype.isSplineType = function (d) {
      var id = isString(d) ? d : d.id;
      return ['spline', 'area-spline'].indexOf(this.config.data_types[id]) >= 0;
  };
  ChartInternal.prototype.isAreaType = function (d) {
      var id = isString(d) ? d : d.id;
      return (['area', 'area-spline', 'area-step'].indexOf(this.config.data_types[id]) >=
          0);
  };
  ChartInternal.prototype.isBarType = function (d) {
      var id = isString(d) ? d : d.id;
      return this.config.data_types[id] === 'bar';
  };
  ChartInternal.prototype.isScatterType = function (d) {
      var id = isString(d) ? d : d.id;
      return this.config.data_types[id] === 'scatter';
  };
  ChartInternal.prototype.isStanfordType = function (d) {
      var id = isString(d) ? d : d.id;
      return this.config.data_types[id] === 'stanford';
  };
  ChartInternal.prototype.isPieType = function (d) {
      var id = isString(d) ? d : d.id;
      return this.config.data_types[id] === 'pie';
  };
  ChartInternal.prototype.isGaugeType = function (d) {
      var id = isString(d) ? d : d.id;
      return this.config.data_types[id] === 'gauge';
  };
  ChartInternal.prototype.isDonutType = function (d) {
      var id = isString(d) ? d : d.id;
      return this.config.data_types[id] === 'donut';
  };
  ChartInternal.prototype.isArcType = function (d) {
      return this.isPieType(d) || this.isDonutType(d) || this.isGaugeType(d);
  };
  ChartInternal.prototype.lineData = function (d) {
      return this.isLineType(d) ? [d] : [];
  };
  ChartInternal.prototype.arcData = function (d) {
      return this.isArcType(d.data) ? [d] : [];
  };
  /* not used
   function scatterData(d) {
   return isScatterType(d) ? d.values : [];
   }
   */
  ChartInternal.prototype.barData = function (d) {
      return this.isBarType(d) ? d.values : [];
  };
  ChartInternal.prototype.lineOrScatterOrStanfordData = function (d) {
      return this.isLineType(d) || this.isScatterType(d) || this.isStanfordType(d)
          ? d.values
          : [];
  };
  ChartInternal.prototype.barOrLineData = function (d) {
      return this.isBarType(d) || this.isLineType(d) ? d.values : [];
  };

  ChartInternal.prototype.isSafari = function () {
      var ua = window.navigator.userAgent;
      return ua.indexOf('Safari') >= 0 && ua.indexOf('Chrome') < 0;
  };
  ChartInternal.prototype.isChrome = function () {
      var ua = window.navigator.userAgent;
      return ua.indexOf('Chrome') >= 0;
  };

  ChartInternal.prototype.initZoom = function () {
      var $$ = this, d3 = $$.d3, config = $$.config, startEvent;
      $$.zoom = d3
          .zoom()
          .on('start', function () {
          if (config.zoom_type !== 'scroll') {
              return;
          }
          var e = d3.event.sourceEvent;
          if (e && e.type === 'brush') {
              return;
          }
          startEvent = e;
          config.zoom_onzoomstart.call($$.api, e);
      })
          .on('zoom', function () {
          if (config.zoom_type !== 'scroll') {
              return;
          }
          var e = d3.event.sourceEvent;
          if (e && e.type === 'brush') {
              return;
          }
          $$.redrawForZoom();
          config.zoom_onzoom.call($$.api, $$.x.orgDomain());
      })
          .on('end', function () {
          if (config.zoom_type !== 'scroll') {
              return;
          }
          var e = d3.event.sourceEvent;
          if (e && e.type === 'brush') {
              return;
          }
          // if click, do nothing. otherwise, click interaction will be canceled.
          if (e &&
              startEvent.clientX === e.clientX &&
              startEvent.clientY === e.clientY) {
              return;
          }
          config.zoom_onzoomend.call($$.api, $$.x.orgDomain());
      });
      $$.zoom.updateDomain = function () {
          if (d3.event && d3.event.transform) {
              if (config.axis_rotated && config.zoom_type === 'scroll' && d3.event.sourceEvent.type === 'mousemove') {
                  // we're moving the mouse in a rotated chart with zoom = "scroll", so we need rescaleY (i.e. vertical)
                  $$.x.domain(d3.event.transform.rescaleY($$.subX).domain());
              }
              else {
                  $$.x.domain(d3.event.transform.rescaleX($$.subX).domain());
              }
          }
          return this;
      };
      $$.zoom.updateExtent = function () {
          this.scaleExtent([1, Infinity])
              .translateExtent([
              [0, 0],
              [$$.width, $$.height]
          ])
              .extent([
              [0, 0],
              [$$.width, $$.height]
          ]);
          return this;
      };
      $$.zoom.update = function () {
          return this.updateExtent().updateDomain();
      };
      return $$.zoom.updateExtent();
  };
  ChartInternal.prototype.zoomTransform = function (range) {
      var $$ = this, s = [$$.x(range[0]), $$.x(range[1])];
      return $$.d3.zoomIdentity.scale($$.width / (s[1] - s[0])).translate(-s[0], 0);
  };
  ChartInternal.prototype.initDragZoom = function () {
      var $$ = this;
      var d3 = $$.d3;
      var config = $$.config;
      var context = ($$.context = $$.svg);
      var brushXPos = $$.margin.left + 20.5;
      var brushYPos = $$.margin.top + 0.5;
      if (!(config.zoom_type === 'drag' && config.zoom_enabled)) {
          return;
      }
      var getZoomedDomain = function (selection) {
          return selection && selection.map(function (x) { return $$.x.invert(x); });
      };
      var brush = ($$.dragZoomBrush = d3
          .brushX()
          .on('start', function () {
          $$.api.unzoom();
          $$.svg.select('.' + CLASS.dragZoom).classed('disabled', false);
          config.zoom_onzoomstart.call($$.api, d3.event.sourceEvent);
      })
          .on('brush', function () {
          config.zoom_onzoom.call($$.api, getZoomedDomain(d3.event.selection));
      })
          .on('end', function () {
          if (d3.event.selection == null) {
              return;
          }
          var zoomedDomain = getZoomedDomain(d3.event.selection);
          if (!config.zoom_disableDefaultBehavior) {
              $$.api.zoom(zoomedDomain);
          }
          $$.svg.select('.' + CLASS.dragZoom).classed('disabled', true);
          config.zoom_onzoomend.call($$.api, zoomedDomain);
      }));
      context
          .append('g')
          .classed(CLASS.dragZoom, true)
          .attr('clip-path', $$.clipPath)
          .attr('transform', 'translate(' + brushXPos + ',' + brushYPos + ')')
          .call(brush);
  };
  ChartInternal.prototype.getZoomDomain = function () {
      var $$ = this, config = $$.config, d3 = $$.d3, min = d3.min([$$.orgXDomain[0], config.zoom_x_min]), max = d3.max([$$.orgXDomain[1], config.zoom_x_max]);
      return [min, max];
  };
  ChartInternal.prototype.redrawForZoom = function () {
      var $$ = this, d3 = $$.d3, config = $$.config, zoom = $$.zoom, x = $$.x;
      if (!config.zoom_enabled) {
          return;
      }
      if ($$.filterTargetsToShow($$.data.targets).length === 0) {
          return;
      }
      zoom.update();
      if (config.zoom_disableDefaultBehavior) {
          return;
      }
      if ($$.isCategorized() && x.orgDomain()[0] === $$.orgXDomain[0]) {
          x.domain([$$.orgXDomain[0] - 1e-10, x.orgDomain()[1]]);
      }
      $$.redraw({
          withTransition: false,
          withY: config.zoom_rescale,
          withSubchart: false,
          withEventRect: false,
          withDimension: false
      });
      if (d3.event.sourceEvent && d3.event.sourceEvent.type === 'mousemove') {
          $$.cancelClick = true;
      }
  };

  return c3;

})));


/***/ }),

/***/ "LZ5Q":
/*!********************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/mercator.js ***!
  \********************************************************/
/*! exports provided: mercatorRaw, default, mercatorProjection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mercatorRaw", function() { return mercatorRaw; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mercatorProjection", function() { return mercatorProjection; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "R0y8");
/* harmony import */ var _rotation_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../rotation.js */ "cwsO");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.js */ "1ibS");




function mercatorRaw(lambda, phi) {
  return [lambda, Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["log"])(Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["tan"])((_math_js__WEBPACK_IMPORTED_MODULE_0__["halfPi"] + phi) / 2))];
}

mercatorRaw.invert = function(x, y) {
  return [x, 2 * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["atan"])(Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["exp"])(y)) - _math_js__WEBPACK_IMPORTED_MODULE_0__["halfPi"]];
};

/* harmony default export */ __webpack_exports__["default"] = (function() {
  return mercatorProjection(mercatorRaw)
      .scale(961 / _math_js__WEBPACK_IMPORTED_MODULE_0__["tau"]);
});

function mercatorProjection(project) {
  var m = Object(_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(project),
      center = m.center,
      scale = m.scale,
      translate = m.translate,
      clipExtent = m.clipExtent,
      x0 = null, y0, x1, y1; // clip extent

  m.scale = function(_) {
    return arguments.length ? (scale(_), reclip()) : scale();
  };

  m.translate = function(_) {
    return arguments.length ? (translate(_), reclip()) : translate();
  };

  m.center = function(_) {
    return arguments.length ? (center(_), reclip()) : center();
  };

  m.clipExtent = function(_) {
    return arguments.length ? ((_ == null ? x0 = y0 = x1 = y1 = null : (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1])), reclip()) : x0 == null ? null : [[x0, y0], [x1, y1]];
  };

  function reclip() {
    var k = _math_js__WEBPACK_IMPORTED_MODULE_0__["pi"] * scale(),
        t = m(Object(_rotation_js__WEBPACK_IMPORTED_MODULE_1__["default"])(m.rotate()).invert([0, 0]));
    return clipExtent(x0 == null
        ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw
        ? [[Math.max(t[0] - k, x0), y0], [Math.min(t[0] + k, x1), y1]]
        : [[x0, Math.max(t[1] - k, y0)], [x1, Math.min(t[1] + k, y1)]]);
  }

  return reclip();
}


/***/ }),

/***/ "MLOY":
/*!**********************************************!*\
  !*** ./node_modules/d3-polygon/src/cross.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Returns the 2D cross product of AB and AC vectors, i.e., the z-component of
// the 3D cross product in a quadrant I Cartesian coordinate system (+x is
// right, +y is up). Returns a positive value if ABC is counter-clockwise,
// negative if clockwise, and zero if the points are collinear.
/* harmony default export */ __webpack_exports__["default"] = (function(a, b, c) {
  return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
});


/***/ }),

/***/ "MrsS":
/*!*********************************************************************************!*\
  !*** ./node_modules/c3/node_modules/d3-array/src/threshold/freedmanDiaconis.js ***!
  \*********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../array */ "yhNL");
/* harmony import */ var _ascending__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ascending */ "nz0m");
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../number */ "1Fr+");
/* harmony import */ var _quantile__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../quantile */ "pVVs");





/* harmony default export */ __webpack_exports__["default"] = (function(values, min, max) {
  values = _array__WEBPACK_IMPORTED_MODULE_0__["map"].call(values, _number__WEBPACK_IMPORTED_MODULE_2__["default"]).sort(_ascending__WEBPACK_IMPORTED_MODULE_1__["default"]);
  return Math.ceil((max - min) / (2 * (Object(_quantile__WEBPACK_IMPORTED_MODULE_3__["default"])(values, 0.75) - Object(_quantile__WEBPACK_IMPORTED_MODULE_3__["default"])(values, 0.25)) * Math.pow(values.length, -1 / 3)));
});


/***/ }),

/***/ "NScU":
/*!***********************************************!*\
  !*** ./node_modules/d3-random/src/uniform.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _defaultSource__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./defaultSource */ "0RZX");


/* harmony default export */ __webpack_exports__["default"] = ((function sourceRandomUniform(source) {
  function randomUniform(min, max) {
    min = min == null ? 0 : +min;
    max = max == null ? 1 : +max;
    if (arguments.length === 1) max = min, min = 0;
    else max -= min;
    return function() {
      return source() * max + min;
    };
  }

  randomUniform.source = sourceRandomUniform;

  return randomUniform;
})(_defaultSource__WEBPACK_IMPORTED_MODULE_0__["default"]));


/***/ }),

/***/ "Nv8T":
/*!*******************************************!*\
  !*** ./node_modules/d3-quadtree/src/y.js ***!
  \*******************************************/
/*! exports provided: defaultY, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultY", function() { return defaultY; });
function defaultY(d) {
  return d[1];
}

/* harmony default export */ __webpack_exports__["default"] = (function(_) {
  return arguments.length ? (this._y = _, this) : this._y;
});


/***/ }),

/***/ "NvdV":
/*!************************************************************************!*\
  !*** ./node_modules/c3/node_modules/d3-array/src/threshold/sturges.js ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(values) {
  return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
});


/***/ }),

/***/ "ODVu":
/*!************************************************!*\
  !*** ./node_modules/d3-geo/src/clip/buffer.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop.js */ "mPOO");


/* harmony default export */ __webpack_exports__["default"] = (function() {
  var lines = [],
      line;
  return {
    point: function(x, y, m) {
      line.push([x, y, m]);
    },
    lineStart: function() {
      lines.push(line = []);
    },
    lineEnd: _noop_js__WEBPACK_IMPORTED_MODULE_0__["default"],
    rejoin: function() {
      if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
    },
    result: function() {
      var result = lines;
      lines = [];
      line = null;
      return result;
    }
  };
});


/***/ }),

/***/ "OSsQ":
/*!*********************************************!*\
  !*** ./node_modules/d3-zoom/src/noevent.js ***!
  \*********************************************/
/*! exports provided: nopropagation, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nopropagation", function() { return nopropagation; });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "/TIM");


function nopropagation() {
  d3_selection__WEBPACK_IMPORTED_MODULE_0__["event"].stopImmediatePropagation();
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  d3_selection__WEBPACK_IMPORTED_MODULE_0__["event"].preventDefault();
  d3_selection__WEBPACK_IMPORTED_MODULE_0__["event"].stopImmediatePropagation();
});


/***/ }),

/***/ "P6wR":
/*!******************************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/azimuthalEqualArea.js ***!
  \******************************************************************/
/*! exports provided: azimuthalEqualAreaRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "azimuthalEqualAreaRaw", function() { return azimuthalEqualAreaRaw; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "R0y8");
/* harmony import */ var _azimuthal_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./azimuthal.js */ "dg0l");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.js */ "1ibS");




var azimuthalEqualAreaRaw = Object(_azimuthal_js__WEBPACK_IMPORTED_MODULE_1__["azimuthalRaw"])(function(cxcy) {
  return Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(2 / (1 + cxcy));
});

azimuthalEqualAreaRaw.invert = Object(_azimuthal_js__WEBPACK_IMPORTED_MODULE_1__["azimuthalInvert"])(function(z) {
  return 2 * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["asin"])(z / 2);
});

/* harmony default export */ __webpack_exports__["default"] = (function() {
  return Object(_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(azimuthalEqualAreaRaw)
      .scale(124.75)
      .clipAngle(180 - 1e-3);
});


/***/ }),

/***/ "PQSO":
/*!************************************************!*\
  !*** ./node_modules/d3-geo/src/clip/circle.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _cartesian_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../cartesian.js */ "YzSS");
/* harmony import */ var _circle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../circle.js */ "vNJl");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math.js */ "R0y8");
/* harmony import */ var _pointEqual_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../pointEqual.js */ "fnXD");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./index.js */ "pb3N");






/* harmony default export */ __webpack_exports__["default"] = (function(radius) {
  var cr = Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["cos"])(radius),
      delta = 6 * _math_js__WEBPACK_IMPORTED_MODULE_2__["radians"],
      smallRadius = cr > 0,
      notHemisphere = Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["abs"])(cr) > _math_js__WEBPACK_IMPORTED_MODULE_2__["epsilon"]; // TODO optimise for this common case

  function interpolate(from, to, direction, stream) {
    Object(_circle_js__WEBPACK_IMPORTED_MODULE_1__["circleStream"])(stream, radius, delta, direction, from, to);
  }

  function visible(lambda, phi) {
    return Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["cos"])(lambda) * Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["cos"])(phi) > cr;
  }

  // Takes a line and cuts into visible segments. Return values used for polygon
  // clipping: 0 - there were intersections or the line was empty; 1 - no
  // intersections 2 - there were intersections, and the first and last segments
  // should be rejoined.
  function clipLine(stream) {
    var point0, // previous point
        c0, // code for previous point
        v0, // visibility of previous point
        v00, // visibility of first point
        clean; // no intersections
    return {
      lineStart: function() {
        v00 = v0 = false;
        clean = 1;
      },
      point: function(lambda, phi) {
        var point1 = [lambda, phi],
            point2,
            v = visible(lambda, phi),
            c = smallRadius
              ? v ? 0 : code(lambda, phi)
              : v ? code(lambda + (lambda < 0 ? _math_js__WEBPACK_IMPORTED_MODULE_2__["pi"] : -_math_js__WEBPACK_IMPORTED_MODULE_2__["pi"]), phi) : 0;
        if (!point0 && (v00 = v0 = v)) stream.lineStart();
        if (v !== v0) {
          point2 = intersect(point0, point1);
          if (!point2 || Object(_pointEqual_js__WEBPACK_IMPORTED_MODULE_3__["default"])(point0, point2) || Object(_pointEqual_js__WEBPACK_IMPORTED_MODULE_3__["default"])(point1, point2))
            point1[2] = 1;
        }
        if (v !== v0) {
          clean = 0;
          if (v) {
            // outside going in
            stream.lineStart();
            point2 = intersect(point1, point0);
            stream.point(point2[0], point2[1]);
          } else {
            // inside going out
            point2 = intersect(point0, point1);
            stream.point(point2[0], point2[1], 2);
            stream.lineEnd();
          }
          point0 = point2;
        } else if (notHemisphere && point0 && smallRadius ^ v) {
          var t;
          // If the codes for two points are different, or are both zero,
          // and there this segment intersects with the small circle.
          if (!(c & c0) && (t = intersect(point1, point0, true))) {
            clean = 0;
            if (smallRadius) {
              stream.lineStart();
              stream.point(t[0][0], t[0][1]);
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
            } else {
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
              stream.lineStart();
              stream.point(t[0][0], t[0][1], 3);
            }
          }
        }
        if (v && (!point0 || !Object(_pointEqual_js__WEBPACK_IMPORTED_MODULE_3__["default"])(point0, point1))) {
          stream.point(point1[0], point1[1]);
        }
        point0 = point1, v0 = v, c0 = c;
      },
      lineEnd: function() {
        if (v0) stream.lineEnd();
        point0 = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function() {
        return clean | ((v00 && v0) << 1);
      }
    };
  }

  // Intersects the great circle between a and b with the clip circle.
  function intersect(a, b, two) {
    var pa = Object(_cartesian_js__WEBPACK_IMPORTED_MODULE_0__["cartesian"])(a),
        pb = Object(_cartesian_js__WEBPACK_IMPORTED_MODULE_0__["cartesian"])(b);

    // We have two planes, n1.p = d1 and n2.p = d2.
    // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 ⨯ n2).
    var n1 = [1, 0, 0], // normal
        n2 = Object(_cartesian_js__WEBPACK_IMPORTED_MODULE_0__["cartesianCross"])(pa, pb),
        n2n2 = Object(_cartesian_js__WEBPACK_IMPORTED_MODULE_0__["cartesianDot"])(n2, n2),
        n1n2 = n2[0], // cartesianDot(n1, n2),
        determinant = n2n2 - n1n2 * n1n2;

    // Two polar points.
    if (!determinant) return !two && a;

    var c1 =  cr * n2n2 / determinant,
        c2 = -cr * n1n2 / determinant,
        n1xn2 = Object(_cartesian_js__WEBPACK_IMPORTED_MODULE_0__["cartesianCross"])(n1, n2),
        A = Object(_cartesian_js__WEBPACK_IMPORTED_MODULE_0__["cartesianScale"])(n1, c1),
        B = Object(_cartesian_js__WEBPACK_IMPORTED_MODULE_0__["cartesianScale"])(n2, c2);
    Object(_cartesian_js__WEBPACK_IMPORTED_MODULE_0__["cartesianAddInPlace"])(A, B);

    // Solve |p(t)|^2 = 1.
    var u = n1xn2,
        w = Object(_cartesian_js__WEBPACK_IMPORTED_MODULE_0__["cartesianDot"])(A, u),
        uu = Object(_cartesian_js__WEBPACK_IMPORTED_MODULE_0__["cartesianDot"])(u, u),
        t2 = w * w - uu * (Object(_cartesian_js__WEBPACK_IMPORTED_MODULE_0__["cartesianDot"])(A, A) - 1);

    if (t2 < 0) return;

    var t = Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["sqrt"])(t2),
        q = Object(_cartesian_js__WEBPACK_IMPORTED_MODULE_0__["cartesianScale"])(u, (-w - t) / uu);
    Object(_cartesian_js__WEBPACK_IMPORTED_MODULE_0__["cartesianAddInPlace"])(q, A);
    q = Object(_cartesian_js__WEBPACK_IMPORTED_MODULE_0__["spherical"])(q);

    if (!two) return q;

    // Two intersection points.
    var lambda0 = a[0],
        lambda1 = b[0],
        phi0 = a[1],
        phi1 = b[1],
        z;

    if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;

    var delta = lambda1 - lambda0,
        polar = Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["abs"])(delta - _math_js__WEBPACK_IMPORTED_MODULE_2__["pi"]) < _math_js__WEBPACK_IMPORTED_MODULE_2__["epsilon"],
        meridian = polar || delta < _math_js__WEBPACK_IMPORTED_MODULE_2__["epsilon"];

    if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;

    // Check that the first point is between a and b.
    if (meridian
        ? polar
          ? phi0 + phi1 > 0 ^ q[1] < (Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["abs"])(q[0] - lambda0) < _math_js__WEBPACK_IMPORTED_MODULE_2__["epsilon"] ? phi0 : phi1)
          : phi0 <= q[1] && q[1] <= phi1
        : delta > _math_js__WEBPACK_IMPORTED_MODULE_2__["pi"] ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
      var q1 = Object(_cartesian_js__WEBPACK_IMPORTED_MODULE_0__["cartesianScale"])(u, (-w + t) / uu);
      Object(_cartesian_js__WEBPACK_IMPORTED_MODULE_0__["cartesianAddInPlace"])(q1, A);
      return [q, Object(_cartesian_js__WEBPACK_IMPORTED_MODULE_0__["spherical"])(q1)];
    }
  }

  // Generates a 4-bit vector representing the location of a point relative to
  // the small circle's bounding box.
  function code(lambda, phi) {
    var r = smallRadius ? radius : _math_js__WEBPACK_IMPORTED_MODULE_2__["pi"] - radius,
        code = 0;
    if (lambda < -r) code |= 1; // left
    else if (lambda > r) code |= 2; // right
    if (phi < -r) code |= 4; // below
    else if (phi > r) code |= 8; // above
    return code;
  }

  return Object(_index_js__WEBPACK_IMPORTED_MODULE_4__["default"])(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-_math_js__WEBPACK_IMPORTED_MODULE_2__["pi"], radius - _math_js__WEBPACK_IMPORTED_MODULE_2__["pi"]]);
});


/***/ }),

/***/ "PSPu":
/*!*****************************************!*\
  !*** ./node_modules/d3-geo/src/area.js ***!
  \*****************************************/
/*! exports provided: areaRingSum, areaStream, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "areaRingSum", function() { return areaRingSum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "areaStream", function() { return areaStream; });
/* harmony import */ var _adder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./adder.js */ "uCr6");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ "R0y8");
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./noop.js */ "mPOO");
/* harmony import */ var _stream_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stream.js */ "tepu");





var areaRingSum = Object(_adder_js__WEBPACK_IMPORTED_MODULE_0__["default"])();

var areaSum = Object(_adder_js__WEBPACK_IMPORTED_MODULE_0__["default"])(),
    lambda00,
    phi00,
    lambda0,
    cosPhi0,
    sinPhi0;

var areaStream = {
  point: _noop_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  lineStart: _noop_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  lineEnd: _noop_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  polygonStart: function() {
    areaRingSum.reset();
    areaStream.lineStart = areaRingStart;
    areaStream.lineEnd = areaRingEnd;
  },
  polygonEnd: function() {
    var areaRing = +areaRingSum;
    areaSum.add(areaRing < 0 ? _math_js__WEBPACK_IMPORTED_MODULE_1__["tau"] + areaRing : areaRing);
    this.lineStart = this.lineEnd = this.point = _noop_js__WEBPACK_IMPORTED_MODULE_2__["default"];
  },
  sphere: function() {
    areaSum.add(_math_js__WEBPACK_IMPORTED_MODULE_1__["tau"]);
  }
};

function areaRingStart() {
  areaStream.point = areaPointFirst;
}

function areaRingEnd() {
  areaPoint(lambda00, phi00);
}

function areaPointFirst(lambda, phi) {
  areaStream.point = areaPoint;
  lambda00 = lambda, phi00 = phi;
  lambda *= _math_js__WEBPACK_IMPORTED_MODULE_1__["radians"], phi *= _math_js__WEBPACK_IMPORTED_MODULE_1__["radians"];
  lambda0 = lambda, cosPhi0 = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi = phi / 2 + _math_js__WEBPACK_IMPORTED_MODULE_1__["quarterPi"]), sinPhi0 = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi);
}

function areaPoint(lambda, phi) {
  lambda *= _math_js__WEBPACK_IMPORTED_MODULE_1__["radians"], phi *= _math_js__WEBPACK_IMPORTED_MODULE_1__["radians"];
  phi = phi / 2 + _math_js__WEBPACK_IMPORTED_MODULE_1__["quarterPi"]; // half the angular distance from south pole

  // Spherical excess E for a spherical triangle with vertices: south pole,
  // previous point, current point.  Uses a formula derived from Cagnoli’s
  // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).
  var dLambda = lambda - lambda0,
      sdLambda = dLambda >= 0 ? 1 : -1,
      adLambda = sdLambda * dLambda,
      cosPhi = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi),
      sinPhi = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi),
      k = sinPhi0 * sinPhi,
      u = cosPhi0 * cosPhi + k * Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["cos"])(adLambda),
      v = k * sdLambda * Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["sin"])(adLambda);
  areaRingSum.add(Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["atan2"])(v, u));

  // Advance the previous points.
  lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;
}

/* harmony default export */ __webpack_exports__["default"] = (function(object) {
  areaSum.reset();
  Object(_stream_js__WEBPACK_IMPORTED_MODULE_3__["default"])(object, areaStream);
  return areaSum * 2;
});


/***/ }),

/***/ "QupR":
/*!*********************************************!*\
  !*** ./node_modules/d3-force/src/jiggle.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function() {
  return (Math.random() - 0.5) * 1e-6;
});


/***/ }),

/***/ "R0y8":
/*!*****************************************!*\
  !*** ./node_modules/d3-geo/src/math.js ***!
  \*****************************************/
/*! exports provided: epsilon, epsilon2, pi, halfPi, quarterPi, tau, degrees, radians, abs, atan, atan2, cos, ceil, exp, floor, log, pow, sin, sign, sqrt, tan, acos, asin, haversin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "epsilon", function() { return epsilon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "epsilon2", function() { return epsilon2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pi", function() { return pi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "halfPi", function() { return halfPi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quarterPi", function() { return quarterPi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tau", function() { return tau; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "degrees", function() { return degrees; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "radians", function() { return radians; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "abs", function() { return abs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "atan", function() { return atan; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "atan2", function() { return atan2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cos", function() { return cos; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ceil", function() { return ceil; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exp", function() { return exp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floor", function() { return floor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "log", function() { return log; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pow", function() { return pow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sin", function() { return sin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sign", function() { return sign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrt", function() { return sqrt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tan", function() { return tan; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "acos", function() { return acos; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "asin", function() { return asin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "haversin", function() { return haversin; });
var epsilon = 1e-6;
var epsilon2 = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var quarterPi = pi / 4;
var tau = pi * 2;

var degrees = 180 / pi;
var radians = pi / 180;

var abs = Math.abs;
var atan = Math.atan;
var atan2 = Math.atan2;
var cos = Math.cos;
var ceil = Math.ceil;
var exp = Math.exp;
var floor = Math.floor;
var log = Math.log;
var pow = Math.pow;
var sin = Math.sin;
var sign = Math.sign || function(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };
var sqrt = Math.sqrt;
var tan = Math.tan;

function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}

function asin(x) {
  return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);
}

function haversin(x) {
  return (x = sin(x / 2)) * x;
}


/***/ }),

/***/ "RBWq":
/*!**************************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/sequential-single/Purples.js ***!
  \**************************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors.js */ "ZtE7");
/* harmony import */ var _ramp_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp.js */ "jQWc");



var scheme = new Array(3).concat(
  "efedf5bcbddc756bb1",
  "f2f0f7cbc9e29e9ac86a51a3",
  "f2f0f7cbc9e29e9ac8756bb154278f",
  "f2f0f7dadaebbcbddc9e9ac8756bb154278f",
  "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486",
  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486",
  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d"
).map(_colors_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp_js__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "RQVR":
/*!**********************************************!*\
  !*** ./node_modules/d3-quadtree/src/root.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function() {
  return this._root;
});


/***/ }),

/***/ "RhHs":
/*!*******************************************!*\
  !*** ./node_modules/d3-axis/src/index.js ***!
  \*******************************************/
/*! exports provided: axisTop, axisRight, axisBottom, axisLeft */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _axis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./axis */ "iBRH");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "axisTop", function() { return _axis__WEBPACK_IMPORTED_MODULE_0__["axisTop"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "axisRight", function() { return _axis__WEBPACK_IMPORTED_MODULE_0__["axisRight"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "axisBottom", function() { return _axis__WEBPACK_IMPORTED_MODULE_0__["axisBottom"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "axisLeft", function() { return _axis__WEBPACK_IMPORTED_MODULE_0__["axisLeft"]; });




/***/ }),

/***/ "S2Xb":
/*!*********************************************!*\
  !*** ./node_modules/d3-contour/src/noop.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function() {});


/***/ }),

/***/ "SGTC":
/*!**********************************************!*\
  !*** ./node_modules/d3-geo/src/clip/line.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(a, b, x0, y0, x1, y1) {
  var ax = a[0],
      ay = a[1],
      bx = b[0],
      by = b[1],
      t0 = 0,
      t1 = 1,
      dx = bx - ax,
      dy = by - ay,
      r;

  r = x0 - ax;
  if (!dx && r > 0) return;
  r /= dx;
  if (dx < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dx > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = x1 - ax;
  if (!dx && r < 0) return;
  r /= dx;
  if (dx < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dx > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  r = y0 - ay;
  if (!dy && r > 0) return;
  r /= dy;
  if (dy < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dy > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = y1 - ay;
  if (!dy && r < 0) return;
  r /= dy;
  if (dy < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dy > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
  if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
  return true;
});


/***/ }),

/***/ "SKGk":
/*!*********************************************!*\
  !*** ./node_modules/d3-chord/src/ribbon.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array */ "8efb");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constant */ "HpDs");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math */ "mJZf");
/* harmony import */ var d3_path__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-path */ "83xM");





function defaultSource(d) {
  return d.source;
}

function defaultTarget(d) {
  return d.target;
}

function defaultRadius(d) {
  return d.radius;
}

function defaultStartAngle(d) {
  return d.startAngle;
}

function defaultEndAngle(d) {
  return d.endAngle;
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  var source = defaultSource,
      target = defaultTarget,
      radius = defaultRadius,
      startAngle = defaultStartAngle,
      endAngle = defaultEndAngle,
      context = null;

  function ribbon() {
    var buffer,
        argv = _array__WEBPACK_IMPORTED_MODULE_0__["slice"].call(arguments),
        s = source.apply(this, argv),
        t = target.apply(this, argv),
        sr = +radius.apply(this, (argv[0] = s, argv)),
        sa0 = startAngle.apply(this, argv) - _math__WEBPACK_IMPORTED_MODULE_2__["halfPi"],
        sa1 = endAngle.apply(this, argv) - _math__WEBPACK_IMPORTED_MODULE_2__["halfPi"],
        sx0 = sr * Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(sa0),
        sy0 = sr * Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(sa0),
        tr = +radius.apply(this, (argv[0] = t, argv)),
        ta0 = startAngle.apply(this, argv) - _math__WEBPACK_IMPORTED_MODULE_2__["halfPi"],
        ta1 = endAngle.apply(this, argv) - _math__WEBPACK_IMPORTED_MODULE_2__["halfPi"];

    if (!context) context = buffer = Object(d3_path__WEBPACK_IMPORTED_MODULE_3__["path"])();

    context.moveTo(sx0, sy0);
    context.arc(0, 0, sr, sa0, sa1);
    if (sa0 !== ta0 || sa1 !== ta1) { // TODO sr !== tr?
      context.quadraticCurveTo(0, 0, tr * Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(ta0), tr * Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(ta0));
      context.arc(0, 0, tr, ta0, ta1);
    }
    context.quadraticCurveTo(0, 0, sx0, sy0);
    context.closePath();

    if (buffer) return context = null, buffer + "" || null;
  }

  ribbon.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), ribbon) : radius;
  };

  ribbon.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), ribbon) : startAngle;
  };

  ribbon.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), ribbon) : endAngle;
  };

  ribbon.source = function(_) {
    return arguments.length ? (source = _, ribbon) : source;
  };

  ribbon.target = function(_) {
    return arguments.length ? (target = _, ribbon) : target;
  };

  ribbon.context = function(_) {
    return arguments.length ? ((context = _ == null ? null : _), ribbon) : context;
  };

  return ribbon;
});


/***/ }),

/***/ "SMHy":
/*!*************************************************************!*\
  !*** ./node_modules/c3/node_modules/d3-scale/src/number.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return +x;
});


/***/ }),

/***/ "SMTj":
/*!************************************************!*\
  !*** ./node_modules/d3-geo/src/path/bounds.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop.js */ "mPOO");


var x0 = Infinity,
    y0 = x0,
    x1 = -x0,
    y1 = x1;

var boundsStream = {
  point: boundsPoint,
  lineStart: _noop_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  lineEnd: _noop_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  polygonStart: _noop_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  polygonEnd: _noop_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  result: function() {
    var bounds = [[x0, y0], [x1, y1]];
    x1 = y1 = -(y0 = x0 = Infinity);
    return bounds;
  }
};

function boundsPoint(x, y) {
  if (x < x0) x0 = x;
  if (x > x1) x1 = x;
  if (y < y0) y0 = y;
  if (y > y1) y1 = y;
}

/* harmony default export */ __webpack_exports__["default"] = (boundsStream);


/***/ }),

/***/ "Sf2A":
/*!************************************************!*\
  !*** ./node_modules/d3-contour/src/density.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "sRF9");
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./array */ "mcvr");
/* harmony import */ var _blur__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./blur */ "VQEX");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constant */ "DiG6");
/* harmony import */ var _contours__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./contours */ "gy+j");






function defaultX(d) {
  return d[0];
}

function defaultY(d) {
  return d[1];
}

function defaultWeight() {
  return 1;
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  var x = defaultX,
      y = defaultY,
      weight = defaultWeight,
      dx = 960,
      dy = 500,
      r = 20, // blur radius
      k = 2, // log2(grid cell size)
      o = r * 3, // grid offset, to pad for blur
      n = (dx + o * 2) >> k, // grid width
      m = (dy + o * 2) >> k, // grid height
      threshold = Object(_constant__WEBPACK_IMPORTED_MODULE_3__["default"])(20);

  function density(data) {
    var values0 = new Float32Array(n * m),
        values1 = new Float32Array(n * m);

    data.forEach(function(d, i, data) {
      var xi = (+x(d, i, data) + o) >> k,
          yi = (+y(d, i, data) + o) >> k,
          wi = +weight(d, i, data);
      if (xi >= 0 && xi < n && yi >= 0 && yi < m) {
        values0[xi + yi * n] += wi;
      }
    });

    // TODO Optimize.
    Object(_blur__WEBPACK_IMPORTED_MODULE_2__["blurX"])({width: n, height: m, data: values0}, {width: n, height: m, data: values1}, r >> k);
    Object(_blur__WEBPACK_IMPORTED_MODULE_2__["blurY"])({width: n, height: m, data: values1}, {width: n, height: m, data: values0}, r >> k);
    Object(_blur__WEBPACK_IMPORTED_MODULE_2__["blurX"])({width: n, height: m, data: values0}, {width: n, height: m, data: values1}, r >> k);
    Object(_blur__WEBPACK_IMPORTED_MODULE_2__["blurY"])({width: n, height: m, data: values1}, {width: n, height: m, data: values0}, r >> k);
    Object(_blur__WEBPACK_IMPORTED_MODULE_2__["blurX"])({width: n, height: m, data: values0}, {width: n, height: m, data: values1}, r >> k);
    Object(_blur__WEBPACK_IMPORTED_MODULE_2__["blurY"])({width: n, height: m, data: values1}, {width: n, height: m, data: values0}, r >> k);

    var tz = threshold(values0);

    // Convert number of thresholds into uniform thresholds.
    if (!Array.isArray(tz)) {
      var stop = Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["max"])(values0);
      tz = Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["tickStep"])(0, stop, tz);
      tz = Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["range"])(0, Math.floor(stop / tz) * tz, tz);
      tz.shift();
    }

    return Object(_contours__WEBPACK_IMPORTED_MODULE_4__["default"])()
        .thresholds(tz)
        .size([n, m])
      (values0)
        .map(transform);
  }

  function transform(geometry) {
    geometry.value *= Math.pow(2, -2 * k); // Density in points per square pixel.
    geometry.coordinates.forEach(transformPolygon);
    return geometry;
  }

  function transformPolygon(coordinates) {
    coordinates.forEach(transformRing);
  }

  function transformRing(coordinates) {
    coordinates.forEach(transformPoint);
  }

  // TODO Optimize.
  function transformPoint(coordinates) {
    coordinates[0] = coordinates[0] * Math.pow(2, k) - o;
    coordinates[1] = coordinates[1] * Math.pow(2, k) - o;
  }

  function resize() {
    o = r * 3;
    n = (dx + o * 2) >> k;
    m = (dy + o * 2) >> k;
    return density;
  }

  density.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_3__["default"])(+_), density) : x;
  };

  density.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_3__["default"])(+_), density) : y;
  };

  density.weight = function(_) {
    return arguments.length ? (weight = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_3__["default"])(+_), density) : weight;
  };

  density.size = function(_) {
    if (!arguments.length) return [dx, dy];
    var _0 = Math.ceil(_[0]), _1 = Math.ceil(_[1]);
    if (!(_0 >= 0) && !(_0 >= 0)) throw new Error("invalid size");
    return dx = _0, dy = _1, resize();
  };

  density.cellSize = function(_) {
    if (!arguments.length) return 1 << k;
    if (!((_ = +_) >= 1)) throw new Error("invalid cell size");
    return k = Math.floor(Math.log(_) / Math.LN2), resize();
  };

  density.thresholds = function(_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? Object(_constant__WEBPACK_IMPORTED_MODULE_3__["default"])(_array__WEBPACK_IMPORTED_MODULE_1__["slice"].call(_)) : Object(_constant__WEBPACK_IMPORTED_MODULE_3__["default"])(_), density) : threshold;
  };

  density.bandwidth = function(_) {
    if (!arguments.length) return Math.sqrt(r * (r + 1));
    if (!((_ = +_) >= 0)) throw new Error("invalid bandwidth");
    return r = Math.round((Math.sqrt(4 * _ * _ + 1) - 1) / 2), resize();
  };

  return density;
});


/***/ }),

/***/ "Spa3":
/*!*************************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/sequential-multi/viridis.js ***!
  \*************************************************************************/
/*! exports provided: default, magma, inferno, plasma */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "magma", function() { return magma; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inferno", function() { return inferno; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "plasma", function() { return plasma; });
/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors.js */ "ZtE7");


function ramp(range) {
  var n = range.length;
  return function(t) {
    return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
}

/* harmony default export */ __webpack_exports__["default"] = (ramp(Object(_colors_js__WEBPACK_IMPORTED_MODULE_0__["default"])("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725")));

var magma = ramp(Object(_colors_js__WEBPACK_IMPORTED_MODULE_0__["default"])("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));

var inferno = ramp(Object(_colors_js__WEBPACK_IMPORTED_MODULE_0__["default"])("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));

var plasma = ramp(Object(_colors_js__WEBPACK_IMPORTED_MODULE_0__["default"])("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));


/***/ }),

/***/ "SxqP":
/*!***************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/diverging/BrBG.js ***!
  \***************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors.js */ "ZtE7");
/* harmony import */ var _ramp_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp.js */ "jQWc");



var scheme = new Array(3).concat(
  "d8b365f5f5f55ab4ac",
  "a6611adfc27d80cdc1018571",
  "a6611adfc27df5f5f580cdc1018571",
  "8c510ad8b365f6e8c3c7eae55ab4ac01665e",
  "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e",
  "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e",
  "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e",
  "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30",
  "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30"
).map(_colors_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp_js__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "TKDR":
/*!********************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/resample.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _cartesian_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../cartesian.js */ "YzSS");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math.js */ "R0y8");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../transform.js */ "t9E6");




var maxDepth = 16, // maximum depth of subdivision
    cosMinDistance = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["cos"])(30 * _math_js__WEBPACK_IMPORTED_MODULE_1__["radians"]); // cos(minimum angular distance)

/* harmony default export */ __webpack_exports__["default"] = (function(project, delta2) {
  return +delta2 ? resample(project, delta2) : resampleNone(project);
});

function resampleNone(project) {
  return Object(_transform_js__WEBPACK_IMPORTED_MODULE_2__["transformer"])({
    point: function(x, y) {
      x = project(x, y);
      this.stream.point(x[0], x[1]);
    }
  });
}

function resample(project, delta2) {

  function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {
    var dx = x1 - x0,
        dy = y1 - y0,
        d2 = dx * dx + dy * dy;
    if (d2 > 4 * delta2 && depth--) {
      var a = a0 + a1,
          b = b0 + b1,
          c = c0 + c1,
          m = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(a * a + b * b + c * c),
          phi2 = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["asin"])(c /= m),
          lambda2 = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["abs"])(Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["abs"])(c) - 1) < _math_js__WEBPACK_IMPORTED_MODULE_1__["epsilon"] || Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["abs"])(lambda0 - lambda1) < _math_js__WEBPACK_IMPORTED_MODULE_1__["epsilon"] ? (lambda0 + lambda1) / 2 : Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["atan2"])(b, a),
          p = project(lambda2, phi2),
          x2 = p[0],
          y2 = p[1],
          dx2 = x2 - x0,
          dy2 = y2 - y0,
          dz = dy * dx2 - dx * dy2;
      if (dz * dz / d2 > delta2 // perpendicular projected distance
          || Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["abs"])((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end
          || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) { // angular distance
        resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);
        stream.point(x2, y2);
        resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);
      }
    }
  }
  return function(stream) {
    var lambda00, x00, y00, a00, b00, c00, // first point
        lambda0, x0, y0, a0, b0, c0; // previous point

    var resampleStream = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function() { stream.polygonStart(); resampleStream.lineStart = ringStart; },
      polygonEnd: function() { stream.polygonEnd(); resampleStream.lineStart = lineStart; }
    };

    function point(x, y) {
      x = project(x, y);
      stream.point(x[0], x[1]);
    }

    function lineStart() {
      x0 = NaN;
      resampleStream.point = linePoint;
      stream.lineStart();
    }

    function linePoint(lambda, phi) {
      var c = Object(_cartesian_js__WEBPACK_IMPORTED_MODULE_0__["cartesian"])([lambda, phi]), p = project(lambda, phi);
      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
      stream.point(x0, y0);
    }

    function lineEnd() {
      resampleStream.point = point;
      stream.lineEnd();
    }

    function ringStart() {
      lineStart();
      resampleStream.point = ringPoint;
      resampleStream.lineEnd = ringEnd;
    }

    function ringPoint(lambda, phi) {
      linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
      resampleStream.point = linePoint;
    }

    function ringEnd() {
      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);
      resampleStream.lineEnd = lineEnd;
      lineEnd();
    }

    return resampleStream;
  };
}


/***/ }),

/***/ "TQ5W":
/*!****************************************************************!*\
  !*** ./node_modules/c3/node_modules/d3-array/src/transpose.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _min__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./min */ "BuHV");


/* harmony default export */ __webpack_exports__["default"] = (function(matrix) {
  if (!(n = matrix.length)) return [];
  for (var i = -1, m = Object(_min__WEBPACK_IMPORTED_MODULE_0__["default"])(matrix, length), transpose = new Array(m); ++i < m;) {
    for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
      row[j] = matrix[j][i];
    }
  }
  return transpose;
});

function length(d) {
  return d.length;
}


/***/ }),

/***/ "TcI5":
/*!****************************************************************!*\
  !*** ./node_modules/c3/node_modules/d3-scale/src/diverging.js ***!
  \****************************************************************/
/*! exports provided: default, divergingLog, divergingSymlog, divergingPow, divergingSqrt */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return diverging; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divergingLog", function() { return divergingLog; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divergingSymlog", function() { return divergingSymlog; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divergingPow", function() { return divergingPow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divergingSqrt", function() { return divergingSqrt; });
/* harmony import */ var _continuous__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./continuous */ "A24K");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./init */ "//NX");
/* harmony import */ var _linear__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./linear */ "hdEp");
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./log */ "9pWx");
/* harmony import */ var _sequential__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./sequential */ "4Ztk");
/* harmony import */ var _symlog__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./symlog */ "kvQR");
/* harmony import */ var _pow__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./pow */ "AyrI");








function transformer() {
  var x0 = 0,
      x1 = 0.5,
      x2 = 1,
      t0,
      t1,
      t2,
      k10,
      k21,
      interpolator = _continuous__WEBPACK_IMPORTED_MODULE_0__["identity"],
      transform,
      clamp = false,
      unknown;

  function scale(x) {
    return isNaN(x = +x) ? unknown : (x = 0.5 + ((x = +transform(x)) - t1) * (x < t1 ? k10 : k21), interpolator(clamp ? Math.max(0, Math.min(1, x)) : x));
  }

  scale.domain = function(_) {
    return arguments.length ? (t0 = transform(x0 = +_[0]), t1 = transform(x1 = +_[1]), t2 = transform(x2 = +_[2]), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1), scale) : [x0, x1, x2];
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = !!_, scale) : clamp;
  };

  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  return function(t) {
    transform = t, t0 = t(x0), t1 = t(x1), t2 = t(x2), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1);
    return scale;
  };
}

function diverging() {
  var scale = Object(_linear__WEBPACK_IMPORTED_MODULE_2__["linearish"])(transformer()(_continuous__WEBPACK_IMPORTED_MODULE_0__["identity"]));

  scale.copy = function() {
    return Object(_sequential__WEBPACK_IMPORTED_MODULE_4__["copy"])(scale, diverging());
  };

  return _init__WEBPACK_IMPORTED_MODULE_1__["initInterpolator"].apply(scale, arguments);
}

function divergingLog() {
  var scale = Object(_log__WEBPACK_IMPORTED_MODULE_3__["loggish"])(transformer()).domain([0.1, 1, 10]);

  scale.copy = function() {
    return Object(_sequential__WEBPACK_IMPORTED_MODULE_4__["copy"])(scale, divergingLog()).base(scale.base());
  };

  return _init__WEBPACK_IMPORTED_MODULE_1__["initInterpolator"].apply(scale, arguments);
}

function divergingSymlog() {
  var scale = Object(_symlog__WEBPACK_IMPORTED_MODULE_5__["symlogish"])(transformer());

  scale.copy = function() {
    return Object(_sequential__WEBPACK_IMPORTED_MODULE_4__["copy"])(scale, divergingSymlog()).constant(scale.constant());
  };

  return _init__WEBPACK_IMPORTED_MODULE_1__["initInterpolator"].apply(scale, arguments);
}

function divergingPow() {
  var scale = Object(_pow__WEBPACK_IMPORTED_MODULE_6__["powish"])(transformer());

  scale.copy = function() {
    return Object(_sequential__WEBPACK_IMPORTED_MODULE_4__["copy"])(scale, divergingPow()).exponent(scale.exponent());
  };

  return _init__WEBPACK_IMPORTED_MODULE_1__["initInterpolator"].apply(scale, arguments);
}

function divergingSqrt() {
  return divergingPow.apply(null, arguments).exponent(0.5);
}


/***/ }),

/***/ "UQyC":
/*!**************************************************!*\
  !*** ./node_modules/c3/node_modules/d3/index.js ***!
  \**************************************************/
/*! exports provided: version, bisect, bisectRight, bisectLeft, ascending, bisector, cross, descending, deviation, extent, histogram, thresholdFreedmanDiaconis, thresholdScott, thresholdSturges, max, mean, median, merge, min, pairs, permute, quantile, range, scan, shuffle, sum, ticks, tickIncrement, tickStep, transpose, variance, zip, axisTop, axisRight, axisBottom, axisLeft, brush, brushX, brushY, brushSelection, chord, ribbon, nest, set, map, keys, values, entries, color, rgb, hsl, lab, hcl, lch, gray, cubehelix, contours, contourDensity, dispatch, drag, dragDisable, dragEnable, dsvFormat, csvParse, csvParseRows, csvFormat, csvFormatBody, csvFormatRows, csvFormatRow, csvFormatValue, tsvParse, tsvParseRows, tsvFormat, tsvFormatBody, tsvFormatRows, tsvFormatRow, tsvFormatValue, autoType, easeLinear, easeQuad, easeQuadIn, easeQuadOut, easeQuadInOut, easeCubic, easeCubicIn, easeCubicOut, easeCubicInOut, easePoly, easePolyIn, easePolyOut, easePolyInOut, easeSin, easeSinIn, easeSinOut, easeSinInOut, easeExp, easeExpIn, easeExpOut, easeExpInOut, easeCircle, easeCircleIn, easeCircleOut, easeCircleInOut, easeBounce, easeBounceIn, easeBounceOut, easeBounceInOut, easeBack, easeBackIn, easeBackOut, easeBackInOut, easeElastic, easeElasticIn, easeElasticOut, easeElasticInOut, blob, buffer, dsv, csv, tsv, image, json, text, xml, html, svg, forceCenter, forceCollide, forceLink, forceManyBody, forceRadial, forceSimulation, forceX, forceY, formatDefaultLocale, format, formatPrefix, formatLocale, formatSpecifier, FormatSpecifier, precisionFixed, precisionPrefix, precisionRound, geoArea, geoBounds, geoCentroid, geoCircle, geoClipAntimeridian, geoClipCircle, geoClipExtent, geoClipRectangle, geoContains, geoDistance, geoGraticule, geoGraticule10, geoInterpolate, geoLength, geoPath, geoAlbers, geoAlbersUsa, geoAzimuthalEqualArea, geoAzimuthalEqualAreaRaw, geoAzimuthalEquidistant, geoAzimuthalEquidistantRaw, geoConicConformal, geoConicConformalRaw, geoConicEqualArea, geoConicEqualAreaRaw, geoConicEquidistant, geoConicEquidistantRaw, geoEqualEarth, geoEqualEarthRaw, geoEquirectangular, geoEquirectangularRaw, geoGnomonic, geoGnomonicRaw, geoIdentity, geoProjection, geoProjectionMutator, geoMercator, geoMercatorRaw, geoNaturalEarth1, geoNaturalEarth1Raw, geoOrthographic, geoOrthographicRaw, geoStereographic, geoStereographicRaw, geoTransverseMercator, geoTransverseMercatorRaw, geoRotation, geoStream, geoTransform, cluster, hierarchy, pack, packSiblings, packEnclose, partition, stratify, tree, treemap, treemapBinary, treemapDice, treemapSlice, treemapSliceDice, treemapSquarify, treemapResquarify, interpolate, interpolateArray, interpolateBasis, interpolateBasisClosed, interpolateDate, interpolateDiscrete, interpolateHue, interpolateNumber, interpolateNumberArray, interpolateObject, interpolateRound, interpolateString, interpolateTransformCss, interpolateTransformSvg, interpolateZoom, interpolateRgb, interpolateRgbBasis, interpolateRgbBasisClosed, interpolateHsl, interpolateHslLong, interpolateLab, interpolateHcl, interpolateHclLong, interpolateCubehelix, interpolateCubehelixLong, piecewise, quantize, path, polygonArea, polygonCentroid, polygonHull, polygonContains, polygonLength, quadtree, randomUniform, randomNormal, randomLogNormal, randomBates, randomIrwinHall, randomExponential, scaleBand, scalePoint, scaleIdentity, scaleLinear, scaleLog, scaleSymlog, scaleOrdinal, scaleImplicit, scalePow, scaleSqrt, scaleQuantile, scaleQuantize, scaleThreshold, scaleTime, scaleUtc, scaleSequential, scaleSequentialLog, scaleSequentialPow, scaleSequentialSqrt, scaleSequentialSymlog, scaleSequentialQuantile, scaleDiverging, scaleDivergingLog, scaleDivergingPow, scaleDivergingSqrt, scaleDivergingSymlog, tickFormat, schemeCategory10, schemeAccent, schemeDark2, schemePaired, schemePastel1, schemePastel2, schemeSet1, schemeSet2, schemeSet3, schemeTableau10, interpolateBrBG, schemeBrBG, interpolatePRGn, schemePRGn, interpolatePiYG, schemePiYG, interpolatePuOr, schemePuOr, interpolateRdBu, schemeRdBu, interpolateRdGy, schemeRdGy, interpolateRdYlBu, schemeRdYlBu, interpolateRdYlGn, schemeRdYlGn, interpolateSpectral, schemeSpectral, interpolateBuGn, schemeBuGn, interpolateBuPu, schemeBuPu, interpolateGnBu, schemeGnBu, interpolateOrRd, schemeOrRd, interpolatePuBuGn, schemePuBuGn, interpolatePuBu, schemePuBu, interpolatePuRd, schemePuRd, interpolateRdPu, schemeRdPu, interpolateYlGnBu, schemeYlGnBu, interpolateYlGn, schemeYlGn, interpolateYlOrBr, schemeYlOrBr, interpolateYlOrRd, schemeYlOrRd, interpolateBlues, schemeBlues, interpolateGreens, schemeGreens, interpolateGreys, schemeGreys, interpolatePurples, schemePurples, interpolateReds, schemeReds, interpolateOranges, schemeOranges, interpolateCividis, interpolateCubehelixDefault, interpolateRainbow, interpolateWarm, interpolateCool, interpolateSinebow, interpolateTurbo, interpolateViridis, interpolateMagma, interpolateInferno, interpolatePlasma, create, creator, local, matcher, mouse, namespace, namespaces, clientPoint, select, selectAll, selection, selector, selectorAll, style, touch, touches, window, event, customEvent, arc, area, line, pie, areaRadial, radialArea, lineRadial, radialLine, pointRadial, linkHorizontal, linkVertical, linkRadial, symbol, symbols, symbolCircle, symbolCross, symbolDiamond, symbolSquare, symbolStar, symbolTriangle, symbolWye, curveBasisClosed, curveBasisOpen, curveBasis, curveBundle, curveCardinalClosed, curveCardinalOpen, curveCardinal, curveCatmullRomClosed, curveCatmullRomOpen, curveCatmullRom, curveLinearClosed, curveLinear, curveMonotoneX, curveMonotoneY, curveNatural, curveStep, curveStepAfter, curveStepBefore, stack, stackOffsetExpand, stackOffsetDiverging, stackOffsetNone, stackOffsetSilhouette, stackOffsetWiggle, stackOrderAppearance, stackOrderAscending, stackOrderDescending, stackOrderInsideOut, stackOrderNone, stackOrderReverse, timeInterval, timeMillisecond, timeMilliseconds, utcMillisecond, utcMilliseconds, timeSecond, timeSeconds, utcSecond, utcSeconds, timeMinute, timeMinutes, timeHour, timeHours, timeDay, timeDays, timeWeek, timeWeeks, timeSunday, timeSundays, timeMonday, timeMondays, timeTuesday, timeTuesdays, timeWednesday, timeWednesdays, timeThursday, timeThursdays, timeFriday, timeFridays, timeSaturday, timeSaturdays, timeMonth, timeMonths, timeYear, timeYears, utcMinute, utcMinutes, utcHour, utcHours, utcDay, utcDays, utcWeek, utcWeeks, utcSunday, utcSundays, utcMonday, utcMondays, utcTuesday, utcTuesdays, utcWednesday, utcWednesdays, utcThursday, utcThursdays, utcFriday, utcFridays, utcSaturday, utcSaturdays, utcMonth, utcMonths, utcYear, utcYears, timeFormatDefaultLocale, timeFormat, timeParse, utcFormat, utcParse, timeFormatLocale, isoFormat, isoParse, now, timer, timerFlush, timeout, interval, transition, active, interrupt, voronoi, zoom, zoomTransform, zoomIdentity */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _dist_package_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/package.js */ "/IEk");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "version", function() { return _dist_package_js__WEBPACK_IMPORTED_MODULE_0__["version"]; });

/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-array */ "sRF9");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bisect", function() { return d3_array__WEBPACK_IMPORTED_MODULE_1__["bisect"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bisectRight", function() { return d3_array__WEBPACK_IMPORTED_MODULE_1__["bisectRight"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bisectLeft", function() { return d3_array__WEBPACK_IMPORTED_MODULE_1__["bisectLeft"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ascending", function() { return d3_array__WEBPACK_IMPORTED_MODULE_1__["ascending"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bisector", function() { return d3_array__WEBPACK_IMPORTED_MODULE_1__["bisector"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cross", function() { return d3_array__WEBPACK_IMPORTED_MODULE_1__["cross"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "descending", function() { return d3_array__WEBPACK_IMPORTED_MODULE_1__["descending"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "deviation", function() { return d3_array__WEBPACK_IMPORTED_MODULE_1__["deviation"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extent", function() { return d3_array__WEBPACK_IMPORTED_MODULE_1__["extent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "histogram", function() { return d3_array__WEBPACK_IMPORTED_MODULE_1__["histogram"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "thresholdFreedmanDiaconis", function() { return d3_array__WEBPACK_IMPORTED_MODULE_1__["thresholdFreedmanDiaconis"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "thresholdScott", function() { return d3_array__WEBPACK_IMPORTED_MODULE_1__["thresholdScott"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "thresholdSturges", function() { return d3_array__WEBPACK_IMPORTED_MODULE_1__["thresholdSturges"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "max", function() { return d3_array__WEBPACK_IMPORTED_MODULE_1__["max"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mean", function() { return d3_array__WEBPACK_IMPORTED_MODULE_1__["mean"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "median", function() { return d3_array__WEBPACK_IMPORTED_MODULE_1__["median"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "merge", function() { return d3_array__WEBPACK_IMPORTED_MODULE_1__["merge"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "min", function() { return d3_array__WEBPACK_IMPORTED_MODULE_1__["min"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pairs", function() { return d3_array__WEBPACK_IMPORTED_MODULE_1__["pairs"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "permute", function() { return d3_array__WEBPACK_IMPORTED_MODULE_1__["permute"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "quantile", function() { return d3_array__WEBPACK_IMPORTED_MODULE_1__["quantile"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "range", function() { return d3_array__WEBPACK_IMPORTED_MODULE_1__["range"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scan", function() { return d3_array__WEBPACK_IMPORTED_MODULE_1__["scan"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "shuffle", function() { return d3_array__WEBPACK_IMPORTED_MODULE_1__["shuffle"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sum", function() { return d3_array__WEBPACK_IMPORTED_MODULE_1__["sum"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ticks", function() { return d3_array__WEBPACK_IMPORTED_MODULE_1__["ticks"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tickIncrement", function() { return d3_array__WEBPACK_IMPORTED_MODULE_1__["tickIncrement"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tickStep", function() { return d3_array__WEBPACK_IMPORTED_MODULE_1__["tickStep"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "transpose", function() { return d3_array__WEBPACK_IMPORTED_MODULE_1__["transpose"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "variance", function() { return d3_array__WEBPACK_IMPORTED_MODULE_1__["variance"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zip", function() { return d3_array__WEBPACK_IMPORTED_MODULE_1__["zip"]; });

/* harmony import */ var d3_axis__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-axis */ "RhHs");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "axisTop", function() { return d3_axis__WEBPACK_IMPORTED_MODULE_2__["axisTop"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "axisRight", function() { return d3_axis__WEBPACK_IMPORTED_MODULE_2__["axisRight"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "axisBottom", function() { return d3_axis__WEBPACK_IMPORTED_MODULE_2__["axisBottom"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "axisLeft", function() { return d3_axis__WEBPACK_IMPORTED_MODULE_2__["axisLeft"]; });

/* harmony import */ var d3_brush__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-brush */ "X486");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "brush", function() { return d3_brush__WEBPACK_IMPORTED_MODULE_3__["brush"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "brushX", function() { return d3_brush__WEBPACK_IMPORTED_MODULE_3__["brushX"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "brushY", function() { return d3_brush__WEBPACK_IMPORTED_MODULE_3__["brushY"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "brushSelection", function() { return d3_brush__WEBPACK_IMPORTED_MODULE_3__["brushSelection"]; });

/* harmony import */ var d3_chord__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-chord */ "+u7/");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "chord", function() { return d3_chord__WEBPACK_IMPORTED_MODULE_4__["chord"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ribbon", function() { return d3_chord__WEBPACK_IMPORTED_MODULE_4__["ribbon"]; });

/* harmony import */ var d3_collection__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-collection */ "bwSX");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "nest", function() { return d3_collection__WEBPACK_IMPORTED_MODULE_5__["nest"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "set", function() { return d3_collection__WEBPACK_IMPORTED_MODULE_5__["set"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "map", function() { return d3_collection__WEBPACK_IMPORTED_MODULE_5__["map"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "keys", function() { return d3_collection__WEBPACK_IMPORTED_MODULE_5__["keys"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "values", function() { return d3_collection__WEBPACK_IMPORTED_MODULE_5__["values"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "entries", function() { return d3_collection__WEBPACK_IMPORTED_MODULE_5__["entries"]; });

/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-color */ "SC+/");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "color", function() { return d3_color__WEBPACK_IMPORTED_MODULE_6__["color"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "rgb", function() { return d3_color__WEBPACK_IMPORTED_MODULE_6__["rgb"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hsl", function() { return d3_color__WEBPACK_IMPORTED_MODULE_6__["hsl"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lab", function() { return d3_color__WEBPACK_IMPORTED_MODULE_6__["lab"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hcl", function() { return d3_color__WEBPACK_IMPORTED_MODULE_6__["hcl"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lch", function() { return d3_color__WEBPACK_IMPORTED_MODULE_6__["lch"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "gray", function() { return d3_color__WEBPACK_IMPORTED_MODULE_6__["gray"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cubehelix", function() { return d3_color__WEBPACK_IMPORTED_MODULE_6__["cubehelix"]; });

/* harmony import */ var d3_contour__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-contour */ "zMfI");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "contours", function() { return d3_contour__WEBPACK_IMPORTED_MODULE_7__["contours"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "contourDensity", function() { return d3_contour__WEBPACK_IMPORTED_MODULE_7__["contourDensity"]; });

/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-dispatch */ "30U6");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dispatch", function() { return d3_dispatch__WEBPACK_IMPORTED_MODULE_8__["dispatch"]; });

/* harmony import */ var d3_drag__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-drag */ "q+nN");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "drag", function() { return d3_drag__WEBPACK_IMPORTED_MODULE_9__["drag"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dragDisable", function() { return d3_drag__WEBPACK_IMPORTED_MODULE_9__["dragDisable"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dragEnable", function() { return d3_drag__WEBPACK_IMPORTED_MODULE_9__["dragEnable"]; });

/* harmony import */ var d3_dsv__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-dsv */ "6yeX");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dsvFormat", function() { return d3_dsv__WEBPACK_IMPORTED_MODULE_10__["dsvFormat"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "csvParse", function() { return d3_dsv__WEBPACK_IMPORTED_MODULE_10__["csvParse"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "csvParseRows", function() { return d3_dsv__WEBPACK_IMPORTED_MODULE_10__["csvParseRows"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "csvFormat", function() { return d3_dsv__WEBPACK_IMPORTED_MODULE_10__["csvFormat"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "csvFormatBody", function() { return d3_dsv__WEBPACK_IMPORTED_MODULE_10__["csvFormatBody"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "csvFormatRows", function() { return d3_dsv__WEBPACK_IMPORTED_MODULE_10__["csvFormatRows"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "csvFormatRow", function() { return d3_dsv__WEBPACK_IMPORTED_MODULE_10__["csvFormatRow"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "csvFormatValue", function() { return d3_dsv__WEBPACK_IMPORTED_MODULE_10__["csvFormatValue"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tsvParse", function() { return d3_dsv__WEBPACK_IMPORTED_MODULE_10__["tsvParse"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tsvParseRows", function() { return d3_dsv__WEBPACK_IMPORTED_MODULE_10__["tsvParseRows"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tsvFormat", function() { return d3_dsv__WEBPACK_IMPORTED_MODULE_10__["tsvFormat"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tsvFormatBody", function() { return d3_dsv__WEBPACK_IMPORTED_MODULE_10__["tsvFormatBody"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tsvFormatRows", function() { return d3_dsv__WEBPACK_IMPORTED_MODULE_10__["tsvFormatRows"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tsvFormatRow", function() { return d3_dsv__WEBPACK_IMPORTED_MODULE_10__["tsvFormatRow"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tsvFormatValue", function() { return d3_dsv__WEBPACK_IMPORTED_MODULE_10__["tsvFormatValue"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "autoType", function() { return d3_dsv__WEBPACK_IMPORTED_MODULE_10__["autoType"]; });

/* harmony import */ var d3_ease__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! d3-ease */ "zUi6");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeLinear", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_11__["easeLinear"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeQuad", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_11__["easeQuad"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeQuadIn", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_11__["easeQuadIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeQuadOut", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_11__["easeQuadOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeQuadInOut", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_11__["easeQuadInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCubic", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_11__["easeCubic"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCubicIn", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_11__["easeCubicIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCubicOut", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_11__["easeCubicOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCubicInOut", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_11__["easeCubicInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easePoly", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_11__["easePoly"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easePolyIn", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_11__["easePolyIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easePolyOut", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_11__["easePolyOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easePolyInOut", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_11__["easePolyInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeSin", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_11__["easeSin"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeSinIn", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_11__["easeSinIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeSinOut", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_11__["easeSinOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeSinInOut", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_11__["easeSinInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeExp", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_11__["easeExp"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeExpIn", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_11__["easeExpIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeExpOut", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_11__["easeExpOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeExpInOut", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_11__["easeExpInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCircle", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_11__["easeCircle"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCircleIn", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_11__["easeCircleIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCircleOut", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_11__["easeCircleOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCircleInOut", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_11__["easeCircleInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBounce", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_11__["easeBounce"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBounceIn", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_11__["easeBounceIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBounceOut", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_11__["easeBounceOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBounceInOut", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_11__["easeBounceInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBack", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_11__["easeBack"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBackIn", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_11__["easeBackIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBackOut", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_11__["easeBackOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBackInOut", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_11__["easeBackInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeElastic", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_11__["easeElastic"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeElasticIn", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_11__["easeElasticIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeElasticOut", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_11__["easeElasticOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeElasticInOut", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_11__["easeElasticInOut"]; });

/* harmony import */ var d3_fetch__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! d3-fetch */ "sukG");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "blob", function() { return d3_fetch__WEBPACK_IMPORTED_MODULE_12__["blob"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "buffer", function() { return d3_fetch__WEBPACK_IMPORTED_MODULE_12__["buffer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dsv", function() { return d3_fetch__WEBPACK_IMPORTED_MODULE_12__["dsv"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "csv", function() { return d3_fetch__WEBPACK_IMPORTED_MODULE_12__["csv"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tsv", function() { return d3_fetch__WEBPACK_IMPORTED_MODULE_12__["tsv"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "image", function() { return d3_fetch__WEBPACK_IMPORTED_MODULE_12__["image"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "json", function() { return d3_fetch__WEBPACK_IMPORTED_MODULE_12__["json"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "text", function() { return d3_fetch__WEBPACK_IMPORTED_MODULE_12__["text"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "xml", function() { return d3_fetch__WEBPACK_IMPORTED_MODULE_12__["xml"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "html", function() { return d3_fetch__WEBPACK_IMPORTED_MODULE_12__["html"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "svg", function() { return d3_fetch__WEBPACK_IMPORTED_MODULE_12__["svg"]; });

/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! d3-force */ "Ckr6");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "forceCenter", function() { return d3_force__WEBPACK_IMPORTED_MODULE_13__["forceCenter"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "forceCollide", function() { return d3_force__WEBPACK_IMPORTED_MODULE_13__["forceCollide"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "forceLink", function() { return d3_force__WEBPACK_IMPORTED_MODULE_13__["forceLink"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "forceManyBody", function() { return d3_force__WEBPACK_IMPORTED_MODULE_13__["forceManyBody"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "forceRadial", function() { return d3_force__WEBPACK_IMPORTED_MODULE_13__["forceRadial"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "forceSimulation", function() { return d3_force__WEBPACK_IMPORTED_MODULE_13__["forceSimulation"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "forceX", function() { return d3_force__WEBPACK_IMPORTED_MODULE_13__["forceX"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "forceY", function() { return d3_force__WEBPACK_IMPORTED_MODULE_13__["forceY"]; });

/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! d3-format */ "rWgG");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "formatDefaultLocale", function() { return d3_format__WEBPACK_IMPORTED_MODULE_14__["formatDefaultLocale"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "format", function() { return d3_format__WEBPACK_IMPORTED_MODULE_14__["format"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "formatPrefix", function() { return d3_format__WEBPACK_IMPORTED_MODULE_14__["formatPrefix"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "formatLocale", function() { return d3_format__WEBPACK_IMPORTED_MODULE_14__["formatLocale"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "formatSpecifier", function() { return d3_format__WEBPACK_IMPORTED_MODULE_14__["formatSpecifier"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FormatSpecifier", function() { return d3_format__WEBPACK_IMPORTED_MODULE_14__["FormatSpecifier"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "precisionFixed", function() { return d3_format__WEBPACK_IMPORTED_MODULE_14__["precisionFixed"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "precisionPrefix", function() { return d3_format__WEBPACK_IMPORTED_MODULE_14__["precisionPrefix"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "precisionRound", function() { return d3_format__WEBPACK_IMPORTED_MODULE_14__["precisionRound"]; });

/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! d3-geo */ "n8A4");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoArea", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_15__["geoArea"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoBounds", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_15__["geoBounds"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoCentroid", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_15__["geoCentroid"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoCircle", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_15__["geoCircle"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoClipAntimeridian", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_15__["geoClipAntimeridian"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoClipCircle", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_15__["geoClipCircle"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoClipExtent", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_15__["geoClipExtent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoClipRectangle", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_15__["geoClipRectangle"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoContains", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_15__["geoContains"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoDistance", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_15__["geoDistance"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGraticule", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_15__["geoGraticule"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGraticule10", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_15__["geoGraticule10"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoInterpolate", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_15__["geoInterpolate"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoLength", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_15__["geoLength"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoPath", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_15__["geoPath"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAlbers", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_15__["geoAlbers"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAlbersUsa", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_15__["geoAlbersUsa"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAzimuthalEqualArea", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_15__["geoAzimuthalEqualArea"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAzimuthalEqualAreaRaw", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_15__["geoAzimuthalEqualAreaRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAzimuthalEquidistant", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_15__["geoAzimuthalEquidistant"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAzimuthalEquidistantRaw", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_15__["geoAzimuthalEquidistantRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoConicConformal", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_15__["geoConicConformal"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoConicConformalRaw", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_15__["geoConicConformalRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoConicEqualArea", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_15__["geoConicEqualArea"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoConicEqualAreaRaw", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_15__["geoConicEqualAreaRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoConicEquidistant", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_15__["geoConicEquidistant"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoConicEquidistantRaw", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_15__["geoConicEquidistantRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEqualEarth", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_15__["geoEqualEarth"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEqualEarthRaw", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_15__["geoEqualEarthRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEquirectangular", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_15__["geoEquirectangular"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEquirectangularRaw", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_15__["geoEquirectangularRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGnomonic", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_15__["geoGnomonic"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGnomonicRaw", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_15__["geoGnomonicRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoIdentity", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_15__["geoIdentity"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoProjection", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_15__["geoProjection"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoProjectionMutator", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_15__["geoProjectionMutator"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoMercator", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_15__["geoMercator"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoMercatorRaw", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_15__["geoMercatorRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoNaturalEarth1", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_15__["geoNaturalEarth1"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoNaturalEarth1Raw", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_15__["geoNaturalEarth1Raw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoOrthographic", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_15__["geoOrthographic"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoOrthographicRaw", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_15__["geoOrthographicRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoStereographic", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_15__["geoStereographic"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoStereographicRaw", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_15__["geoStereographicRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoTransverseMercator", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_15__["geoTransverseMercator"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoTransverseMercatorRaw", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_15__["geoTransverseMercatorRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoRotation", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_15__["geoRotation"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoStream", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_15__["geoStream"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoTransform", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_15__["geoTransform"]; });

/* harmony import */ var d3_hierarchy__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! d3-hierarchy */ "yUfG");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cluster", function() { return d3_hierarchy__WEBPACK_IMPORTED_MODULE_16__["cluster"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hierarchy", function() { return d3_hierarchy__WEBPACK_IMPORTED_MODULE_16__["hierarchy"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pack", function() { return d3_hierarchy__WEBPACK_IMPORTED_MODULE_16__["pack"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "packSiblings", function() { return d3_hierarchy__WEBPACK_IMPORTED_MODULE_16__["packSiblings"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "packEnclose", function() { return d3_hierarchy__WEBPACK_IMPORTED_MODULE_16__["packEnclose"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "partition", function() { return d3_hierarchy__WEBPACK_IMPORTED_MODULE_16__["partition"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stratify", function() { return d3_hierarchy__WEBPACK_IMPORTED_MODULE_16__["stratify"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tree", function() { return d3_hierarchy__WEBPACK_IMPORTED_MODULE_16__["tree"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "treemap", function() { return d3_hierarchy__WEBPACK_IMPORTED_MODULE_16__["treemap"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "treemapBinary", function() { return d3_hierarchy__WEBPACK_IMPORTED_MODULE_16__["treemapBinary"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "treemapDice", function() { return d3_hierarchy__WEBPACK_IMPORTED_MODULE_16__["treemapDice"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "treemapSlice", function() { return d3_hierarchy__WEBPACK_IMPORTED_MODULE_16__["treemapSlice"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "treemapSliceDice", function() { return d3_hierarchy__WEBPACK_IMPORTED_MODULE_16__["treemapSliceDice"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "treemapSquarify", function() { return d3_hierarchy__WEBPACK_IMPORTED_MODULE_16__["treemapSquarify"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "treemapResquarify", function() { return d3_hierarchy__WEBPACK_IMPORTED_MODULE_16__["treemapResquarify"]; });

/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! d3-interpolate */ "pD2Y");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolate", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_17__["interpolate"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateArray", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_17__["interpolateArray"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateBasis", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_17__["interpolateBasis"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateBasisClosed", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_17__["interpolateBasisClosed"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateDate", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_17__["interpolateDate"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateDiscrete", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_17__["interpolateDiscrete"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateHue", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_17__["interpolateHue"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateNumber", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_17__["interpolateNumber"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateNumberArray", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_17__["interpolateNumberArray"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateObject", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_17__["interpolateObject"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRound", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_17__["interpolateRound"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateString", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_17__["interpolateString"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateTransformCss", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_17__["interpolateTransformCss"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateTransformSvg", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_17__["interpolateTransformSvg"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateZoom", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_17__["interpolateZoom"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRgb", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_17__["interpolateRgb"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRgbBasis", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_17__["interpolateRgbBasis"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRgbBasisClosed", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_17__["interpolateRgbBasisClosed"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateHsl", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_17__["interpolateHsl"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateHslLong", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_17__["interpolateHslLong"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateLab", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_17__["interpolateLab"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateHcl", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_17__["interpolateHcl"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateHclLong", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_17__["interpolateHclLong"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateCubehelix", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_17__["interpolateCubehelix"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateCubehelixLong", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_17__["interpolateCubehelixLong"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "piecewise", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_17__["piecewise"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "quantize", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_17__["quantize"]; });

/* harmony import */ var d3_path__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! d3-path */ "83xM");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "path", function() { return d3_path__WEBPACK_IMPORTED_MODULE_18__["path"]; });

/* harmony import */ var d3_polygon__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! d3-polygon */ "tUiF");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "polygonArea", function() { return d3_polygon__WEBPACK_IMPORTED_MODULE_19__["polygonArea"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "polygonCentroid", function() { return d3_polygon__WEBPACK_IMPORTED_MODULE_19__["polygonCentroid"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "polygonHull", function() { return d3_polygon__WEBPACK_IMPORTED_MODULE_19__["polygonHull"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "polygonContains", function() { return d3_polygon__WEBPACK_IMPORTED_MODULE_19__["polygonContains"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "polygonLength", function() { return d3_polygon__WEBPACK_IMPORTED_MODULE_19__["polygonLength"]; });

/* harmony import */ var d3_quadtree__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! d3-quadtree */ "gO8D");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "quadtree", function() { return d3_quadtree__WEBPACK_IMPORTED_MODULE_20__["quadtree"]; });

/* harmony import */ var d3_random__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! d3-random */ "7MRl");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "randomUniform", function() { return d3_random__WEBPACK_IMPORTED_MODULE_21__["randomUniform"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "randomNormal", function() { return d3_random__WEBPACK_IMPORTED_MODULE_21__["randomNormal"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "randomLogNormal", function() { return d3_random__WEBPACK_IMPORTED_MODULE_21__["randomLogNormal"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "randomBates", function() { return d3_random__WEBPACK_IMPORTED_MODULE_21__["randomBates"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "randomIrwinHall", function() { return d3_random__WEBPACK_IMPORTED_MODULE_21__["randomIrwinHall"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "randomExponential", function() { return d3_random__WEBPACK_IMPORTED_MODULE_21__["randomExponential"]; });

/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! d3-scale */ "4Oje");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleBand", function() { return d3_scale__WEBPACK_IMPORTED_MODULE_22__["scaleBand"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scalePoint", function() { return d3_scale__WEBPACK_IMPORTED_MODULE_22__["scalePoint"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleIdentity", function() { return d3_scale__WEBPACK_IMPORTED_MODULE_22__["scaleIdentity"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleLinear", function() { return d3_scale__WEBPACK_IMPORTED_MODULE_22__["scaleLinear"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleLog", function() { return d3_scale__WEBPACK_IMPORTED_MODULE_22__["scaleLog"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleSymlog", function() { return d3_scale__WEBPACK_IMPORTED_MODULE_22__["scaleSymlog"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleOrdinal", function() { return d3_scale__WEBPACK_IMPORTED_MODULE_22__["scaleOrdinal"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleImplicit", function() { return d3_scale__WEBPACK_IMPORTED_MODULE_22__["scaleImplicit"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scalePow", function() { return d3_scale__WEBPACK_IMPORTED_MODULE_22__["scalePow"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleSqrt", function() { return d3_scale__WEBPACK_IMPORTED_MODULE_22__["scaleSqrt"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleQuantile", function() { return d3_scale__WEBPACK_IMPORTED_MODULE_22__["scaleQuantile"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleQuantize", function() { return d3_scale__WEBPACK_IMPORTED_MODULE_22__["scaleQuantize"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleThreshold", function() { return d3_scale__WEBPACK_IMPORTED_MODULE_22__["scaleThreshold"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleTime", function() { return d3_scale__WEBPACK_IMPORTED_MODULE_22__["scaleTime"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleUtc", function() { return d3_scale__WEBPACK_IMPORTED_MODULE_22__["scaleUtc"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleSequential", function() { return d3_scale__WEBPACK_IMPORTED_MODULE_22__["scaleSequential"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleSequentialLog", function() { return d3_scale__WEBPACK_IMPORTED_MODULE_22__["scaleSequentialLog"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleSequentialPow", function() { return d3_scale__WEBPACK_IMPORTED_MODULE_22__["scaleSequentialPow"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleSequentialSqrt", function() { return d3_scale__WEBPACK_IMPORTED_MODULE_22__["scaleSequentialSqrt"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleSequentialSymlog", function() { return d3_scale__WEBPACK_IMPORTED_MODULE_22__["scaleSequentialSymlog"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleSequentialQuantile", function() { return d3_scale__WEBPACK_IMPORTED_MODULE_22__["scaleSequentialQuantile"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleDiverging", function() { return d3_scale__WEBPACK_IMPORTED_MODULE_22__["scaleDiverging"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleDivergingLog", function() { return d3_scale__WEBPACK_IMPORTED_MODULE_22__["scaleDivergingLog"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleDivergingPow", function() { return d3_scale__WEBPACK_IMPORTED_MODULE_22__["scaleDivergingPow"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleDivergingSqrt", function() { return d3_scale__WEBPACK_IMPORTED_MODULE_22__["scaleDivergingSqrt"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleDivergingSymlog", function() { return d3_scale__WEBPACK_IMPORTED_MODULE_22__["scaleDivergingSymlog"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tickFormat", function() { return d3_scale__WEBPACK_IMPORTED_MODULE_22__["tickFormat"]; });

/* harmony import */ var d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! d3-scale-chromatic */ "oetV");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeCategory10", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["schemeCategory10"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeAccent", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["schemeAccent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeDark2", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["schemeDark2"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemePaired", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["schemePaired"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemePastel1", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["schemePastel1"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemePastel2", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["schemePastel2"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeSet1", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["schemeSet1"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeSet2", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["schemeSet2"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeSet3", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["schemeSet3"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeTableau10", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["schemeTableau10"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateBrBG", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["interpolateBrBG"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeBrBG", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["schemeBrBG"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolatePRGn", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["interpolatePRGn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemePRGn", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["schemePRGn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolatePiYG", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["interpolatePiYG"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemePiYG", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["schemePiYG"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolatePuOr", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["interpolatePuOr"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemePuOr", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["schemePuOr"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRdBu", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["interpolateRdBu"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeRdBu", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["schemeRdBu"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRdGy", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["interpolateRdGy"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeRdGy", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["schemeRdGy"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRdYlBu", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["interpolateRdYlBu"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeRdYlBu", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["schemeRdYlBu"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRdYlGn", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["interpolateRdYlGn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeRdYlGn", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["schemeRdYlGn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateSpectral", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["interpolateSpectral"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeSpectral", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["schemeSpectral"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateBuGn", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["interpolateBuGn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeBuGn", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["schemeBuGn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateBuPu", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["interpolateBuPu"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeBuPu", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["schemeBuPu"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateGnBu", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["interpolateGnBu"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeGnBu", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["schemeGnBu"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateOrRd", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["interpolateOrRd"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeOrRd", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["schemeOrRd"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolatePuBuGn", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["interpolatePuBuGn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemePuBuGn", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["schemePuBuGn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolatePuBu", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["interpolatePuBu"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemePuBu", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["schemePuBu"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolatePuRd", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["interpolatePuRd"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemePuRd", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["schemePuRd"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRdPu", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["interpolateRdPu"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeRdPu", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["schemeRdPu"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateYlGnBu", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["interpolateYlGnBu"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeYlGnBu", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["schemeYlGnBu"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateYlGn", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["interpolateYlGn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeYlGn", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["schemeYlGn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateYlOrBr", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["interpolateYlOrBr"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeYlOrBr", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["schemeYlOrBr"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateYlOrRd", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["interpolateYlOrRd"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeYlOrRd", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["schemeYlOrRd"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateBlues", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["interpolateBlues"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeBlues", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["schemeBlues"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateGreens", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["interpolateGreens"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeGreens", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["schemeGreens"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateGreys", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["interpolateGreys"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeGreys", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["schemeGreys"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolatePurples", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["interpolatePurples"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemePurples", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["schemePurples"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateReds", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["interpolateReds"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeReds", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["schemeReds"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateOranges", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["interpolateOranges"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeOranges", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["schemeOranges"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateCividis", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["interpolateCividis"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateCubehelixDefault", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["interpolateCubehelixDefault"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRainbow", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["interpolateRainbow"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateWarm", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["interpolateWarm"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateCool", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["interpolateCool"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateSinebow", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["interpolateSinebow"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateTurbo", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["interpolateTurbo"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateViridis", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["interpolateViridis"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateMagma", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["interpolateMagma"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateInferno", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["interpolateInferno"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolatePlasma", function() { return d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["interpolatePlasma"]; });

/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! d3-selection */ "/TIM");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "create", function() { return d3_selection__WEBPACK_IMPORTED_MODULE_24__["create"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "creator", function() { return d3_selection__WEBPACK_IMPORTED_MODULE_24__["creator"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "local", function() { return d3_selection__WEBPACK_IMPORTED_MODULE_24__["local"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "matcher", function() { return d3_selection__WEBPACK_IMPORTED_MODULE_24__["matcher"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mouse", function() { return d3_selection__WEBPACK_IMPORTED_MODULE_24__["mouse"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "namespace", function() { return d3_selection__WEBPACK_IMPORTED_MODULE_24__["namespace"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "namespaces", function() { return d3_selection__WEBPACK_IMPORTED_MODULE_24__["namespaces"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "clientPoint", function() { return d3_selection__WEBPACK_IMPORTED_MODULE_24__["clientPoint"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "select", function() { return d3_selection__WEBPACK_IMPORTED_MODULE_24__["select"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "selectAll", function() { return d3_selection__WEBPACK_IMPORTED_MODULE_24__["selectAll"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "selection", function() { return d3_selection__WEBPACK_IMPORTED_MODULE_24__["selection"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "selector", function() { return d3_selection__WEBPACK_IMPORTED_MODULE_24__["selector"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "selectorAll", function() { return d3_selection__WEBPACK_IMPORTED_MODULE_24__["selectorAll"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "style", function() { return d3_selection__WEBPACK_IMPORTED_MODULE_24__["style"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "touch", function() { return d3_selection__WEBPACK_IMPORTED_MODULE_24__["touch"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "touches", function() { return d3_selection__WEBPACK_IMPORTED_MODULE_24__["touches"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "window", function() { return d3_selection__WEBPACK_IMPORTED_MODULE_24__["window"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "event", function() { return d3_selection__WEBPACK_IMPORTED_MODULE_24__["event"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "customEvent", function() { return d3_selection__WEBPACK_IMPORTED_MODULE_24__["customEvent"]; });

/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! d3-shape */ "8d86");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "arc", function() { return d3_shape__WEBPACK_IMPORTED_MODULE_25__["arc"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "area", function() { return d3_shape__WEBPACK_IMPORTED_MODULE_25__["area"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "line", function() { return d3_shape__WEBPACK_IMPORTED_MODULE_25__["line"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pie", function() { return d3_shape__WEBPACK_IMPORTED_MODULE_25__["pie"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "areaRadial", function() { return d3_shape__WEBPACK_IMPORTED_MODULE_25__["areaRadial"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "radialArea", function() { return d3_shape__WEBPACK_IMPORTED_MODULE_25__["radialArea"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lineRadial", function() { return d3_shape__WEBPACK_IMPORTED_MODULE_25__["lineRadial"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "radialLine", function() { return d3_shape__WEBPACK_IMPORTED_MODULE_25__["radialLine"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pointRadial", function() { return d3_shape__WEBPACK_IMPORTED_MODULE_25__["pointRadial"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "linkHorizontal", function() { return d3_shape__WEBPACK_IMPORTED_MODULE_25__["linkHorizontal"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "linkVertical", function() { return d3_shape__WEBPACK_IMPORTED_MODULE_25__["linkVertical"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "linkRadial", function() { return d3_shape__WEBPACK_IMPORTED_MODULE_25__["linkRadial"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "symbol", function() { return d3_shape__WEBPACK_IMPORTED_MODULE_25__["symbol"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "symbols", function() { return d3_shape__WEBPACK_IMPORTED_MODULE_25__["symbols"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "symbolCircle", function() { return d3_shape__WEBPACK_IMPORTED_MODULE_25__["symbolCircle"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "symbolCross", function() { return d3_shape__WEBPACK_IMPORTED_MODULE_25__["symbolCross"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "symbolDiamond", function() { return d3_shape__WEBPACK_IMPORTED_MODULE_25__["symbolDiamond"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "symbolSquare", function() { return d3_shape__WEBPACK_IMPORTED_MODULE_25__["symbolSquare"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "symbolStar", function() { return d3_shape__WEBPACK_IMPORTED_MODULE_25__["symbolStar"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "symbolTriangle", function() { return d3_shape__WEBPACK_IMPORTED_MODULE_25__["symbolTriangle"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "symbolWye", function() { return d3_shape__WEBPACK_IMPORTED_MODULE_25__["symbolWye"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveBasisClosed", function() { return d3_shape__WEBPACK_IMPORTED_MODULE_25__["curveBasisClosed"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveBasisOpen", function() { return d3_shape__WEBPACK_IMPORTED_MODULE_25__["curveBasisOpen"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveBasis", function() { return d3_shape__WEBPACK_IMPORTED_MODULE_25__["curveBasis"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveBundle", function() { return d3_shape__WEBPACK_IMPORTED_MODULE_25__["curveBundle"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveCardinalClosed", function() { return d3_shape__WEBPACK_IMPORTED_MODULE_25__["curveCardinalClosed"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveCardinalOpen", function() { return d3_shape__WEBPACK_IMPORTED_MODULE_25__["curveCardinalOpen"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveCardinal", function() { return d3_shape__WEBPACK_IMPORTED_MODULE_25__["curveCardinal"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveCatmullRomClosed", function() { return d3_shape__WEBPACK_IMPORTED_MODULE_25__["curveCatmullRomClosed"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveCatmullRomOpen", function() { return d3_shape__WEBPACK_IMPORTED_MODULE_25__["curveCatmullRomOpen"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveCatmullRom", function() { return d3_shape__WEBPACK_IMPORTED_MODULE_25__["curveCatmullRom"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveLinearClosed", function() { return d3_shape__WEBPACK_IMPORTED_MODULE_25__["curveLinearClosed"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveLinear", function() { return d3_shape__WEBPACK_IMPORTED_MODULE_25__["curveLinear"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveMonotoneX", function() { return d3_shape__WEBPACK_IMPORTED_MODULE_25__["curveMonotoneX"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveMonotoneY", function() { return d3_shape__WEBPACK_IMPORTED_MODULE_25__["curveMonotoneY"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveNatural", function() { return d3_shape__WEBPACK_IMPORTED_MODULE_25__["curveNatural"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveStep", function() { return d3_shape__WEBPACK_IMPORTED_MODULE_25__["curveStep"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveStepAfter", function() { return d3_shape__WEBPACK_IMPORTED_MODULE_25__["curveStepAfter"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveStepBefore", function() { return d3_shape__WEBPACK_IMPORTED_MODULE_25__["curveStepBefore"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stack", function() { return d3_shape__WEBPACK_IMPORTED_MODULE_25__["stack"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stackOffsetExpand", function() { return d3_shape__WEBPACK_IMPORTED_MODULE_25__["stackOffsetExpand"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stackOffsetDiverging", function() { return d3_shape__WEBPACK_IMPORTED_MODULE_25__["stackOffsetDiverging"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stackOffsetNone", function() { return d3_shape__WEBPACK_IMPORTED_MODULE_25__["stackOffsetNone"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stackOffsetSilhouette", function() { return d3_shape__WEBPACK_IMPORTED_MODULE_25__["stackOffsetSilhouette"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stackOffsetWiggle", function() { return d3_shape__WEBPACK_IMPORTED_MODULE_25__["stackOffsetWiggle"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stackOrderAppearance", function() { return d3_shape__WEBPACK_IMPORTED_MODULE_25__["stackOrderAppearance"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stackOrderAscending", function() { return d3_shape__WEBPACK_IMPORTED_MODULE_25__["stackOrderAscending"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stackOrderDescending", function() { return d3_shape__WEBPACK_IMPORTED_MODULE_25__["stackOrderDescending"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stackOrderInsideOut", function() { return d3_shape__WEBPACK_IMPORTED_MODULE_25__["stackOrderInsideOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stackOrderNone", function() { return d3_shape__WEBPACK_IMPORTED_MODULE_25__["stackOrderNone"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stackOrderReverse", function() { return d3_shape__WEBPACK_IMPORTED_MODULE_25__["stackOrderReverse"]; });

/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! d3-time */ "eIOW");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeInterval", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["timeInterval"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeMillisecond", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["timeMillisecond"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeMilliseconds", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["timeMilliseconds"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcMillisecond", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["utcMillisecond"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcMilliseconds", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["utcMilliseconds"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeSecond", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["timeSecond"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeSeconds", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["timeSeconds"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcSecond", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["utcSecond"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcSeconds", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["utcSeconds"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeMinute", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["timeMinute"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeMinutes", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["timeMinutes"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeHour", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["timeHour"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeHours", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["timeHours"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeDay", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["timeDay"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeDays", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["timeDays"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeWeek", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["timeWeek"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeWeeks", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["timeWeeks"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeSunday", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["timeSunday"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeSundays", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["timeSundays"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeMonday", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["timeMonday"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeMondays", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["timeMondays"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeTuesday", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["timeTuesday"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeTuesdays", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["timeTuesdays"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeWednesday", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["timeWednesday"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeWednesdays", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["timeWednesdays"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeThursday", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["timeThursday"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeThursdays", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["timeThursdays"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeFriday", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["timeFriday"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeFridays", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["timeFridays"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeSaturday", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["timeSaturday"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeSaturdays", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["timeSaturdays"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeMonth", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["timeMonth"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeMonths", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["timeMonths"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeYear", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["timeYear"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeYears", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["timeYears"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcMinute", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["utcMinute"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcMinutes", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["utcMinutes"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcHour", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["utcHour"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcHours", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["utcHours"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcDay", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["utcDay"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcDays", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["utcDays"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcWeek", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["utcWeek"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcWeeks", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["utcWeeks"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcSunday", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["utcSunday"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcSundays", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["utcSundays"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcMonday", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["utcMonday"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcMondays", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["utcMondays"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcTuesday", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["utcTuesday"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcTuesdays", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["utcTuesdays"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcWednesday", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["utcWednesday"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcWednesdays", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["utcWednesdays"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcThursday", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["utcThursday"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcThursdays", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["utcThursdays"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcFriday", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["utcFriday"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcFridays", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["utcFridays"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcSaturday", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["utcSaturday"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcSaturdays", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["utcSaturdays"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcMonth", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["utcMonth"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcMonths", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["utcMonths"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcYear", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["utcYear"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcYears", function() { return d3_time__WEBPACK_IMPORTED_MODULE_26__["utcYears"]; });

/* harmony import */ var d3_time_format__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! d3-time-format */ "cOGN");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeFormatDefaultLocale", function() { return d3_time_format__WEBPACK_IMPORTED_MODULE_27__["timeFormatDefaultLocale"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeFormat", function() { return d3_time_format__WEBPACK_IMPORTED_MODULE_27__["timeFormat"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeParse", function() { return d3_time_format__WEBPACK_IMPORTED_MODULE_27__["timeParse"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcFormat", function() { return d3_time_format__WEBPACK_IMPORTED_MODULE_27__["utcFormat"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utcParse", function() { return d3_time_format__WEBPACK_IMPORTED_MODULE_27__["utcParse"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeFormatLocale", function() { return d3_time_format__WEBPACK_IMPORTED_MODULE_27__["timeFormatLocale"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isoFormat", function() { return d3_time_format__WEBPACK_IMPORTED_MODULE_27__["isoFormat"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isoParse", function() { return d3_time_format__WEBPACK_IMPORTED_MODULE_27__["isoParse"]; });

/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! d3-timer */ "QSoV");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "now", function() { return d3_timer__WEBPACK_IMPORTED_MODULE_28__["now"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timer", function() { return d3_timer__WEBPACK_IMPORTED_MODULE_28__["timer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timerFlush", function() { return d3_timer__WEBPACK_IMPORTED_MODULE_28__["timerFlush"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeout", function() { return d3_timer__WEBPACK_IMPORTED_MODULE_28__["timeout"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interval", function() { return d3_timer__WEBPACK_IMPORTED_MODULE_28__["interval"]; });

/* harmony import */ var d3_transition__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! d3-transition */ "sQjb");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "transition", function() { return d3_transition__WEBPACK_IMPORTED_MODULE_29__["transition"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "active", function() { return d3_transition__WEBPACK_IMPORTED_MODULE_29__["active"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interrupt", function() { return d3_transition__WEBPACK_IMPORTED_MODULE_29__["interrupt"]; });

/* harmony import */ var d3_voronoi__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! d3-voronoi */ "bKjm");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "voronoi", function() { return d3_voronoi__WEBPACK_IMPORTED_MODULE_30__["voronoi"]; });

/* harmony import */ var d3_zoom__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! d3-zoom */ "2TRZ");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zoom", function() { return d3_zoom__WEBPACK_IMPORTED_MODULE_31__["zoom"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zoomTransform", function() { return d3_zoom__WEBPACK_IMPORTED_MODULE_31__["zoomTransform"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zoomIdentity", function() { return d3_zoom__WEBPACK_IMPORTED_MODULE_31__["zoomIdentity"]; });



































/***/ }),

/***/ "UnGF":
/*!*************************************************!*\
  !*** ./node_modules/d3-contour/src/contains.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(ring, hole) {
  var i = -1, n = hole.length, c;
  while (++i < n) if (c = ringContains(ring, hole[i])) return c;
  return 0;
});

function ringContains(ring, point) {
  var x = point[0], y = point[1], contains = -1;
  for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {
    var pi = ring[i], xi = pi[0], yi = pi[1], pj = ring[j], xj = pj[0], yj = pj[1];
    if (segmentContains(pi, pj, point)) return 0;
    if (((yi > y) !== (yj > y)) && ((x < (xj - xi) * (y - yi) / (yj - yi) + xi))) contains = -contains;
  }
  return contains;
}

function segmentContains(a, b, c) {
  var i; return collinear(a, b, c) && within(a[i = +(a[0] === b[0])], c[i], b[i]);
}

function collinear(a, b, c) {
  return (b[0] - a[0]) * (c[1] - a[1]) === (c[0] - a[0]) * (b[1] - a[1]);
}

function within(p, q, r) {
  return p <= q && q <= r || r <= q && q <= p;
}


/***/ }),

/***/ "VIHS":
/*!*************************************************!*\
  !*** ./node_modules/d3-force/src/simulation.js ***!
  \*************************************************/
/*! exports provided: x, y, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "x", function() { return x; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "y", function() { return y; });
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-dispatch */ "30U6");
/* harmony import */ var d3_collection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-collection */ "bwSX");
/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-timer */ "QSoV");




function x(d) {
  return d.x;
}

function y(d) {
  return d.y;
}

var initialRadius = 10,
    initialAngle = Math.PI * (3 - Math.sqrt(5));

/* harmony default export */ __webpack_exports__["default"] = (function(nodes) {
  var simulation,
      alpha = 1,
      alphaMin = 0.001,
      alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),
      alphaTarget = 0,
      velocityDecay = 0.6,
      forces = Object(d3_collection__WEBPACK_IMPORTED_MODULE_1__["map"])(),
      stepper = Object(d3_timer__WEBPACK_IMPORTED_MODULE_2__["timer"])(step),
      event = Object(d3_dispatch__WEBPACK_IMPORTED_MODULE_0__["dispatch"])("tick", "end");

  if (nodes == null) nodes = [];

  function step() {
    tick();
    event.call("tick", simulation);
    if (alpha < alphaMin) {
      stepper.stop();
      event.call("end", simulation);
    }
  }

  function tick(iterations) {
    var i, n = nodes.length, node;

    if (iterations === undefined) iterations = 1;

    for (var k = 0; k < iterations; ++k) {
      alpha += (alphaTarget - alpha) * alphaDecay;

      forces.each(function (force) {
        force(alpha);
      });

      for (i = 0; i < n; ++i) {
        node = nodes[i];
        if (node.fx == null) node.x += node.vx *= velocityDecay;
        else node.x = node.fx, node.vx = 0;
        if (node.fy == null) node.y += node.vy *= velocityDecay;
        else node.y = node.fy, node.vy = 0;
      }
    }

    return simulation;
  }

  function initializeNodes() {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.index = i;
      if (node.fx != null) node.x = node.fx;
      if (node.fy != null) node.y = node.fy;
      if (isNaN(node.x) || isNaN(node.y)) {
        var radius = initialRadius * Math.sqrt(i), angle = i * initialAngle;
        node.x = radius * Math.cos(angle);
        node.y = radius * Math.sin(angle);
      }
      if (isNaN(node.vx) || isNaN(node.vy)) {
        node.vx = node.vy = 0;
      }
    }
  }

  function initializeForce(force) {
    if (force.initialize) force.initialize(nodes);
    return force;
  }

  initializeNodes();

  return simulation = {
    tick: tick,

    restart: function() {
      return stepper.restart(step), simulation;
    },

    stop: function() {
      return stepper.stop(), simulation;
    },

    nodes: function(_) {
      return arguments.length ? (nodes = _, initializeNodes(), forces.each(initializeForce), simulation) : nodes;
    },

    alpha: function(_) {
      return arguments.length ? (alpha = +_, simulation) : alpha;
    },

    alphaMin: function(_) {
      return arguments.length ? (alphaMin = +_, simulation) : alphaMin;
    },

    alphaDecay: function(_) {
      return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;
    },

    alphaTarget: function(_) {
      return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;
    },

    velocityDecay: function(_) {
      return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;
    },

    force: function(name, _) {
      return arguments.length > 1 ? ((_ == null ? forces.remove(name) : forces.set(name, initializeForce(_))), simulation) : forces.get(name);
    },

    find: function(x, y, radius) {
      var i = 0,
          n = nodes.length,
          dx,
          dy,
          d2,
          node,
          closest;

      if (radius == null) radius = Infinity;
      else radius *= radius;

      for (i = 0; i < n; ++i) {
        node = nodes[i];
        dx = x - node.x;
        dy = y - node.y;
        d2 = dx * dx + dy * dy;
        if (d2 < radius) closest = node, radius = d2;
      }

      return closest;
    },

    on: function(name, _) {
      return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);
    }
  };
});


/***/ }),

/***/ "VMG8":
/*!***************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/diverging/PiYG.js ***!
  \***************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors.js */ "ZtE7");
/* harmony import */ var _ramp_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp.js */ "jQWc");



var scheme = new Array(3).concat(
  "e9a3c9f7f7f7a1d76a",
  "d01c8bf1b6dab8e1864dac26",
  "d01c8bf1b6daf7f7f7b8e1864dac26",
  "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221",
  "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221",
  "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221",
  "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221",
  "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419",
  "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419"
).map(_colors_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp_js__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "VQEX":
/*!*********************************************!*\
  !*** ./node_modules/d3-contour/src/blur.js ***!
  \*********************************************/
/*! exports provided: blurX, blurY */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "blurX", function() { return blurX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "blurY", function() { return blurY; });
// TODO Optimize edge cases.
// TODO Optimize index calculation.
// TODO Optimize arguments.
function blurX(source, target, r) {
  var n = source.width,
      m = source.height,
      w = (r << 1) + 1;
  for (var j = 0; j < m; ++j) {
    for (var i = 0, sr = 0; i < n + r; ++i) {
      if (i < n) {
        sr += source.data[i + j * n];
      }
      if (i >= r) {
        if (i >= w) {
          sr -= source.data[i - w + j * n];
        }
        target.data[i - r + j * n] = sr / Math.min(i + 1, n - 1 + w - i, w);
      }
    }
  }
}

// TODO Optimize edge cases.
// TODO Optimize index calculation.
// TODO Optimize arguments.
function blurY(source, target, r) {
  var n = source.width,
      m = source.height,
      w = (r << 1) + 1;
  for (var i = 0; i < n; ++i) {
    for (var j = 0, sr = 0; j < m + r; ++j) {
      if (j < m) {
        sr += source.data[i + j * n];
      }
      if (j >= r) {
        if (j >= w) {
          sr -= source.data[i + (j - w) * n];
        }
        target.data[i + (j - r) * n] = sr / Math.min(j + 1, m - 1 + w - j, w);
      }
    }
  }
}


/***/ }),

/***/ "VXJj":
/*!***************************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/equirectangular.js ***!
  \***************************************************************/
/*! exports provided: equirectangularRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equirectangularRaw", function() { return equirectangularRaw; });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "1ibS");


function equirectangularRaw(lambda, phi) {
  return [lambda, phi];
}

equirectangularRaw.invert = equirectangularRaw;

/* harmony default export */ __webpack_exports__["default"] = (function() {
  return Object(_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(equirectangularRaw)
      .scale(152.63);
});


/***/ }),

/***/ "VsNs":
/*!**************************************************************!*\
  !*** ./node_modules/c3/node_modules/d3-scale/src/utcTime.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _time__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./time */ "DS9Q");
/* harmony import */ var d3_time_format__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-time-format */ "cOGN");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-time */ "eIOW");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./init */ "//NX");





/* harmony default export */ __webpack_exports__["default"] = (function() {
  return _init__WEBPACK_IMPORTED_MODULE_3__["initRange"].apply(Object(_time__WEBPACK_IMPORTED_MODULE_0__["calendar"])(d3_time__WEBPACK_IMPORTED_MODULE_2__["utcYear"], d3_time__WEBPACK_IMPORTED_MODULE_2__["utcMonth"], d3_time__WEBPACK_IMPORTED_MODULE_2__["utcWeek"], d3_time__WEBPACK_IMPORTED_MODULE_2__["utcDay"], d3_time__WEBPACK_IMPORTED_MODULE_2__["utcHour"], d3_time__WEBPACK_IMPORTED_MODULE_2__["utcMinute"], d3_time__WEBPACK_IMPORTED_MODULE_2__["utcSecond"], d3_time__WEBPACK_IMPORTED_MODULE_2__["utcMillisecond"], d3_time_format__WEBPACK_IMPORTED_MODULE_1__["utcFormat"]).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]), arguments);
});


/***/ }),

/***/ "Wcxc":
/*!***********************************************************!*\
  !*** ./node_modules/c3/node_modules/d3-array/src/mean.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./number */ "1Fr+");


/* harmony default export */ __webpack_exports__["default"] = (function(values, valueof) {
  var n = values.length,
      m = n,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = Object(_number__WEBPACK_IMPORTED_MODULE_0__["default"])(values[i]))) sum += value;
      else --m;
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = Object(_number__WEBPACK_IMPORTED_MODULE_0__["default"])(valueof(values[i], i, values)))) sum += value;
      else --m;
    }
  }

  if (m) return sum / m;
});


/***/ }),

/***/ "WmoW":
/*!***************************************************************!*\
  !*** ./node_modules/c3/node_modules/d3-array/src/identity.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return x;
});


/***/ }),

/***/ "Wtxg":
/*!*********************************************!*\
  !*** ./node_modules/d3-force/src/radial.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant */ "nXVj");


/* harmony default export */ __webpack_exports__["default"] = (function(radius, x, y) {
  var nodes,
      strength = Object(_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(0.1),
      strengths,
      radiuses;

  if (typeof radius !== "function") radius = Object(_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+radius);
  if (x == null) x = 0;
  if (y == null) y = 0;

  function force(alpha) {
    for (var i = 0, n = nodes.length; i < n; ++i) {
      var node = nodes[i],
          dx = node.x - x || 1e-6,
          dy = node.y - y || 1e-6,
          r = Math.sqrt(dx * dx + dy * dy),
          k = (radiuses[i] - r) * strengths[i] * alpha / r;
      node.vx += dx * k;
      node.vy += dy * k;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    radiuses = new Array(n);
    for (i = 0; i < n; ++i) {
      radiuses[i] = +radius(nodes[i], i, nodes);
      strengths[i] = isNaN(radiuses[i]) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function(_) {
    nodes = _, initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), initialize(), force) : strength;
  };

  force.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), initialize(), force) : radius;
  };

  force.x = function(_) {
    return arguments.length ? (x = +_, force) : x;
  };

  force.y = function(_) {
    return arguments.length ? (y = +_, force) : y;
  };

  return force;
});


/***/ }),

/***/ "X181":
/*!***********************************************!*\
  !*** ./node_modules/d3-collection/src/set.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./map */ "+RkR");


function Set() {}

var proto = _map__WEBPACK_IMPORTED_MODULE_0__["default"].prototype;

Set.prototype = set.prototype = {
  constructor: Set,
  has: proto.has,
  add: function(value) {
    value += "";
    this[_map__WEBPACK_IMPORTED_MODULE_0__["prefix"] + value] = value;
    return this;
  },
  remove: proto.remove,
  clear: proto.clear,
  values: proto.keys,
  size: proto.size,
  empty: proto.empty,
  each: proto.each
};

function set(object, f) {
  var set = new Set;

  // Copy constructor.
  if (object instanceof Set) object.each(function(value) { set.add(value); });

  // Otherwise, assume it’s an array.
  else if (object) {
    var i = -1, n = object.length;
    if (f == null) while (++i < n) set.add(object[i]);
    else while (++i < n) set.add(f(object[i], i, object));
  }

  return set;
}

/* harmony default export */ __webpack_exports__["default"] = (set);


/***/ }),

/***/ "X4w7":
/*!***************************************************************!*\
  !*** ./node_modules/c3/node_modules/d3-scale/src/identity.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return identity; });
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array */ "d/QP");
/* harmony import */ var _linear__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./linear */ "hdEp");
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./number */ "SMHy");




function identity(domain) {
  var unknown;

  function scale(x) {
    return isNaN(x = +x) ? unknown : x;
  }

  scale.invert = scale;

  scale.domain = scale.range = function(_) {
    return arguments.length ? (domain = _array__WEBPACK_IMPORTED_MODULE_0__["map"].call(_, _number__WEBPACK_IMPORTED_MODULE_2__["default"]), scale) : domain.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return identity(domain).unknown(unknown);
  };

  domain = arguments.length ? _array__WEBPACK_IMPORTED_MODULE_0__["map"].call(domain, _number__WEBPACK_IMPORTED_MODULE_2__["default"]) : [0, 1];

  return Object(_linear__WEBPACK_IMPORTED_MODULE_1__["linearish"])(scale);
}


/***/ }),

/***/ "X7xT":
/*!*************************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/sequential-multi/rainbow.js ***!
  \*************************************************************************/
/*! exports provided: warm, cool, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "warm", function() { return warm; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cool", function() { return cool; });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "SC+/");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-interpolate */ "pD2Y");



var warm = Object(d3_interpolate__WEBPACK_IMPORTED_MODULE_1__["interpolateCubehelixLong"])(Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["cubehelix"])(-100, 0.75, 0.35), Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["cubehelix"])(80, 1.50, 0.8));

var cool = Object(d3_interpolate__WEBPACK_IMPORTED_MODULE_1__["interpolateCubehelixLong"])(Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["cubehelix"])(260, 0.75, 0.35), Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["cubehelix"])(80, 1.50, 0.8));

var c = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["cubehelix"])();

/* harmony default export */ __webpack_exports__["default"] = (function(t) {
  if (t < 0 || t > 1) t -= Math.floor(t);
  var ts = Math.abs(t - 0.5);
  c.h = 360 * t - 100;
  c.s = 1.5 - 1.5 * ts;
  c.l = 0.8 - 0.9 * ts;
  return c + "";
});


/***/ }),

/***/ "XAaG":
/*!***************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/fit.js ***!
  \***************************************************/
/*! exports provided: fitExtent, fitSize, fitWidth, fitHeight */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fitExtent", function() { return fitExtent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fitSize", function() { return fitSize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fitWidth", function() { return fitWidth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fitHeight", function() { return fitHeight; });
/* harmony import */ var _stream_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../stream.js */ "tepu");
/* harmony import */ var _path_bounds_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../path/bounds.js */ "SMTj");



function fit(projection, fitBounds, object) {
  var clip = projection.clipExtent && projection.clipExtent();
  projection.scale(150).translate([0, 0]);
  if (clip != null) projection.clipExtent(null);
  Object(_stream_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, projection.stream(_path_bounds_js__WEBPACK_IMPORTED_MODULE_1__["default"]));
  fitBounds(_path_bounds_js__WEBPACK_IMPORTED_MODULE_1__["default"].result());
  if (clip != null) projection.clipExtent(clip);
  return projection;
}

function fitExtent(projection, extent, object) {
  return fit(projection, function(b) {
    var w = extent[1][0] - extent[0][0],
        h = extent[1][1] - extent[0][1],
        k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),
        x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,
        y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
    projection.scale(150 * k).translate([x, y]);
  }, object);
}

function fitSize(projection, size, object) {
  return fitExtent(projection, [[0, 0], size], object);
}

function fitWidth(projection, width, object) {
  return fit(projection, function(b) {
    var w = +width,
        k = w / (b[1][0] - b[0][0]),
        x = (w - k * (b[1][0] + b[0][0])) / 2,
        y = -k * b[0][1];
    projection.scale(150 * k).translate([x, y]);
  }, object);
}

function fitHeight(projection, height, object) {
  return fit(projection, function(b) {
    var h = +height,
        k = h / (b[1][1] - b[0][1]),
        x = -k * b[0][0],
        y = (h - k * (b[1][1] + b[0][1])) / 2;
    projection.scale(150 * k).translate([x, y]);
  }, object);
}


/***/ }),

/***/ "XElW":
/*!******************************************************************!*\
  !*** ./src/app/pages/dashboard/dashboard/dashboard.component.ts ***!
  \******************************************************************/
/*! exports provided: DashboardComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DashboardComponent", function() { return DashboardComponent; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "8Y7J");
/* harmony import */ var src_app_services_dashboard_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! src/app/services/dashboard.service */ "0AbP");
/* harmony import */ var c3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! c3 */ "LV99");
/* harmony import */ var c3__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(c3__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var ng_zorro_antd_date_picker__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ng-zorro-antd/date-picker */ "lAiz");
/* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/forms */ "s7LF");
/* harmony import */ var ng_zorro_antd_list__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ng-zorro-antd/list */ "zTFG");
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/common */ "SVse");









function DashboardComponent_nz_list_item_135_Template(rf, ctx) { if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "nz-list-item", 28);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](1, "span", 29);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](2);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](3, "span", 30);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](4, " Payable To ");
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](5, "a", 31);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](6);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
} if (rf & 2) {
    const item_r3 = ctx.$implicit;
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](2);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate1"](" ", item_r3 == null ? null : item_r3.payable, " AED");
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](4);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate1"](" ", item_r3 == null ? null : item_r3.company, " ");
} }
function DashboardComponent_nz_list_item_147_Template(rf, ctx) { if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "nz-list-item", 28);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](1, "span", 29);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](2);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](3, "span", 30);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](4, " Receivable from ");
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](5, "a", 31);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](6);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
} if (rf & 2) {
    const item_r4 = ctx.$implicit;
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](2);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate1"]("", item_r4.receving, " AED ");
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](4);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate1"](" ", item_r4.agent, " ");
} }
function DashboardComponent_nz_list_item_159_Template(rf, ctx) { if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "nz-list-item", 28);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](1, "span", 29);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](2);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](3, "span", 30);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](4, " Balance from ");
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](5, "a", 31);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](6);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
} if (rf & 2) {
    const item_r5 = ctx.$implicit;
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](2);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate1"]("", item_r5 == null ? null : item_r5.amount, " AED ");
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](4);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate1"](" ", item_r5 == null ? null : item_r5.bankName, " ");
} }
class DashboardComponent {
    constructor(_dashboardService) {
        this._dashboardService = _dashboardService;
        this.caseRevenuePerMonthDate = new Date();
    }
    ngOnInit() {
        this._dashboardService.dashboardObserver$.subscribe(res => {
            this.Dashboard = res;
        });
        this._dashboardService.GetAnalytics();
        this._dashboardService.overallInfoObserver$.subscribe(res => {
            this.overallInfo = res;
        });
        this._dashboardService.GetOverAllInfo();
    }
    getRevenuePerMonthData() {
        this._dashboardService.getRevenuePerMonthData(this.caseRevenuePerMonthDate.toISOString()).subscribe(res => {
            this.generateRevenueBarChart(res.dynamicResult);
        });
    }
    generateRevenueBarChart(columns) {
        let columnList = ['Revenue'];
        columnList = columnList.concat(columns);
        const revenue = c3__WEBPACK_IMPORTED_MODULE_2___default.a.generate({
            bindto: '#revenue',
            size: {
            // width: 460,
            // height: 260
            },
            data: {
                columns: [
                    columnList
                ],
                type: 'bar',
            },
            axis: {
                x: {
                    type: 'category',
                    categories: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
                },
            },
            color: {
                pattern: ['#007aff'],
            },
        });
    }
}
DashboardComponent.ɵfac = function DashboardComponent_Factory(t) { return new (t || DashboardComponent)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](src_app_services_dashboard_service__WEBPACK_IMPORTED_MODULE_1__["DashboardService"])); };
DashboardComponent.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({ type: DashboardComponent, selectors: [["app-dashboard"]], decls: 167, vars: 15, consts: [[1, "breadcrumbs", "mb-3"], [1, "row", "home-top-cards"], [1, "col-xl-3"], [1, "card"], [1, "card-body", "d-flex", "flex-wrap", "justify-content-between", "align-items-start", "bg-alice-blue"], [1, ""], [1, "text-dark", "f-13", "font-weight-bold"], [1, "text-dark", "font-weight-bold", "font-size-24"], [1, "font-size-12", "text-default"], ["src", "assets/home/event-icon.svg", "width", "50px", "alt", "Icon"], ["src", "assets/home/case-icon.svg", "width", "50px", "alt", "Icon"], ["src", "assets/home/deadline-icon.svg", "width", "50px", "alt", "Icon"], ["src", "assets/home/invoice-icon.svg", "width", "50px", "alt", "Icon"], [1, "row"], [1, "col-xl-4", "col-lg-6", "pt-4"], [1, "bg-white", "card-body"], [1, "topRow", "d-flex", "align-items-center", "justify-content-between"], ["nzMode", "year", "nzAllowClear", "false", 3, "ngModel", "ngModelChange"], ["id", "revenue"], [1, "row", "home-page-cards"], [1, "col-xl-4"], [1, "card", "bg-white", "rounded-0", "max-h-310", "min-h-250", "mb-3"], [1, "card-header", "p-3", "mb-3"], [1, "mb-0", "d-flex", "align-items-center", "justify-content-between"], [1, "fw-500", "f-14"], ["href", "#/cases", 1, "f-12", "float-right", "kit__utils__link"], [1, "card-body", "py-0", "px-3", "overflow-auto"], ["class", "fw-500 f-13", 4, "ngFor", "ngForOf"], [1, "fw-500", "f-13"], [1, "firstLastName"], [1, "f-12", "added-by"], ["href", "javascript:void(0)", 1, "kit__utils__link"]], template: function DashboardComponent_Template(rf, ctx) { if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "div", 0);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](1, "strong");
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](2, "Dashboard");
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](3, "div", 1);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](4, "div", 2);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](5, "div", 3);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](6, "div", 4);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](7, "div", 5);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](8, "div", 6);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](9, "Today Profit");
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](10, "div", 7);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](11);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](12, "div", 8);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](13, " today");
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](14, "div", 5);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](15, "img", 9);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](16, "div", 2);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](17, "div", 3);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](18, "div", 4);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](19, "div", 5);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](20, "div", 6);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](21, "Today Added Sales");
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](22, "div", 7);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](23);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](24, "div", 8);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](25, "Sales for today");
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](26, "div", 5);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](27, "img", 10);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](28, "div", 2);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](29, "div", 3);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](30, "div", 4);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](31, "div", 5);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](32, "div", 6);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](33, "Today Payable ");
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](34, "div", 7);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](35);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](36, "div", 8);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](37, "today");
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](38, "div", 5);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](39, "img", 11);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](40, "div", 2);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](41, "div", 3);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](42, "div", 4);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](43, "div", 5);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](44, "div", 6);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](45, "Today Receviable");
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](46, "div", 7);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](47);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](48, "div", 8);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](49, "Receviable for today");
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](50, "div", 5);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](51, "img", 12);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](52, "div", 13);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](53, "div", 14);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](54, "div", 15);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](55, "div", 16);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](56, "strong");
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](57, "Profit Per Month");
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](58, "nz-date-picker", 17);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("ngModelChange", function DashboardComponent_Template_nz_date_picker_ngModelChange_58_listener($event) { return ctx.caseRevenuePerMonthDate = $event; })("ngModelChange", function DashboardComponent_Template_nz_date_picker_ngModelChange_58_listener() { return ctx.getRevenuePerMonthData(); });
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](59, "div", 18);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](60, "div", 14);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](61, "div", 15);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](62, "div", 16);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](63, "strong");
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](64, "Sales Per Month");
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](65, "nz-date-picker", 17);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("ngModelChange", function DashboardComponent_Template_nz_date_picker_ngModelChange_65_listener($event) { return ctx.caseRevenuePerMonthDate = $event; })("ngModelChange", function DashboardComponent_Template_nz_date_picker_ngModelChange_65_listener() { return ctx.getRevenuePerMonthData(); });
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](66, "div", 18);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](67, "div", 14);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](68, "div", 15);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](69, "div", 16);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](70, "strong");
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](71, "Expense Per Month");
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](72, "nz-date-picker", 17);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("ngModelChange", function DashboardComponent_Template_nz_date_picker_ngModelChange_72_listener($event) { return ctx.caseRevenuePerMonthDate = $event; })("ngModelChange", function DashboardComponent_Template_nz_date_picker_ngModelChange_72_listener() { return ctx.getRevenuePerMonthData(); });
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](73, "div", 18);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](74, "div", 1);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](75, "div", 2);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](76, "div", 3);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](77, "div", 4);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](78, "div", 5);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](79, "div", 6);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](80, "Yesterday's Profit");
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](81, "div", 7);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](82);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](83, "div", 8);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](84, " yesterday");
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](85, "div", 5);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](86, "img", 9);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](87, "div", 2);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](88, "div", 3);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](89, "div", 4);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](90, "div", 5);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](91, "div", 6);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](92, "Yesterday's Added Sales");
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](93, "div", 7);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](94);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](95, "div", 8);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](96, "Sales for yesterday");
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](97, "div", 5);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](98, "img", 10);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](99, "div", 2);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](100, "div", 3);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](101, "div", 4);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](102, "div", 5);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](103, "div", 6);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](104, " Yesterday's Payable ");
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](105, "div", 7);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](106);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](107, "div", 8);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](108, "today");
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](109, "div", 5);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](110, "img", 11);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](111, "div", 2);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](112, "div", 3);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](113, "div", 4);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](114, "div", 5);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](115, "div", 6);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](116, "Yesterday's Receviable");
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](117, "div", 7);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](118);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](119, "div", 8);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](120, "Receviable for today");
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](121, "div", 5);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](122, "img", 12);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](123, "div", 19);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](124, "div", 20);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](125, "div", 21);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](126, "div", 22);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](127, "h6", 23);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](128, "span", 24);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](129, "Brokers Payable");
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](130, "span");
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](131, "a", 25);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](132, "View All");
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](133, "div", 26);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](134, "nz-list");
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](135, DashboardComponent_nz_list_item_135_Template, 7, 2, "nz-list-item", 27);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](136, "div", 20);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](137, "div", 21);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](138, "div", 22);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](139, "h6", 23);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](140, "span", 24);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](141, " Agent Receviable ");
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](142, "span");
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](143, "a", 25);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](144, "View All");
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](145, "div", 26);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](146, "nz-list");
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](147, DashboardComponent_nz_list_item_147_Template, 7, 2, "nz-list-item", 27);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](148, "div", 20);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](149, "div", 21);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](150, "div", 22);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](151, "h6", 23);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](152, "span", 24);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](153, "Banks");
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](154, "span");
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](155, "a", 25);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](156, "View All");
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](157, "div", 26);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](158, "nz-list");
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](159, DashboardComponent_nz_list_item_159_Template, 7, 2, "nz-list-item", 27);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](160, "div", 14);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](161, "div", 15);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](162, "div", 16);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](163, "strong");
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](164, "Profit Per Month");
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](165, "nz-date-picker", 17);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("ngModelChange", function DashboardComponent_Template_nz_date_picker_ngModelChange_165_listener($event) { return ctx.caseRevenuePerMonthDate = $event; })("ngModelChange", function DashboardComponent_Template_nz_date_picker_ngModelChange_165_listener() { return ctx.getRevenuePerMonthData(); });
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](166, "div", 18);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
    } if (rf & 2) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](11);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate1"]("", ctx.Dashboard == null ? null : ctx.Dashboard.totalProfit, " AED");
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](12);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate"](ctx.Dashboard == null ? null : ctx.Dashboard.totalSales);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](12);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate1"]("", ctx.Dashboard == null ? null : ctx.Dashboard.totalPayable, " AED");
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](12);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate1"]("", ctx.Dashboard == null ? null : ctx.Dashboard.totalReceviable, " AED");
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](11);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngModel", ctx.caseRevenuePerMonthDate);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](7);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngModel", ctx.caseRevenuePerMonthDate);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](7);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngModel", ctx.caseRevenuePerMonthDate);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](10);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate1"]("", ctx.Dashboard == null ? null : ctx.Dashboard.yesterdaysProfit, " AED");
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](12);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate"](ctx.Dashboard == null ? null : ctx.Dashboard.yesterdaysSales);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](12);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate1"]("", ctx.Dashboard == null ? null : ctx.Dashboard.yesterdaysPayable, " AED");
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](12);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate1"]("", ctx.Dashboard == null ? null : ctx.Dashboard.yesterdaysReceviable, " AED");
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](17);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngForOf", ctx.overallInfo == null ? null : ctx.overallInfo.brokers);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](12);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngForOf", ctx.overallInfo == null ? null : ctx.overallInfo.agents);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](12);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngForOf", ctx.overallInfo == null ? null : ctx.overallInfo.banks);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](6);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngModel", ctx.caseRevenuePerMonthDate);
    } }, directives: [ng_zorro_antd_date_picker__WEBPACK_IMPORTED_MODULE_3__["NzDatePickerComponent"], _angular_forms__WEBPACK_IMPORTED_MODULE_4__["NgControlStatus"], _angular_forms__WEBPACK_IMPORTED_MODULE_4__["NgModel"], ng_zorro_antd_list__WEBPACK_IMPORTED_MODULE_5__["NzListComponent"], _angular_common__WEBPACK_IMPORTED_MODULE_6__["NgForOf"], ng_zorro_antd_list__WEBPACK_IMPORTED_MODULE_5__["NzListItemComponent"]], styles: ["nz-date-picker[_ngcontent-%COMP%] {\n  margin: 0 8px 12px 0;\n}\n\n.c3[_ngcontent-%COMP%] {\n  margin-left: -15px;\n}\n\n@media (max-width: 1599px) {\n  .analyticsPage[_ngcontent-%COMP%]   .topRow[_ngcontent-%COMP%]   strong[_ngcontent-%COMP%] {\n    font-size: 0.9rem;\n  }\n  .analyticsPage[_ngcontent-%COMP%]   .casePerDayMsg[_ngcontent-%COMP%] {\n    font-size: 0.8rem;\n    margin-bottom: 0;\n  }\n  .analyticsPage[_ngcontent-%COMP%]   .accountsReceivables[_ngcontent-%COMP%] {\n    padding-top: 10px;\n  }\n}\n\n@media (max-width: 1199px) {\n  .analyticsPage[_ngcontent-%COMP%]   .card-header[_ngcontent-%COMP%], .analyticsPage[_ngcontent-%COMP%]   .card-footer[_ngcontent-%COMP%], .analyticsPage[_ngcontent-%COMP%]   .card-body[_ngcontent-%COMP%] {\n    padding: 0.6rem 1rem;\n  }\n  .analyticsPage[_ngcontent-%COMP%]   .casePerDayMsg[_ngcontent-%COMP%] {\n    font-size: 0.7rem;\n    margin: 0 !important;\n  }\n  .analyticsPage[_ngcontent-%COMP%]   .caseStatusDiv[_ngcontent-%COMP%] {\n    padding-top: 1.5rem;\n  }\n  .analyticsPage[_ngcontent-%COMP%]   .caseStatusDiv[_ngcontent-%COMP%]   .my-3[_ngcontent-%COMP%] {\n    margin: 0 !important;\n  }\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uXFwuLlxcLi5cXC4uXFwuLlxcZGFzaGJvYXJkLmNvbXBvbmVudC5zY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWNBO0VBQ0Usb0JBQUE7QUFiRjs7QUFnQkE7RUFDRSxrQkFBQTtBQWJGOztBQWtCQTtFQUdJO0lBQ0UsaUJBQUE7RUFqQko7RUFvQkU7SUFDRSxpQkFBQTtJQUNBLGdCQUFBO0VBbEJKO0VBcUJFO0lBQ0UsaUJBQUE7RUFuQko7QUFDRjs7QUE0QkE7RUFHSTs7O0lBR0Usb0JBQUE7RUE1Qko7RUErQkU7SUFDRSxpQkFBQTtJQUNBLG9CQUFBO0VBN0JKO0VBK0JFO0lBQ0UsbUJBQUE7RUE3Qko7RUFnQ0U7SUFDRSxvQkFBQTtFQTlCSjtBQUNGIiwiZmlsZSI6ImRhc2hib2FyZC5jb21wb25lbnQuc2NzcyIsInNvdXJjZXNDb250ZW50IjpbIkBpbXBvcnQgJ3NyYy9hcHAvY29tcG9uZW50cy9taXhpbnMuc2Nzcyc7XHJcblxyXG4vLyBSZXNwb25zaXZlIHV0aWxzXHJcbi8vICR4eGwtbWluLXdpZHRoOiAxNjAwcHg7XHJcbi8vICR4eGwtbWF4LXdpZHRoOiAxNTk5cHg7XHJcbi8vICR4bC1taW4td2lkdGg6IDEyMDBweDtcclxuLy8gJHhsLW1heC13aWR0aDogMTE5OXB4O1xyXG4vLyAkbGctbWluLXdpZHRoOiA5OTJweDtcclxuLy8gJGxnLW1heC13aWR0aDogOTkxcHg7XHJcbi8vICRtZC1taW4td2lkdGg6IDc2OHB4O1xyXG4vLyAkbWQtbWF4LXdpZHRoOiA3NjdweDtcclxuLy8gJHNtLW1pbi13aWR0aDogNTc2cHg7XHJcbi8vICRzbS1tYXgtd2lkdGg6IDU3NXB4O1xyXG5cclxubnotZGF0ZS1waWNrZXIge1xyXG4gIG1hcmdpbjogMCA4cHggMTJweCAwO1xyXG59XHJcblxyXG4uYzMge1xyXG4gIG1hcmdpbi1sZWZ0OiAtMTVweDtcclxufVxyXG5cclxuICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIFJlc3BvbnNpdmVuZXNzIFN0YXJ0cyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBcclxuXHJcbkBtZWRpYSAobWF4LXdpZHRoOiAkeHhsLW1heC13aWR0aCkge1xyXG5cclxuICAuYW5hbHl0aWNzUGFnZSB7XHJcbiAgICAudG9wUm93IHN0cm9uZyB7XHJcbiAgICAgIGZvbnQtc2l6ZTogLjlyZW07XHJcbiAgICB9XHJcblxyXG4gICAgLmNhc2VQZXJEYXlNc2cge1xyXG4gICAgICBmb250LXNpemU6IDAuOHJlbTtcclxuICAgICAgbWFyZ2luLWJvdHRvbTogMDtcclxuICAgIH1cclxuXHJcbiAgICAuYWNjb3VudHNSZWNlaXZhYmxlcyB7XHJcbiAgICAgIHBhZGRpbmctdG9wOiAxMHB4O1xyXG4gICAgfVxyXG5cclxuICB9XHJcblxyXG4gIC8vIGFuYWx5dGljc1BhZ2UgZW5kcyBcclxufVxyXG5cclxuLy8gKG1heC13aWR0aDogMTU5OXB4KSBlbmRzIFxyXG5cclxuQG1lZGlhIChtYXgtd2lkdGg6ICR4bC1tYXgtd2lkdGgpIHtcclxuICAuYW5hbHl0aWNzUGFnZSB7XHJcblxyXG4gICAgLmNhcmQtaGVhZGVyLFxyXG4gICAgLmNhcmQtZm9vdGVyLFxyXG4gICAgLmNhcmQtYm9keSB7XHJcbiAgICAgIHBhZGRpbmc6IC42cmVtIDFyZW07XHJcbiAgICB9XHJcblxyXG4gICAgLmNhc2VQZXJEYXlNc2cge1xyXG4gICAgICBmb250LXNpemU6IDAuN3JlbTtcclxuICAgICAgbWFyZ2luOiAwICFpbXBvcnRhbnQ7XHJcbiAgICB9XHJcbiAgICAuY2FzZVN0YXR1c0RpdntcclxuICAgICAgcGFkZGluZy10b3A6IDEuNXJlbTtcclxuICAgIH1cclxuXHJcbiAgICAuY2FzZVN0YXR1c0RpdiAubXktMyB7XHJcbiAgICAgIG1hcmdpbjogMCAhaW1wb3J0YW50O1xyXG4gIH1cclxuXHJcbiAgfVxyXG5cclxuICAvLyBhbmFseXRpY3NQYWdlIGVuZHMgXHJcbn1cclxuXHJcbi8vICR4bC1tYXgtd2lkdGg6IDExOTlweCBlbmRzIFxyXG5cclxuQG1lZGlhIChtYXgtd2lkdGg6ICRsZy1tYXgtd2lkdGgpe1xyXG5cclxufVxyXG4vLyAkbGctbWF4LXdpZHRoOiA5OTFweDtcclxuXHJcbkBtZWRpYSAobWF4LXdpZHRoOiAkc20tbWF4LXdpZHRoKXtcclxuIFxyXG59XHJcbi8vICRzbS1tYXgtd2lkdGg6IDU3NXB4O1xyXG5cclxuICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIFJlc3BvbnNpdmVuZXNzIEVuZHMgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogXHJcblxyXG4iXX0= */"] });
/*@__PURE__*/ (function () { _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](DashboardComponent, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"],
        args: [{
                selector: 'app-dashboard',
                templateUrl: './dashboard.component.html',
                styleUrls: ['./dashboard.component.scss']
            }]
    }], function () { return [{ type: src_app_services_dashboard_service__WEBPACK_IMPORTED_MODULE_1__["DashboardService"] }]; }, null); })();


/***/ }),

/***/ "XJJ9":
/*!*********************************************!*\
  !*** ./node_modules/d3-random/src/bates.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _defaultSource__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./defaultSource */ "0RZX");
/* harmony import */ var _irwinHall__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./irwinHall */ "hSnb");



/* harmony default export */ __webpack_exports__["default"] = ((function sourceRandomBates(source) {
  function randomBates(n) {
    var randomIrwinHall = _irwinHall__WEBPACK_IMPORTED_MODULE_1__["default"].source(source)(n);
    return function() {
      return randomIrwinHall() / n;
    };
  }

  randomBates.source = sourceRandomBates;

  return randomBates;
})(_defaultSource__WEBPACK_IMPORTED_MODULE_0__["default"]));


/***/ }),

/***/ "XO33":
/*!*********************************************!*\
  !*** ./node_modules/d3-fetch/src/buffer.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function responseArrayBuffer(response) {
  if (!response.ok) throw new Error(response.status + " " + response.statusText);
  return response.arrayBuffer();
}

/* harmony default export */ __webpack_exports__["default"] = (function(input, init) {
  return fetch(input, init).then(responseArrayBuffer);
});


/***/ }),

/***/ "XTLa":
/*!***************************************************************!*\
  !*** ./node_modules/c3/node_modules/d3-array/src/constant.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return function() {
    return x;
  };
});


/***/ }),

/***/ "XTjh":
/*!*************************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/sequential-multi/cividis.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(t) {
  t = Math.max(0, Math.min(1, t));
  return "rgb("
      + Math.max(0, Math.min(255, Math.round(-4.54 - t * (35.34 - t * (2381.73 - t * (6402.7 - t * (7024.72 - t * 2710.57))))))) + ", "
      + Math.max(0, Math.min(255, Math.round(32.49 + t * (170.73 + t * (52.82 - t * (131.46 - t * (176.58 - t * 67.37))))))) + ", "
      + Math.max(0, Math.min(255, Math.round(81.24 + t * (442.36 - t * (2482.43 - t * (6167.24 - t * (6614.94 - t * 2475.67)))))))
      + ")";
});


/***/ }),

/***/ "XfOf":
/*!***************************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/sequential-multi/cubehelix.js ***!
  \***************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "SC+/");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-interpolate */ "pD2Y");



/* harmony default export */ __webpack_exports__["default"] = (Object(d3_interpolate__WEBPACK_IMPORTED_MODULE_1__["interpolateCubehelixLong"])(Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["cubehelix"])(300, 0.5, 0.0), Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["cubehelix"])(-240, 0.5, 1.0)));


/***/ }),

/***/ "Y3EW":
/*!**********************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/sequential-multi/BuPu.js ***!
  \**********************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors.js */ "ZtE7");
/* harmony import */ var _ramp_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp.js */ "jQWc");



var scheme = new Array(3).concat(
  "e0ecf49ebcda8856a7",
  "edf8fbb3cde38c96c688419d",
  "edf8fbb3cde38c96c68856a7810f7c",
  "edf8fbbfd3e69ebcda8c96c68856a7810f7c",
  "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b",
  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b",
  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b"
).map(_colors_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp_js__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "Y4Tn":
/*!******************************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/transverseMercator.js ***!
  \******************************************************************/
/*! exports provided: transverseMercatorRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transverseMercatorRaw", function() { return transverseMercatorRaw; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "R0y8");
/* harmony import */ var _mercator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mercator.js */ "LZ5Q");



function transverseMercatorRaw(lambda, phi) {
  return [Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["log"])(Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["tan"])((_math_js__WEBPACK_IMPORTED_MODULE_0__["halfPi"] + phi) / 2)), -lambda];
}

transverseMercatorRaw.invert = function(x, y) {
  return [-y, 2 * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["atan"])(Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["exp"])(x)) - _math_js__WEBPACK_IMPORTED_MODULE_0__["halfPi"]];
};

/* harmony default export */ __webpack_exports__["default"] = (function() {
  var m = Object(_mercator_js__WEBPACK_IMPORTED_MODULE_1__["mercatorProjection"])(transverseMercatorRaw),
      center = m.center,
      rotate = m.rotate;

  m.center = function(_) {
    return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);
  };

  m.rotate = function(_) {
    return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);
  };

  return rotate([0, 0, 90])
      .scale(159.155);
});


/***/ }),

/***/ "Yij6":
/*!**********************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/sequential-multi/RdPu.js ***!
  \**********************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors.js */ "ZtE7");
/* harmony import */ var _ramp_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp.js */ "jQWc");



var scheme = new Array(3).concat(
  "fde0ddfa9fb5c51b8a",
  "feebe2fbb4b9f768a1ae017e",
  "feebe2fbb4b9f768a1c51b8a7a0177",
  "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177",
  "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177",
  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177",
  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a"
).map(_colors_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp_js__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "Yn3m":
/*!***************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/diverging/RdBu.js ***!
  \***************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors.js */ "ZtE7");
/* harmony import */ var _ramp_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp.js */ "jQWc");



var scheme = new Array(3).concat(
  "ef8a62f7f7f767a9cf",
  "ca0020f4a58292c5de0571b0",
  "ca0020f4a582f7f7f792c5de0571b0",
  "b2182bef8a62fddbc7d1e5f067a9cf2166ac",
  "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac",
  "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac",
  "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac",
  "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061",
  "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061"
).map(_colors_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp_js__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "YzSS":
/*!**********************************************!*\
  !*** ./node_modules/d3-geo/src/cartesian.js ***!
  \**********************************************/
/*! exports provided: spherical, cartesian, cartesianDot, cartesianCross, cartesianAddInPlace, cartesianScale, cartesianNormalizeInPlace */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "spherical", function() { return spherical; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cartesian", function() { return cartesian; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cartesianDot", function() { return cartesianDot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cartesianCross", function() { return cartesianCross; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cartesianAddInPlace", function() { return cartesianAddInPlace; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cartesianScale", function() { return cartesianScale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cartesianNormalizeInPlace", function() { return cartesianNormalizeInPlace; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "R0y8");


function spherical(cartesian) {
  return [Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["atan2"])(cartesian[1], cartesian[0]), Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["asin"])(cartesian[2])];
}

function cartesian(spherical) {
  var lambda = spherical[0], phi = spherical[1], cosPhi = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["cos"])(phi);
  return [cosPhi * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["cos"])(lambda), cosPhi * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sin"])(lambda), Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sin"])(phi)];
}

function cartesianDot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

function cartesianCross(a, b) {
  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
}

// TODO return a
function cartesianAddInPlace(a, b) {
  a[0] += b[0], a[1] += b[1], a[2] += b[2];
}

function cartesianScale(vector, k) {
  return [vector[0] * k, vector[1] * k, vector[2] * k];
}

// TODO return d
function cartesianNormalizeInPlace(d) {
  var l = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
  d[0] /= l, d[1] /= l, d[2] /= l;
}


/***/ }),

/***/ "Z9Ww":
/*!***********************************************!*\
  !*** ./node_modules/d3-force/src/manyBody.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant */ "nXVj");
/* harmony import */ var _jiggle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./jiggle */ "QupR");
/* harmony import */ var d3_quadtree__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-quadtree */ "gO8D");
/* harmony import */ var _simulation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./simulation */ "VIHS");





/* harmony default export */ __webpack_exports__["default"] = (function() {
  var nodes,
      node,
      alpha,
      strength = Object(_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(-30),
      strengths,
      distanceMin2 = 1,
      distanceMax2 = Infinity,
      theta2 = 0.81;

  function force(_) {
    var i, n = nodes.length, tree = Object(d3_quadtree__WEBPACK_IMPORTED_MODULE_2__["quadtree"])(nodes, _simulation__WEBPACK_IMPORTED_MODULE_3__["x"], _simulation__WEBPACK_IMPORTED_MODULE_3__["y"]).visitAfter(accumulate);
    for (alpha = _, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply);
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length, node;
    strengths = new Array(n);
    for (i = 0; i < n; ++i) node = nodes[i], strengths[node.index] = +strength(node, i, nodes);
  }

  function accumulate(quad) {
    var strength = 0, q, c, weight = 0, x, y, i;

    // For internal nodes, accumulate forces from child quadrants.
    if (quad.length) {
      for (x = y = i = 0; i < 4; ++i) {
        if ((q = quad[i]) && (c = Math.abs(q.value))) {
          strength += q.value, weight += c, x += c * q.x, y += c * q.y;
        }
      }
      quad.x = x / weight;
      quad.y = y / weight;
    }

    // For leaf nodes, accumulate forces from coincident quadrants.
    else {
      q = quad;
      q.x = q.data.x;
      q.y = q.data.y;
      do strength += strengths[q.data.index];
      while (q = q.next);
    }

    quad.value = strength;
  }

  function apply(quad, x1, _, x2) {
    if (!quad.value) return true;

    var x = quad.x - node.x,
        y = quad.y - node.y,
        w = x2 - x1,
        l = x * x + y * y;

    // Apply the Barnes-Hut approximation if possible.
    // Limit forces for very close nodes; randomize direction if coincident.
    if (w * w / theta2 < l) {
      if (l < distanceMax2) {
        if (x === 0) x = Object(_jiggle__WEBPACK_IMPORTED_MODULE_1__["default"])(), l += x * x;
        if (y === 0) y = Object(_jiggle__WEBPACK_IMPORTED_MODULE_1__["default"])(), l += y * y;
        if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
        node.vx += x * quad.value * alpha / l;
        node.vy += y * quad.value * alpha / l;
      }
      return true;
    }

    // Otherwise, process points directly.
    else if (quad.length || l >= distanceMax2) return;

    // Limit forces for very close nodes; randomize direction if coincident.
    if (quad.data !== node || quad.next) {
      if (x === 0) x = Object(_jiggle__WEBPACK_IMPORTED_MODULE_1__["default"])(), l += x * x;
      if (y === 0) y = Object(_jiggle__WEBPACK_IMPORTED_MODULE_1__["default"])(), l += y * y;
      if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
    }

    do if (quad.data !== node) {
      w = strengths[quad.data.index] * alpha / l;
      node.vx += x * w;
      node.vy += y * w;
    } while (quad = quad.next);
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), initialize(), force) : strength;
  };

  force.distanceMin = function(_) {
    return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);
  };

  force.distanceMax = function(_) {
    return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);
  };

  force.theta = function(_) {
    return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);
  };

  return force;
});


/***/ }),

/***/ "ZtE7":
/*!*******************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/colors.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(specifier) {
  var n = specifier.length / 6 | 0, colors = new Array(n), i = 0;
  while (i < n) colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
  return colors;
});


/***/ }),

/***/ "aR9J":
/*!*************************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/stereographic.js ***!
  \*************************************************************/
/*! exports provided: stereographicRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stereographicRaw", function() { return stereographicRaw; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "R0y8");
/* harmony import */ var _azimuthal_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./azimuthal.js */ "dg0l");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.js */ "1ibS");




function stereographicRaw(x, y) {
  var cy = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["cos"])(y), k = 1 + Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["cos"])(x) * cy;
  return [cy * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sin"])(x) / k, Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sin"])(y) / k];
}

stereographicRaw.invert = Object(_azimuthal_js__WEBPACK_IMPORTED_MODULE_1__["azimuthalInvert"])(function(z) {
  return 2 * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["atan"])(z);
});

/* harmony default export */ __webpack_exports__["default"] = (function() {
  return Object(_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(stereographicRaw)
      .scale(250)
      .clipAngle(142);
});


/***/ }),

/***/ "aj5g":
/*!*********************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/albersUsa.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "R0y8");
/* harmony import */ var _albers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./albers.js */ "iQWy");
/* harmony import */ var _conicEqualArea_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./conicEqualArea.js */ "nVu6");
/* harmony import */ var _fit_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./fit.js */ "XAaG");





// The projections must have mutually exclusive clip regions on the sphere,
// as this will avoid emitting interleaving lines and polygons.
function multiplex(streams) {
  var n = streams.length;
  return {
    point: function(x, y) { var i = -1; while (++i < n) streams[i].point(x, y); },
    sphere: function() { var i = -1; while (++i < n) streams[i].sphere(); },
    lineStart: function() { var i = -1; while (++i < n) streams[i].lineStart(); },
    lineEnd: function() { var i = -1; while (++i < n) streams[i].lineEnd(); },
    polygonStart: function() { var i = -1; while (++i < n) streams[i].polygonStart(); },
    polygonEnd: function() { var i = -1; while (++i < n) streams[i].polygonEnd(); }
  };
}

// A composite projection for the United States, configured by default for
// 960×500. The projection also works quite well at 960×600 if you change the
// scale to 1285 and adjust the translate accordingly. The set of standard
// parallels for each region comes from USGS, which is published here:
// http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers
/* harmony default export */ __webpack_exports__["default"] = (function() {
  var cache,
      cacheStream,
      lower48 = Object(_albers_js__WEBPACK_IMPORTED_MODULE_1__["default"])(), lower48Point,
      alaska = Object(_conicEqualArea_js__WEBPACK_IMPORTED_MODULE_2__["default"])().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, // EPSG:3338
      hawaii = Object(_conicEqualArea_js__WEBPACK_IMPORTED_MODULE_2__["default"])().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, // ESRI:102007
      point, pointStream = {point: function(x, y) { point = [x, y]; }};

  function albersUsa(coordinates) {
    var x = coordinates[0], y = coordinates[1];
    return point = null,
        (lower48Point.point(x, y), point)
        || (alaskaPoint.point(x, y), point)
        || (hawaiiPoint.point(x, y), point);
  }

  albersUsa.invert = function(coordinates) {
    var k = lower48.scale(),
        t = lower48.translate(),
        x = (coordinates[0] - t[0]) / k,
        y = (coordinates[1] - t[1]) / k;
    return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska
        : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii
        : lower48).invert(coordinates);
  };

  albersUsa.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
  };

  albersUsa.precision = function(_) {
    if (!arguments.length) return lower48.precision();
    lower48.precision(_), alaska.precision(_), hawaii.precision(_);
    return reset();
  };

  albersUsa.scale = function(_) {
    if (!arguments.length) return lower48.scale();
    lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
    return albersUsa.translate(lower48.translate());
  };

  albersUsa.translate = function(_) {
    if (!arguments.length) return lower48.translate();
    var k = lower48.scale(), x = +_[0], y = +_[1];

    lower48Point = lower48
        .translate(_)
        .clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]])
        .stream(pointStream);

    alaskaPoint = alaska
        .translate([x - 0.307 * k, y + 0.201 * k])
        .clipExtent([[x - 0.425 * k + _math_js__WEBPACK_IMPORTED_MODULE_0__["epsilon"], y + 0.120 * k + _math_js__WEBPACK_IMPORTED_MODULE_0__["epsilon"]], [x - 0.214 * k - _math_js__WEBPACK_IMPORTED_MODULE_0__["epsilon"], y + 0.234 * k - _math_js__WEBPACK_IMPORTED_MODULE_0__["epsilon"]]])
        .stream(pointStream);

    hawaiiPoint = hawaii
        .translate([x - 0.205 * k, y + 0.212 * k])
        .clipExtent([[x - 0.214 * k + _math_js__WEBPACK_IMPORTED_MODULE_0__["epsilon"], y + 0.166 * k + _math_js__WEBPACK_IMPORTED_MODULE_0__["epsilon"]], [x - 0.115 * k - _math_js__WEBPACK_IMPORTED_MODULE_0__["epsilon"], y + 0.234 * k - _math_js__WEBPACK_IMPORTED_MODULE_0__["epsilon"]]])
        .stream(pointStream);

    return reset();
  };

  albersUsa.fitExtent = function(extent, object) {
    return Object(_fit_js__WEBPACK_IMPORTED_MODULE_3__["fitExtent"])(albersUsa, extent, object);
  };

  albersUsa.fitSize = function(size, object) {
    return Object(_fit_js__WEBPACK_IMPORTED_MODULE_3__["fitSize"])(albersUsa, size, object);
  };

  albersUsa.fitWidth = function(width, object) {
    return Object(_fit_js__WEBPACK_IMPORTED_MODULE_3__["fitWidth"])(albersUsa, width, object);
  };

  albersUsa.fitHeight = function(height, object) {
    return Object(_fit_js__WEBPACK_IMPORTED_MODULE_3__["fitHeight"])(albersUsa, height, object);
  };

  function reset() {
    cache = cacheStream = null;
    return albersUsa;
  }

  return albersUsa.scale(1070);
});


/***/ }),

/***/ "amxm":
/*!****************************************************************!*\
  !*** ./node_modules/c3/node_modules/d3-array/src/deviation.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _variance__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./variance */ "w5my");


/* harmony default export */ __webpack_exports__["default"] = (function(array, f) {
  var v = Object(_variance__WEBPACK_IMPORTED_MODULE_0__["default"])(array, f);
  return v ? Math.sqrt(v) : v;
});


/***/ }),

/***/ "bKjm":
/*!**********************************************!*\
  !*** ./node_modules/d3-voronoi/src/index.js ***!
  \**********************************************/
/*! exports provided: voronoi */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _voronoi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./voronoi */ "EGnP");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "voronoi", function() { return _voronoi__WEBPACK_IMPORTED_MODULE_0__["default"]; });




/***/ }),

/***/ "bN2o":
/*!*****************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/conic.js ***!
  \*****************************************************/
/*! exports provided: conicProjection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conicProjection", function() { return conicProjection; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "R0y8");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "1ibS");



function conicProjection(projectAt) {
  var phi0 = 0,
      phi1 = _math_js__WEBPACK_IMPORTED_MODULE_0__["pi"] / 3,
      m = Object(_index_js__WEBPACK_IMPORTED_MODULE_1__["projectionMutator"])(projectAt),
      p = m(phi0, phi1);

  p.parallels = function(_) {
    return arguments.length ? m(phi0 = _[0] * _math_js__WEBPACK_IMPORTED_MODULE_0__["radians"], phi1 = _[1] * _math_js__WEBPACK_IMPORTED_MODULE_0__["radians"]) : [phi0 * _math_js__WEBPACK_IMPORTED_MODULE_0__["degrees"], phi1 * _math_js__WEBPACK_IMPORTED_MODULE_0__["degrees"]];
  };

  return p;
}


/***/ }),

/***/ "bUA0":
/*!********************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/identity.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _clip_rectangle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../clip/rectangle.js */ "F2eR");
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../identity.js */ "IYKK");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../transform.js */ "t9E6");
/* harmony import */ var _fit_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./fit.js */ "XAaG");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math.js */ "R0y8");






/* harmony default export */ __webpack_exports__["default"] = (function() {
  var k = 1, tx = 0, ty = 0, sx = 1, sy = 1, // scale, translate and reflect
      alpha = 0, ca, sa, // angle
      x0 = null, y0, x1, y1, // clip extent
      kx = 1, ky = 1,
      transform = Object(_transform_js__WEBPACK_IMPORTED_MODULE_2__["transformer"])({
        point: function(x, y) {
          var p = projection([x, y])
          this.stream.point(p[0], p[1]);
        }
      }),
      postclip = _identity_js__WEBPACK_IMPORTED_MODULE_1__["default"],
      cache,
      cacheStream;

  function reset() {
    kx = k * sx;
    ky = k * sy;
    cache = cacheStream = null;
    return projection;
  }

  function projection (p) {
    var x = p[0] * kx, y = p[1] * ky;
    if (alpha) {
      var t = y * ca - x * sa;
      x = x * ca + y * sa;
      y = t;
    }    
    return [x + tx, y + ty];
  }
  projection.invert = function(p) {
    var x = p[0] - tx, y = p[1] - ty;
    if (alpha) {
      var t = y * ca + x * sa;
      x = x * ca - y * sa;
      y = t;
    }
    return [x / kx, y / ky];
  };
  projection.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = transform(postclip(cacheStream = stream));
  };
  projection.postclip = function(_) {
    return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
  };
  projection.clipExtent = function(_) {
    return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, _identity_js__WEBPACK_IMPORTED_MODULE_1__["default"]) : Object(_clip_rectangle_js__WEBPACK_IMPORTED_MODULE_0__["default"])(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
  };
  projection.scale = function(_) {
    return arguments.length ? (k = +_, reset()) : k;
  };
  projection.translate = function(_) {
    return arguments.length ? (tx = +_[0], ty = +_[1], reset()) : [tx, ty];
  }
  projection.angle = function(_) {
    return arguments.length ? (alpha = _ % 360 * _math_js__WEBPACK_IMPORTED_MODULE_4__["radians"], sa = Object(_math_js__WEBPACK_IMPORTED_MODULE_4__["sin"])(alpha), ca = Object(_math_js__WEBPACK_IMPORTED_MODULE_4__["cos"])(alpha), reset()) : alpha * _math_js__WEBPACK_IMPORTED_MODULE_4__["degrees"];
  };
  projection.reflectX = function(_) {
    return arguments.length ? (sx = _ ? -1 : 1, reset()) : sx < 0;
  };
  projection.reflectY = function(_) {
    return arguments.length ? (sy = _ ? -1 : 1, reset()) : sy < 0;
  };
  projection.fitExtent = function(extent, object) {
    return Object(_fit_js__WEBPACK_IMPORTED_MODULE_3__["fitExtent"])(projection, extent, object);
  };
  projection.fitSize = function(size, object) {
    return Object(_fit_js__WEBPACK_IMPORTED_MODULE_3__["fitSize"])(projection, size, object);
  };
  projection.fitWidth = function(width, object) {
    return Object(_fit_js__WEBPACK_IMPORTED_MODULE_3__["fitWidth"])(projection, width, object);
  };
  projection.fitHeight = function(height, object) {
    return Object(_fit_js__WEBPACK_IMPORTED_MODULE_3__["fitHeight"])(projection, height, object);
  };

  return projection;
});


/***/ }),

/***/ "bwSX":
/*!*************************************************!*\
  !*** ./node_modules/d3-collection/src/index.js ***!
  \*************************************************/
/*! exports provided: nest, set, map, keys, values, entries */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _nest__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nest */ "mZMl");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "nest", function() { return _nest__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _set__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./set */ "X181");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "set", function() { return _set__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./map */ "+RkR");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "map", function() { return _map__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _keys__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./keys */ "GlnO");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "keys", function() { return _keys__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _values__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./values */ "CIwN");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "values", function() { return _values__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _entries__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./entries */ "hLuZ");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "entries", function() { return _entries__WEBPACK_IMPORTED_MODULE_5__["default"]; });









/***/ }),

/***/ "cnUW":
/*!****************************************!*\
  !*** ./node_modules/d3-force/src/x.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant */ "nXVj");


/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  var strength = Object(_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(0.1),
      nodes,
      strengths,
      xz;

  if (typeof x !== "function") x = Object(_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(x == null ? 0 : +x);

  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    xz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), initialize(), force) : strength;
  };

  force.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), initialize(), force) : x;
  };

  return force;
});


/***/ }),

/***/ "cwsO":
/*!*********************************************!*\
  !*** ./node_modules/d3-geo/src/rotation.js ***!
  \*********************************************/
/*! exports provided: rotateRadians, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateRadians", function() { return rotateRadians; });
/* harmony import */ var _compose_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./compose.js */ "pbho");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ "R0y8");



function rotationIdentity(lambda, phi) {
  return [Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["abs"])(lambda) > _math_js__WEBPACK_IMPORTED_MODULE_1__["pi"] ? lambda + Math.round(-lambda / _math_js__WEBPACK_IMPORTED_MODULE_1__["tau"]) * _math_js__WEBPACK_IMPORTED_MODULE_1__["tau"] : lambda, phi];
}

rotationIdentity.invert = rotationIdentity;

function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
  return (deltaLambda %= _math_js__WEBPACK_IMPORTED_MODULE_1__["tau"]) ? (deltaPhi || deltaGamma ? Object(_compose_js__WEBPACK_IMPORTED_MODULE_0__["default"])(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma))
    : rotationLambda(deltaLambda))
    : (deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma)
    : rotationIdentity);
}

function forwardRotationLambda(deltaLambda) {
  return function(lambda, phi) {
    return lambda += deltaLambda, [lambda > _math_js__WEBPACK_IMPORTED_MODULE_1__["pi"] ? lambda - _math_js__WEBPACK_IMPORTED_MODULE_1__["tau"] : lambda < -_math_js__WEBPACK_IMPORTED_MODULE_1__["pi"] ? lambda + _math_js__WEBPACK_IMPORTED_MODULE_1__["tau"] : lambda, phi];
  };
}

function rotationLambda(deltaLambda) {
  var rotation = forwardRotationLambda(deltaLambda);
  rotation.invert = forwardRotationLambda(-deltaLambda);
  return rotation;
}

function rotationPhiGamma(deltaPhi, deltaGamma) {
  var cosDeltaPhi = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["cos"])(deltaPhi),
      sinDeltaPhi = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["sin"])(deltaPhi),
      cosDeltaGamma = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["cos"])(deltaGamma),
      sinDeltaGamma = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["sin"])(deltaGamma);

  function rotation(lambda, phi) {
    var cosPhi = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi),
        x = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["cos"])(lambda) * cosPhi,
        y = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["sin"])(lambda) * cosPhi,
        z = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi),
        k = z * cosDeltaPhi + x * sinDeltaPhi;
    return [
      Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["atan2"])(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),
      Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["asin"])(k * cosDeltaGamma + y * sinDeltaGamma)
    ];
  }

  rotation.invert = function(lambda, phi) {
    var cosPhi = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi),
        x = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["cos"])(lambda) * cosPhi,
        y = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["sin"])(lambda) * cosPhi,
        z = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi),
        k = z * cosDeltaGamma - y * sinDeltaGamma;
    return [
      Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["atan2"])(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),
      Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["asin"])(k * cosDeltaPhi - x * sinDeltaPhi)
    ];
  };

  return rotation;
}

/* harmony default export */ __webpack_exports__["default"] = (function(rotate) {
  rotate = rotateRadians(rotate[0] * _math_js__WEBPACK_IMPORTED_MODULE_1__["radians"], rotate[1] * _math_js__WEBPACK_IMPORTED_MODULE_1__["radians"], rotate.length > 2 ? rotate[2] * _math_js__WEBPACK_IMPORTED_MODULE_1__["radians"] : 0);

  function forward(coordinates) {
    coordinates = rotate(coordinates[0] * _math_js__WEBPACK_IMPORTED_MODULE_1__["radians"], coordinates[1] * _math_js__WEBPACK_IMPORTED_MODULE_1__["radians"]);
    return coordinates[0] *= _math_js__WEBPACK_IMPORTED_MODULE_1__["degrees"], coordinates[1] *= _math_js__WEBPACK_IMPORTED_MODULE_1__["degrees"], coordinates;
  }

  forward.invert = function(coordinates) {
    coordinates = rotate.invert(coordinates[0] * _math_js__WEBPACK_IMPORTED_MODULE_1__["radians"], coordinates[1] * _math_js__WEBPACK_IMPORTED_MODULE_1__["radians"]);
    return coordinates[0] *= _math_js__WEBPACK_IMPORTED_MODULE_1__["degrees"], coordinates[1] *= _math_js__WEBPACK_IMPORTED_MODULE_1__["degrees"], coordinates;
  };

  return forward;
});


/***/ }),

/***/ "d/QP":
/*!************************************************************!*\
  !*** ./node_modules/c3/node_modules/d3-scale/src/array.js ***!
  \************************************************************/
/*! exports provided: map, slice */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "map", function() { return map; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slice", function() { return slice; });
var array = Array.prototype;

var map = array.map;
var slice = array.slice;


/***/ }),

/***/ "dC/H":
/*!**********************************************!*\
  !*** ./node_modules/d3-voronoi/src/Beach.js ***!
  \**********************************************/
/*! exports provided: removeBeach, addBeach */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeBeach", function() { return removeBeach; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addBeach", function() { return addBeach; });
/* harmony import */ var _RedBlackTree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RedBlackTree */ "AyFX");
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Cell */ "Ke4m");
/* harmony import */ var _Circle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Circle */ "Kljt");
/* harmony import */ var _Edge__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Edge */ "FbTJ");
/* harmony import */ var _Diagram__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Diagram */ "Go7+");






var beachPool = [];

function Beach() {
  Object(_RedBlackTree__WEBPACK_IMPORTED_MODULE_0__["RedBlackNode"])(this);
  this.edge =
  this.site =
  this.circle = null;
}

function createBeach(site) {
  var beach = beachPool.pop() || new Beach;
  beach.site = site;
  return beach;
}

function detachBeach(beach) {
  Object(_Circle__WEBPACK_IMPORTED_MODULE_2__["detachCircle"])(beach);
  _Diagram__WEBPACK_IMPORTED_MODULE_4__["beaches"].remove(beach);
  beachPool.push(beach);
  Object(_RedBlackTree__WEBPACK_IMPORTED_MODULE_0__["RedBlackNode"])(beach);
}

function removeBeach(beach) {
  var circle = beach.circle,
      x = circle.x,
      y = circle.cy,
      vertex = [x, y],
      previous = beach.P,
      next = beach.N,
      disappearing = [beach];

  detachBeach(beach);

  var lArc = previous;
  while (lArc.circle
      && Math.abs(x - lArc.circle.x) < _Diagram__WEBPACK_IMPORTED_MODULE_4__["epsilon"]
      && Math.abs(y - lArc.circle.cy) < _Diagram__WEBPACK_IMPORTED_MODULE_4__["epsilon"]) {
    previous = lArc.P;
    disappearing.unshift(lArc);
    detachBeach(lArc);
    lArc = previous;
  }

  disappearing.unshift(lArc);
  Object(_Circle__WEBPACK_IMPORTED_MODULE_2__["detachCircle"])(lArc);

  var rArc = next;
  while (rArc.circle
      && Math.abs(x - rArc.circle.x) < _Diagram__WEBPACK_IMPORTED_MODULE_4__["epsilon"]
      && Math.abs(y - rArc.circle.cy) < _Diagram__WEBPACK_IMPORTED_MODULE_4__["epsilon"]) {
    next = rArc.N;
    disappearing.push(rArc);
    detachBeach(rArc);
    rArc = next;
  }

  disappearing.push(rArc);
  Object(_Circle__WEBPACK_IMPORTED_MODULE_2__["detachCircle"])(rArc);

  var nArcs = disappearing.length,
      iArc;
  for (iArc = 1; iArc < nArcs; ++iArc) {
    rArc = disappearing[iArc];
    lArc = disappearing[iArc - 1];
    Object(_Edge__WEBPACK_IMPORTED_MODULE_3__["setEdgeEnd"])(rArc.edge, lArc.site, rArc.site, vertex);
  }

  lArc = disappearing[0];
  rArc = disappearing[nArcs - 1];
  rArc.edge = Object(_Edge__WEBPACK_IMPORTED_MODULE_3__["createEdge"])(lArc.site, rArc.site, null, vertex);

  Object(_Circle__WEBPACK_IMPORTED_MODULE_2__["attachCircle"])(lArc);
  Object(_Circle__WEBPACK_IMPORTED_MODULE_2__["attachCircle"])(rArc);
}

function addBeach(site) {
  var x = site[0],
      directrix = site[1],
      lArc,
      rArc,
      dxl,
      dxr,
      node = _Diagram__WEBPACK_IMPORTED_MODULE_4__["beaches"]._;

  while (node) {
    dxl = leftBreakPoint(node, directrix) - x;
    if (dxl > _Diagram__WEBPACK_IMPORTED_MODULE_4__["epsilon"]) node = node.L; else {
      dxr = x - rightBreakPoint(node, directrix);
      if (dxr > _Diagram__WEBPACK_IMPORTED_MODULE_4__["epsilon"]) {
        if (!node.R) {
          lArc = node;
          break;
        }
        node = node.R;
      } else {
        if (dxl > -_Diagram__WEBPACK_IMPORTED_MODULE_4__["epsilon"]) {
          lArc = node.P;
          rArc = node;
        } else if (dxr > -_Diagram__WEBPACK_IMPORTED_MODULE_4__["epsilon"]) {
          lArc = node;
          rArc = node.N;
        } else {
          lArc = rArc = node;
        }
        break;
      }
    }
  }

  Object(_Cell__WEBPACK_IMPORTED_MODULE_1__["createCell"])(site);
  var newArc = createBeach(site);
  _Diagram__WEBPACK_IMPORTED_MODULE_4__["beaches"].insert(lArc, newArc);

  if (!lArc && !rArc) return;

  if (lArc === rArc) {
    Object(_Circle__WEBPACK_IMPORTED_MODULE_2__["detachCircle"])(lArc);
    rArc = createBeach(lArc.site);
    _Diagram__WEBPACK_IMPORTED_MODULE_4__["beaches"].insert(newArc, rArc);
    newArc.edge = rArc.edge = Object(_Edge__WEBPACK_IMPORTED_MODULE_3__["createEdge"])(lArc.site, newArc.site);
    Object(_Circle__WEBPACK_IMPORTED_MODULE_2__["attachCircle"])(lArc);
    Object(_Circle__WEBPACK_IMPORTED_MODULE_2__["attachCircle"])(rArc);
    return;
  }

  if (!rArc) { // && lArc
    newArc.edge = Object(_Edge__WEBPACK_IMPORTED_MODULE_3__["createEdge"])(lArc.site, newArc.site);
    return;
  }

  // else lArc !== rArc
  Object(_Circle__WEBPACK_IMPORTED_MODULE_2__["detachCircle"])(lArc);
  Object(_Circle__WEBPACK_IMPORTED_MODULE_2__["detachCircle"])(rArc);

  var lSite = lArc.site,
      ax = lSite[0],
      ay = lSite[1],
      bx = site[0] - ax,
      by = site[1] - ay,
      rSite = rArc.site,
      cx = rSite[0] - ax,
      cy = rSite[1] - ay,
      d = 2 * (bx * cy - by * cx),
      hb = bx * bx + by * by,
      hc = cx * cx + cy * cy,
      vertex = [(cy * hb - by * hc) / d + ax, (bx * hc - cx * hb) / d + ay];

  Object(_Edge__WEBPACK_IMPORTED_MODULE_3__["setEdgeEnd"])(rArc.edge, lSite, rSite, vertex);
  newArc.edge = Object(_Edge__WEBPACK_IMPORTED_MODULE_3__["createEdge"])(lSite, site, null, vertex);
  rArc.edge = Object(_Edge__WEBPACK_IMPORTED_MODULE_3__["createEdge"])(site, rSite, null, vertex);
  Object(_Circle__WEBPACK_IMPORTED_MODULE_2__["attachCircle"])(lArc);
  Object(_Circle__WEBPACK_IMPORTED_MODULE_2__["attachCircle"])(rArc);
}

function leftBreakPoint(arc, directrix) {
  var site = arc.site,
      rfocx = site[0],
      rfocy = site[1],
      pby2 = rfocy - directrix;

  if (!pby2) return rfocx;

  var lArc = arc.P;
  if (!lArc) return -Infinity;

  site = lArc.site;
  var lfocx = site[0],
      lfocy = site[1],
      plby2 = lfocy - directrix;

  if (!plby2) return lfocx;

  var hl = lfocx - rfocx,
      aby2 = 1 / pby2 - 1 / plby2,
      b = hl / plby2;

  if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;

  return (rfocx + lfocx) / 2;
}

function rightBreakPoint(arc, directrix) {
  var rArc = arc.N;
  if (rArc) return leftBreakPoint(rArc, directrix);
  var site = arc.site;
  return site[1] === directrix ? site[0] : Infinity;
}


/***/ }),

/***/ "dg0l":
/*!*********************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/azimuthal.js ***!
  \*********************************************************/
/*! exports provided: azimuthalRaw, azimuthalInvert */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "azimuthalRaw", function() { return azimuthalRaw; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "azimuthalInvert", function() { return azimuthalInvert; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "R0y8");


function azimuthalRaw(scale) {
  return function(x, y) {
    var cx = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["cos"])(x),
        cy = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["cos"])(y),
        k = scale(cx * cy);
    return [
      k * cy * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sin"])(x),
      k * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sin"])(y)
    ];
  }
}

function azimuthalInvert(angle) {
  return function(x, y) {
    var z = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(x * x + y * y),
        c = angle(z),
        sc = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sin"])(c),
        cc = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["cos"])(c);
    return [
      Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["atan2"])(x * sc, z * cc),
      Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["asin"])(z && y * sc / z)
    ];
  }
}


/***/ }),

/***/ "eTLM":
/*!***************************************************!*\
  !*** ./node_modules/d3-random/src/exponential.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _defaultSource__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./defaultSource */ "0RZX");


/* harmony default export */ __webpack_exports__["default"] = ((function sourceRandomExponential(source) {
  function randomExponential(lambda) {
    return function() {
      return -Math.log(1 - source()) / lambda;
    };
  }

  randomExponential.source = sourceRandomExponential;

  return randomExponential;
})(_defaultSource__WEBPACK_IMPORTED_MODULE_0__["default"]));


/***/ }),

/***/ "eW2m":
/*!**********************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/sequential-multi/PuRd.js ***!
  \**********************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors.js */ "ZtE7");
/* harmony import */ var _ramp_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp.js */ "jQWc");



var scheme = new Array(3).concat(
  "e7e1efc994c7dd1c77",
  "f1eef6d7b5d8df65b0ce1256",
  "f1eef6d7b5d8df65b0dd1c77980043",
  "f1eef6d4b9dac994c7df65b0dd1c77980043",
  "f1eef6d4b9dac994c7df65b0e7298ace125691003f",
  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f",
  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f"
).map(_colors_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp_js__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "eYML":
/*!************************************************************!*\
  !*** ./node_modules/c3/node_modules/d3-array/src/merge.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(arrays) {
  var n = arrays.length,
      m,
      i = -1,
      j = 0,
      merged,
      array;

  while (++i < n) j += arrays[i].length;
  merged = new Array(j);

  while (--n >= 0) {
    array = arrays[n];
    m = array.length;
    while (--m >= 0) {
      merged[--j] = array[m];
    }
  }

  return merged;
});


/***/ }),

/***/ "ea/W":
/*!*************************************************************!*\
  !*** ./src/app/pages/dashboard/dashboard-routing.module.ts ***!
  \*************************************************************/
/*! exports provided: DashboardRoutingModule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DashboardRoutingModule", function() { return DashboardRoutingModule; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "8Y7J");
/* harmony import */ var _angular_router__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/router */ "iInd");
/* harmony import */ var _dashboard_dashboard_component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dashboard/dashboard.component */ "XElW");





const routes = [{
        path: '',
        component: _dashboard_dashboard_component__WEBPACK_IMPORTED_MODULE_2__["DashboardComponent"]
    }];
class DashboardRoutingModule {
}
DashboardRoutingModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({ type: DashboardRoutingModule });
DashboardRoutingModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({ factory: function DashboardRoutingModule_Factory(t) { return new (t || DashboardRoutingModule)(); }, imports: [[_angular_router__WEBPACK_IMPORTED_MODULE_1__["RouterModule"].forChild(routes)], _angular_router__WEBPACK_IMPORTED_MODULE_1__["RouterModule"]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](DashboardRoutingModule, { imports: [_angular_router__WEBPACK_IMPORTED_MODULE_1__["RouterModule"]], exports: [_angular_router__WEBPACK_IMPORTED_MODULE_1__["RouterModule"]] }); })();
/*@__PURE__*/ (function () { _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](DashboardRoutingModule, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"],
        args: [{
                imports: [_angular_router__WEBPACK_IMPORTED_MODULE_1__["RouterModule"].forChild(routes)],
                exports: [_angular_router__WEBPACK_IMPORTED_MODULE_1__["RouterModule"]]
            }]
    }], null, null); })();


/***/ }),

/***/ "eha6":
/*!************************************************************************!*\
  !*** ./node_modules/c3/node_modules/d3/node_modules/d3-dsv/src/dsv.js ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var EOL = {},
    EOF = {},
    QUOTE = 34,
    NEWLINE = 10,
    RETURN = 13;

function objectConverter(columns) {
  return new Function("d", "return {" + columns.map(function(name, i) {
    return JSON.stringify(name) + ": d[" + i + "] || \"\"";
  }).join(",") + "}");
}

function customConverter(columns, f) {
  var object = objectConverter(columns);
  return function(row, i) {
    return f(object(row), i, columns);
  };
}

// Compute unique columns in order of discovery.
function inferColumns(rows) {
  var columnSet = Object.create(null),
      columns = [];

  rows.forEach(function(row) {
    for (var column in row) {
      if (!(column in columnSet)) {
        columns.push(columnSet[column] = column);
      }
    }
  });

  return columns;
}

function pad(value, width) {
  var s = value + "", length = s.length;
  return length < width ? new Array(width - length + 1).join(0) + s : s;
}

function formatYear(year) {
  return year < 0 ? "-" + pad(-year, 6)
    : year > 9999 ? "+" + pad(year, 6)
    : pad(year, 4);
}

function formatDate(date) {
  var hours = date.getUTCHours(),
      minutes = date.getUTCMinutes(),
      seconds = date.getUTCSeconds(),
      milliseconds = date.getUTCMilliseconds();
  return isNaN(date) ? "Invalid Date"
      : formatYear(date.getUTCFullYear(), 4) + "-" + pad(date.getUTCMonth() + 1, 2) + "-" + pad(date.getUTCDate(), 2)
      + (milliseconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "." + pad(milliseconds, 3) + "Z"
      : seconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "Z"
      : minutes || hours ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + "Z"
      : "");
}

/* harmony default export */ __webpack_exports__["default"] = (function(delimiter) {
  var reFormat = new RegExp("[\"" + delimiter + "\n\r]"),
      DELIMITER = delimiter.charCodeAt(0);

  function parse(text, f) {
    var convert, columns, rows = parseRows(text, function(row, i) {
      if (convert) return convert(row, i - 1);
      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
    });
    rows.columns = columns || [];
    return rows;
  }

  function parseRows(text, f) {
    var rows = [], // output rows
        N = text.length,
        I = 0, // current character index
        n = 0, // current line number
        t, // current token
        eof = N <= 0, // current token followed by EOF?
        eol = false; // current token followed by EOL?

    // Strip the trailing newline.
    if (text.charCodeAt(N - 1) === NEWLINE) --N;
    if (text.charCodeAt(N - 1) === RETURN) --N;

    function token() {
      if (eof) return EOF;
      if (eol) return eol = false, EOL;

      // Unescape quotes.
      var i, j = I, c;
      if (text.charCodeAt(j) === QUOTE) {
        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);
        if ((i = I) >= N) eof = true;
        else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;
        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
        return text.slice(j + 1, i - 1).replace(/""/g, "\"");
      }

      // Find next delimiter or newline.
      while (I < N) {
        if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;
        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
        else if (c !== DELIMITER) continue;
        return text.slice(j, i);
      }

      // Return last token before EOF.
      return eof = true, text.slice(j, N);
    }

    while ((t = token()) !== EOF) {
      var row = [];
      while (t !== EOL && t !== EOF) row.push(t), t = token();
      if (f && (row = f(row, n++)) == null) continue;
      rows.push(row);
    }

    return rows;
  }

  function preformatBody(rows, columns) {
    return rows.map(function(row) {
      return columns.map(function(column) {
        return formatValue(row[column]);
      }).join(delimiter);
    });
  }

  function format(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
  }

  function formatBody(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return preformatBody(rows, columns).join("\n");
  }

  function formatRows(rows) {
    return rows.map(formatRow).join("\n");
  }

  function formatRow(row) {
    return row.map(formatValue).join(delimiter);
  }

  function formatValue(value) {
    return value == null ? ""
        : value instanceof Date ? formatDate(value)
        : reFormat.test(value += "") ? "\"" + value.replace(/"/g, "\"\"") + "\""
        : value;
  }

  return {
    parse: parse,
    parseRows: parseRows,
    format: format,
    formatBody: formatBody,
    formatRows: formatRows,
    formatRow: formatRow,
    formatValue: formatValue
  };
});


/***/ }),

/***/ "ezys":
/*!*********************************************!*\
  !*** ./node_modules/d3-polygon/src/hull.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _cross_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cross.js */ "MLOY");


function lexicographicOrder(a, b) {
  return a[0] - b[0] || a[1] - b[1];
}

// Computes the upper convex hull per the monotone chain algorithm.
// Assumes points.length >= 3, is sorted by x, unique in y.
// Returns an array of indices into points in left-to-right order.
function computeUpperHullIndexes(points) {
  var n = points.length,
      indexes = [0, 1],
      size = 2;

  for (var i = 2; i < n; ++i) {
    while (size > 1 && Object(_cross_js__WEBPACK_IMPORTED_MODULE_0__["default"])(points[indexes[size - 2]], points[indexes[size - 1]], points[i]) <= 0) --size;
    indexes[size++] = i;
  }

  return indexes.slice(0, size); // remove popped points
}

/* harmony default export */ __webpack_exports__["default"] = (function(points) {
  if ((n = points.length) < 3) return null;

  var i,
      n,
      sortedPoints = new Array(n),
      flippedPoints = new Array(n);

  for (i = 0; i < n; ++i) sortedPoints[i] = [+points[i][0], +points[i][1], i];
  sortedPoints.sort(lexicographicOrder);
  for (i = 0; i < n; ++i) flippedPoints[i] = [sortedPoints[i][0], -sortedPoints[i][1]];

  var upperIndexes = computeUpperHullIndexes(sortedPoints),
      lowerIndexes = computeUpperHullIndexes(flippedPoints);

  // Construct the hull polygon, removing possible duplicate endpoints.
  var skipLeft = lowerIndexes[0] === upperIndexes[0],
      skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1],
      hull = [];

  // Add upper hull in right-to-l order.
  // Then add lower hull in left-to-right order.
  for (i = upperIndexes.length - 1; i >= 0; --i) hull.push(points[sortedPoints[upperIndexes[i]][2]]);
  for (i = +skipLeft; i < lowerIndexes.length - skipRight; ++i) hull.push(points[sortedPoints[lowerIndexes[i]][2]]);

  return hull;
});


/***/ }),

/***/ "fjNz":
/*!*******************************************!*\
  !*** ./node_modules/d3-geo/src/bounds.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _adder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./adder.js */ "uCr6");
/* harmony import */ var _area_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./area.js */ "PSPu");
/* harmony import */ var _cartesian_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cartesian.js */ "YzSS");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./math.js */ "R0y8");
/* harmony import */ var _stream_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./stream.js */ "tepu");






var lambda0, phi0, lambda1, phi1, // bounds
    lambda2, // previous lambda-coordinate
    lambda00, phi00, // first point
    p0, // previous 3D point
    deltaSum = Object(_adder_js__WEBPACK_IMPORTED_MODULE_0__["default"])(),
    ranges,
    range;

var boundsStream = {
  point: boundsPoint,
  lineStart: boundsLineStart,
  lineEnd: boundsLineEnd,
  polygonStart: function() {
    boundsStream.point = boundsRingPoint;
    boundsStream.lineStart = boundsRingStart;
    boundsStream.lineEnd = boundsRingEnd;
    deltaSum.reset();
    _area_js__WEBPACK_IMPORTED_MODULE_1__["areaStream"].polygonStart();
  },
  polygonEnd: function() {
    _area_js__WEBPACK_IMPORTED_MODULE_1__["areaStream"].polygonEnd();
    boundsStream.point = boundsPoint;
    boundsStream.lineStart = boundsLineStart;
    boundsStream.lineEnd = boundsLineEnd;
    if (_area_js__WEBPACK_IMPORTED_MODULE_1__["areaRingSum"] < 0) lambda0 = -(lambda1 = 180), phi0 = -(phi1 = 90);
    else if (deltaSum > _math_js__WEBPACK_IMPORTED_MODULE_3__["epsilon"]) phi1 = 90;
    else if (deltaSum < -_math_js__WEBPACK_IMPORTED_MODULE_3__["epsilon"]) phi0 = -90;
    range[0] = lambda0, range[1] = lambda1;
  },
  sphere: function() {
    lambda0 = -(lambda1 = 180), phi0 = -(phi1 = 90);
  }
};

function boundsPoint(lambda, phi) {
  ranges.push(range = [lambda0 = lambda, lambda1 = lambda]);
  if (phi < phi0) phi0 = phi;
  if (phi > phi1) phi1 = phi;
}

function linePoint(lambda, phi) {
  var p = Object(_cartesian_js__WEBPACK_IMPORTED_MODULE_2__["cartesian"])([lambda * _math_js__WEBPACK_IMPORTED_MODULE_3__["radians"], phi * _math_js__WEBPACK_IMPORTED_MODULE_3__["radians"]]);
  if (p0) {
    var normal = Object(_cartesian_js__WEBPACK_IMPORTED_MODULE_2__["cartesianCross"])(p0, p),
        equatorial = [normal[1], -normal[0], 0],
        inflection = Object(_cartesian_js__WEBPACK_IMPORTED_MODULE_2__["cartesianCross"])(equatorial, normal);
    Object(_cartesian_js__WEBPACK_IMPORTED_MODULE_2__["cartesianNormalizeInPlace"])(inflection);
    inflection = Object(_cartesian_js__WEBPACK_IMPORTED_MODULE_2__["spherical"])(inflection);
    var delta = lambda - lambda2,
        sign = delta > 0 ? 1 : -1,
        lambdai = inflection[0] * _math_js__WEBPACK_IMPORTED_MODULE_3__["degrees"] * sign,
        phii,
        antimeridian = Object(_math_js__WEBPACK_IMPORTED_MODULE_3__["abs"])(delta) > 180;
    if (antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
      phii = inflection[1] * _math_js__WEBPACK_IMPORTED_MODULE_3__["degrees"];
      if (phii > phi1) phi1 = phii;
    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
      phii = -inflection[1] * _math_js__WEBPACK_IMPORTED_MODULE_3__["degrees"];
      if (phii < phi0) phi0 = phii;
    } else {
      if (phi < phi0) phi0 = phi;
      if (phi > phi1) phi1 = phi;
    }
    if (antimeridian) {
      if (lambda < lambda2) {
        if (angle(lambda0, lambda) > angle(lambda0, lambda1)) lambda1 = lambda;
      } else {
        if (angle(lambda, lambda1) > angle(lambda0, lambda1)) lambda0 = lambda;
      }
    } else {
      if (lambda1 >= lambda0) {
        if (lambda < lambda0) lambda0 = lambda;
        if (lambda > lambda1) lambda1 = lambda;
      } else {
        if (lambda > lambda2) {
          if (angle(lambda0, lambda) > angle(lambda0, lambda1)) lambda1 = lambda;
        } else {
          if (angle(lambda, lambda1) > angle(lambda0, lambda1)) lambda0 = lambda;
        }
      }
    }
  } else {
    ranges.push(range = [lambda0 = lambda, lambda1 = lambda]);
  }
  if (phi < phi0) phi0 = phi;
  if (phi > phi1) phi1 = phi;
  p0 = p, lambda2 = lambda;
}

function boundsLineStart() {
  boundsStream.point = linePoint;
}

function boundsLineEnd() {
  range[0] = lambda0, range[1] = lambda1;
  boundsStream.point = boundsPoint;
  p0 = null;
}

function boundsRingPoint(lambda, phi) {
  if (p0) {
    var delta = lambda - lambda2;
    deltaSum.add(Object(_math_js__WEBPACK_IMPORTED_MODULE_3__["abs"])(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
  } else {
    lambda00 = lambda, phi00 = phi;
  }
  _area_js__WEBPACK_IMPORTED_MODULE_1__["areaStream"].point(lambda, phi);
  linePoint(lambda, phi);
}

function boundsRingStart() {
  _area_js__WEBPACK_IMPORTED_MODULE_1__["areaStream"].lineStart();
}

function boundsRingEnd() {
  boundsRingPoint(lambda00, phi00);
  _area_js__WEBPACK_IMPORTED_MODULE_1__["areaStream"].lineEnd();
  if (Object(_math_js__WEBPACK_IMPORTED_MODULE_3__["abs"])(deltaSum) > _math_js__WEBPACK_IMPORTED_MODULE_3__["epsilon"]) lambda0 = -(lambda1 = 180);
  range[0] = lambda0, range[1] = lambda1;
  p0 = null;
}

// Finds the left-right distance between two longitudes.
// This is almost the same as (lambda1 - lambda0 + 360°) % 360°, except that we want
// the distance between ±180° to be 360°.
function angle(lambda0, lambda1) {
  return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;
}

function rangeCompare(a, b) {
  return a[0] - b[0];
}

function rangeContains(range, x) {
  return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
}

/* harmony default export */ __webpack_exports__["default"] = (function(feature) {
  var i, n, a, b, merged, deltaMax, delta;

  phi1 = lambda1 = -(lambda0 = phi0 = Infinity);
  ranges = [];
  Object(_stream_js__WEBPACK_IMPORTED_MODULE_4__["default"])(feature, boundsStream);

  // First, sort ranges by their minimum longitudes.
  if (n = ranges.length) {
    ranges.sort(rangeCompare);

    // Then, merge any ranges that overlap.
    for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {
      b = ranges[i];
      if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {
        if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
        if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
      } else {
        merged.push(a = b);
      }
    }

    // Finally, find the largest gap between the merged ranges.
    // The final bounding box will be the inverse of this gap.
    for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {
      b = merged[i];
      if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0 = b[0], lambda1 = a[1];
    }
  }

  ranges = range = null;

  return lambda0 === Infinity || phi0 === Infinity
      ? [[NaN, NaN], [NaN, NaN]]
      : [[lambda0, phi0], [lambda1, phi1]];
});


/***/ }),

/***/ "fnXD":
/*!***********************************************!*\
  !*** ./node_modules/d3-geo/src/pointEqual.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "R0y8");


/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  return Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["abs"])(a[0] - b[0]) < _math_js__WEBPACK_IMPORTED_MODULE_0__["epsilon"] && Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["abs"])(a[1] - b[1]) < _math_js__WEBPACK_IMPORTED_MODULE_0__["epsilon"];
});


/***/ }),

/***/ "gO8D":
/*!***********************************************!*\
  !*** ./node_modules/d3-quadtree/src/index.js ***!
  \***********************************************/
/*! exports provided: quadtree */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _quadtree_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./quadtree.js */ "z6FA");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "quadtree", function() { return _quadtree_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });




/***/ }),

/***/ "gbBL":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/categorical/Set2.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors.js */ "ZtE7");


/* harmony default export */ __webpack_exports__["default"] = (Object(_colors_js__WEBPACK_IMPORTED_MODULE_0__["default"])("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3"));


/***/ }),

/***/ "gy+j":
/*!*************************************************!*\
  !*** ./node_modules/d3-contour/src/contours.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "sRF9");
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./array */ "mcvr");
/* harmony import */ var _ascending__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ascending */ "tOsU");
/* harmony import */ var _area__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./area */ "xP+1");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./constant */ "DiG6");
/* harmony import */ var _contains__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./contains */ "UnGF");
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./noop */ "S2Xb");








var cases = [
  [],
  [[[1.0, 1.5], [0.5, 1.0]]],
  [[[1.5, 1.0], [1.0, 1.5]]],
  [[[1.5, 1.0], [0.5, 1.0]]],
  [[[1.0, 0.5], [1.5, 1.0]]],
  [[[1.0, 1.5], [0.5, 1.0]], [[1.0, 0.5], [1.5, 1.0]]],
  [[[1.0, 0.5], [1.0, 1.5]]],
  [[[1.0, 0.5], [0.5, 1.0]]],
  [[[0.5, 1.0], [1.0, 0.5]]],
  [[[1.0, 1.5], [1.0, 0.5]]],
  [[[0.5, 1.0], [1.0, 0.5]], [[1.5, 1.0], [1.0, 1.5]]],
  [[[1.5, 1.0], [1.0, 0.5]]],
  [[[0.5, 1.0], [1.5, 1.0]]],
  [[[1.0, 1.5], [1.5, 1.0]]],
  [[[0.5, 1.0], [1.0, 1.5]]],
  []
];

/* harmony default export */ __webpack_exports__["default"] = (function() {
  var dx = 1,
      dy = 1,
      threshold = d3_array__WEBPACK_IMPORTED_MODULE_0__["thresholdSturges"],
      smooth = smoothLinear;

  function contours(values) {
    var tz = threshold(values);

    // Convert number of thresholds into uniform thresholds.
    if (!Array.isArray(tz)) {
      var domain = Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["extent"])(values), start = domain[0], stop = domain[1];
      tz = Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["tickStep"])(start, stop, tz);
      tz = Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["range"])(Math.floor(start / tz) * tz, Math.floor(stop / tz) * tz, tz);
    } else {
      tz = tz.slice().sort(_ascending__WEBPACK_IMPORTED_MODULE_2__["default"]);
    }

    return tz.map(function(value) {
      return contour(values, value);
    });
  }

  // Accumulate, smooth contour rings, assign holes to exterior rings.
  // Based on https://github.com/mbostock/shapefile/blob/v0.6.2/shp/polygon.js
  function contour(values, value) {
    var polygons = [],
        holes = [];

    isorings(values, value, function(ring) {
      smooth(ring, values, value);
      if (Object(_area__WEBPACK_IMPORTED_MODULE_3__["default"])(ring) > 0) polygons.push([ring]);
      else holes.push(ring);
    });

    holes.forEach(function(hole) {
      for (var i = 0, n = polygons.length, polygon; i < n; ++i) {
        if (Object(_contains__WEBPACK_IMPORTED_MODULE_5__["default"])((polygon = polygons[i])[0], hole) !== -1) {
          polygon.push(hole);
          return;
        }
      }
    });

    return {
      type: "MultiPolygon",
      value: value,
      coordinates: polygons
    };
  }

  // Marching squares with isolines stitched into rings.
  // Based on https://github.com/topojson/topojson-client/blob/v3.0.0/src/stitch.js
  function isorings(values, value, callback) {
    var fragmentByStart = new Array,
        fragmentByEnd = new Array,
        x, y, t0, t1, t2, t3;

    // Special case for the first row (y = -1, t2 = t3 = 0).
    x = y = -1;
    t1 = values[0] >= value;
    cases[t1 << 1].forEach(stitch);
    while (++x < dx - 1) {
      t0 = t1, t1 = values[x + 1] >= value;
      cases[t0 | t1 << 1].forEach(stitch);
    }
    cases[t1 << 0].forEach(stitch);

    // General case for the intermediate rows.
    while (++y < dy - 1) {
      x = -1;
      t1 = values[y * dx + dx] >= value;
      t2 = values[y * dx] >= value;
      cases[t1 << 1 | t2 << 2].forEach(stitch);
      while (++x < dx - 1) {
        t0 = t1, t1 = values[y * dx + dx + x + 1] >= value;
        t3 = t2, t2 = values[y * dx + x + 1] >= value;
        cases[t0 | t1 << 1 | t2 << 2 | t3 << 3].forEach(stitch);
      }
      cases[t1 | t2 << 3].forEach(stitch);
    }

    // Special case for the last row (y = dy - 1, t0 = t1 = 0).
    x = -1;
    t2 = values[y * dx] >= value;
    cases[t2 << 2].forEach(stitch);
    while (++x < dx - 1) {
      t3 = t2, t2 = values[y * dx + x + 1] >= value;
      cases[t2 << 2 | t3 << 3].forEach(stitch);
    }
    cases[t2 << 3].forEach(stitch);

    function stitch(line) {
      var start = [line[0][0] + x, line[0][1] + y],
          end = [line[1][0] + x, line[1][1] + y],
          startIndex = index(start),
          endIndex = index(end),
          f, g;
      if (f = fragmentByEnd[startIndex]) {
        if (g = fragmentByStart[endIndex]) {
          delete fragmentByEnd[f.end];
          delete fragmentByStart[g.start];
          if (f === g) {
            f.ring.push(end);
            callback(f.ring);
          } else {
            fragmentByStart[f.start] = fragmentByEnd[g.end] = {start: f.start, end: g.end, ring: f.ring.concat(g.ring)};
          }
        } else {
          delete fragmentByEnd[f.end];
          f.ring.push(end);
          fragmentByEnd[f.end = endIndex] = f;
        }
      } else if (f = fragmentByStart[endIndex]) {
        if (g = fragmentByEnd[startIndex]) {
          delete fragmentByStart[f.start];
          delete fragmentByEnd[g.end];
          if (f === g) {
            f.ring.push(end);
            callback(f.ring);
          } else {
            fragmentByStart[g.start] = fragmentByEnd[f.end] = {start: g.start, end: f.end, ring: g.ring.concat(f.ring)};
          }
        } else {
          delete fragmentByStart[f.start];
          f.ring.unshift(start);
          fragmentByStart[f.start = startIndex] = f;
        }
      } else {
        fragmentByStart[startIndex] = fragmentByEnd[endIndex] = {start: startIndex, end: endIndex, ring: [start, end]};
      }
    }
  }

  function index(point) {
    return point[0] * 2 + point[1] * (dx + 1) * 4;
  }

  function smoothLinear(ring, values, value) {
    ring.forEach(function(point) {
      var x = point[0],
          y = point[1],
          xt = x | 0,
          yt = y | 0,
          v0,
          v1 = values[yt * dx + xt];
      if (x > 0 && x < dx && xt === x) {
        v0 = values[yt * dx + xt - 1];
        point[0] = x + (value - v0) / (v1 - v0) - 0.5;
      }
      if (y > 0 && y < dy && yt === y) {
        v0 = values[(yt - 1) * dx + xt];
        point[1] = y + (value - v0) / (v1 - v0) - 0.5;
      }
    });
  }

  contours.contour = contour;

  contours.size = function(_) {
    if (!arguments.length) return [dx, dy];
    var _0 = Math.ceil(_[0]), _1 = Math.ceil(_[1]);
    if (!(_0 > 0) || !(_1 > 0)) throw new Error("invalid size");
    return dx = _0, dy = _1, contours;
  };

  contours.thresholds = function(_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? Object(_constant__WEBPACK_IMPORTED_MODULE_4__["default"])(_array__WEBPACK_IMPORTED_MODULE_1__["slice"].call(_)) : Object(_constant__WEBPACK_IMPORTED_MODULE_4__["default"])(_), contours) : threshold;
  };

  contours.smooth = function(_) {
    return arguments.length ? (smooth = _ ? smoothLinear : _noop__WEBPACK_IMPORTED_MODULE_6__["default"], contours) : smooth === smoothLinear;
  };

  return contours;
});


/***/ }),

/***/ "h2xr":
/*!*******************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/categorical/Accent.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors.js */ "ZtE7");


/* harmony default export */ __webpack_exports__["default"] = (Object(_colors_js__WEBPACK_IMPORTED_MODULE_0__["default"])("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666"));


/***/ }),

/***/ "h8aP":
/*!**************************************************************!*\
  !*** ./node_modules/c3/node_modules/d3-scale/src/ordinal.js ***!
  \**************************************************************/
/*! exports provided: implicit, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "implicit", function() { return implicit; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ordinal; });
/* harmony import */ var d3_collection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-collection */ "bwSX");
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./array */ "d/QP");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./init */ "//NX");




var implicit = {name: "implicit"};

function ordinal() {
  var index = Object(d3_collection__WEBPACK_IMPORTED_MODULE_0__["map"])(),
      domain = [],
      range = [],
      unknown = implicit;

  function scale(d) {
    var key = d + "", i = index.get(key);
    if (!i) {
      if (unknown !== implicit) return unknown;
      index.set(key, i = domain.push(d));
    }
    return range[(i - 1) % range.length];
  }

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [], index = Object(d3_collection__WEBPACK_IMPORTED_MODULE_0__["map"])();
    var i = -1, n = _.length, d, key;
    while (++i < n) if (!index.has(key = (d = _[i]) + "")) index.set(key, domain.push(d));
    return scale;
  };

  scale.range = function(_) {
    return arguments.length ? (range = _array__WEBPACK_IMPORTED_MODULE_1__["slice"].call(_), scale) : range.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return ordinal(domain, range).unknown(unknown);
  };

  _init__WEBPACK_IMPORTED_MODULE_2__["initRange"].apply(scale, arguments);

  return scale;
}


/***/ }),

/***/ "h9r8":
/*!************************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/sequential-single/Blues.js ***!
  \************************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors.js */ "ZtE7");
/* harmony import */ var _ramp_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp.js */ "jQWc");



var scheme = new Array(3).concat(
  "deebf79ecae13182bd",
  "eff3ffbdd7e76baed62171b5",
  "eff3ffbdd7e76baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b"
).map(_colors_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp_js__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "hLuZ":
/*!***************************************************!*\
  !*** ./node_modules/d3-collection/src/entries.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(map) {
  var entries = [];
  for (var key in map) entries.push({key: key, value: map[key]});
  return entries;
});


/***/ }),

/***/ "hSnb":
/*!*************************************************!*\
  !*** ./node_modules/d3-random/src/irwinHall.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _defaultSource__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./defaultSource */ "0RZX");


/* harmony default export */ __webpack_exports__["default"] = ((function sourceRandomIrwinHall(source) {
  function randomIrwinHall(n) {
    return function() {
      for (var sum = 0, i = 0; i < n; ++i) sum += source();
      return sum;
    };
  }

  randomIrwinHall.source = sourceRandomIrwinHall;

  return randomIrwinHall;
})(_defaultSource__WEBPACK_IMPORTED_MODULE_0__["default"]));


/***/ }),

/***/ "hdEp":
/*!*************************************************************!*\
  !*** ./node_modules/c3/node_modules/d3-scale/src/linear.js ***!
  \*************************************************************/
/*! exports provided: linearish, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linearish", function() { return linearish; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return linear; });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "sRF9");
/* harmony import */ var _continuous__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./continuous */ "A24K");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./init */ "//NX");
/* harmony import */ var _tickFormat__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tickFormat */ "zCPI");





function linearish(scale) {
  var domain = scale.domain;

  scale.ticks = function(count) {
    var d = domain();
    return Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["ticks"])(d[0], d[d.length - 1], count == null ? 10 : count);
  };

  scale.tickFormat = function(count, specifier) {
    var d = domain();
    return Object(_tickFormat__WEBPACK_IMPORTED_MODULE_3__["default"])(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
  };

  scale.nice = function(count) {
    if (count == null) count = 10;

    var d = domain(),
        i0 = 0,
        i1 = d.length - 1,
        start = d[i0],
        stop = d[i1],
        step;

    if (stop < start) {
      step = start, start = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }

    step = Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["tickIncrement"])(start, stop, count);

    if (step > 0) {
      start = Math.floor(start / step) * step;
      stop = Math.ceil(stop / step) * step;
      step = Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["tickIncrement"])(start, stop, count);
    } else if (step < 0) {
      start = Math.ceil(start * step) / step;
      stop = Math.floor(stop * step) / step;
      step = Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["tickIncrement"])(start, stop, count);
    }

    if (step > 0) {
      d[i0] = Math.floor(start / step) * step;
      d[i1] = Math.ceil(stop / step) * step;
      domain(d);
    } else if (step < 0) {
      d[i0] = Math.ceil(start * step) / step;
      d[i1] = Math.floor(stop * step) / step;
      domain(d);
    }

    return scale;
  };

  return scale;
}

function linear() {
  var scale = Object(_continuous__WEBPACK_IMPORTED_MODULE_1__["default"])(_continuous__WEBPACK_IMPORTED_MODULE_1__["identity"], _continuous__WEBPACK_IMPORTED_MODULE_1__["identity"]);

  scale.copy = function() {
    return Object(_continuous__WEBPACK_IMPORTED_MODULE_1__["copy"])(scale, linear());
  };

  _init__WEBPACK_IMPORTED_MODULE_2__["initRange"].apply(scale, arguments);

  return linearish(scale);
}


/***/ }),

/***/ "hjfa":
/*!***********************************************!*\
  !*** ./node_modules/d3-zoom/src/transform.js ***!
  \***********************************************/
/*! exports provided: Transform, identity, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Transform", function() { return Transform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return transform; });
function Transform(k, x, y) {
  this.k = k;
  this.x = x;
  this.y = y;
}

Transform.prototype = {
  constructor: Transform,
  scale: function(k) {
    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
  },
  translate: function(x, y) {
    return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
  },
  apply: function(point) {
    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
  },
  applyX: function(x) {
    return x * this.k + this.x;
  },
  applyY: function(y) {
    return y * this.k + this.y;
  },
  invert: function(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function(x) {
    return (x - this.x) / this.k;
  },
  invertY: function(y) {
    return (y - this.y) / this.k;
  },
  rescaleX: function(x) {
    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
  },
  rescaleY: function(y) {
    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};

var identity = new Transform(1, 0, 0);

transform.prototype = Transform.prototype;

function transform(node) {
  while (!node.__zoom) if (!(node = node.parentNode)) return identity;
  return node.__zoom;
}


/***/ }),

/***/ "hkWm":
/*!******************************************!*\
  !*** ./node_modules/d3-zoom/src/zoom.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-dispatch */ "30U6");
/* harmony import */ var d3_drag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-drag */ "q+nN");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-interpolate */ "pD2Y");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-selection */ "/TIM");
/* harmony import */ var d3_transition__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-transition */ "sQjb");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./constant.js */ "lExN");
/* harmony import */ var _event_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./event.js */ "lhfN");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./transform.js */ "hjfa");
/* harmony import */ var _noevent_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./noevent.js */ "OSsQ");










// Ignore right-click, since that should open the context menu.
function defaultFilter() {
  return !d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].ctrlKey && !d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].button;
}

function defaultExtent() {
  var e = this;
  if (e instanceof SVGElement) {
    e = e.ownerSVGElement || e;
    if (e.hasAttribute("viewBox")) {
      e = e.viewBox.baseVal;
      return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
    }
    return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
  }
  return [[0, 0], [e.clientWidth, e.clientHeight]];
}

function defaultTransform() {
  return this.__zoom || _transform_js__WEBPACK_IMPORTED_MODULE_7__["identity"];
}

function defaultWheelDelta() {
  return -d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].deltaY * (d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].deltaMode === 1 ? 0.05 : d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].deltaMode ? 1 : 0.002);
}

function defaultTouchable() {
  return navigator.maxTouchPoints || ("ontouchstart" in this);
}

function defaultConstrain(transform, extent, translateExtent) {
  var dx0 = transform.invertX(extent[0][0]) - translateExtent[0][0],
      dx1 = transform.invertX(extent[1][0]) - translateExtent[1][0],
      dy0 = transform.invertY(extent[0][1]) - translateExtent[0][1],
      dy1 = transform.invertY(extent[1][1]) - translateExtent[1][1];
  return transform.translate(
    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
  );
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  var filter = defaultFilter,
      extent = defaultExtent,
      constrain = defaultConstrain,
      wheelDelta = defaultWheelDelta,
      touchable = defaultTouchable,
      scaleExtent = [0, Infinity],
      translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]],
      duration = 250,
      interpolate = d3_interpolate__WEBPACK_IMPORTED_MODULE_2__["interpolateZoom"],
      listeners = Object(d3_dispatch__WEBPACK_IMPORTED_MODULE_0__["dispatch"])("start", "zoom", "end"),
      touchstarting,
      touchending,
      touchDelay = 500,
      wheelDelay = 150,
      clickDistance2 = 0;

  function zoom(selection) {
    selection
        .property("__zoom", defaultTransform)
        .on("wheel.zoom", wheeled)
        .on("mousedown.zoom", mousedowned)
        .on("dblclick.zoom", dblclicked)
      .filter(touchable)
        .on("touchstart.zoom", touchstarted)
        .on("touchmove.zoom", touchmoved)
        .on("touchend.zoom touchcancel.zoom", touchended)
        .style("touch-action", "none")
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  zoom.transform = function(collection, transform, point) {
    var selection = collection.selection ? collection.selection() : collection;
    selection.property("__zoom", defaultTransform);
    if (collection !== selection) {
      schedule(collection, transform, point);
    } else {
      selection.interrupt().each(function() {
        gesture(this, arguments)
            .start()
            .zoom(null, typeof transform === "function" ? transform.apply(this, arguments) : transform)
            .end();
      });
    }
  };

  zoom.scaleBy = function(selection, k, p) {
    zoom.scaleTo(selection, function() {
      var k0 = this.__zoom.k,
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return k0 * k1;
    }, p);
  };

  zoom.scaleTo = function(selection, k, p) {
    zoom.transform(selection, function() {
      var e = extent.apply(this, arguments),
          t0 = this.__zoom,
          p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p,
          p1 = t0.invert(p0),
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
    }, p);
  };

  zoom.translateBy = function(selection, x, y) {
    zoom.transform(selection, function() {
      return constrain(this.__zoom.translate(
        typeof x === "function" ? x.apply(this, arguments) : x,
        typeof y === "function" ? y.apply(this, arguments) : y
      ), extent.apply(this, arguments), translateExtent);
    });
  };

  zoom.translateTo = function(selection, x, y, p) {
    zoom.transform(selection, function() {
      var e = extent.apply(this, arguments),
          t = this.__zoom,
          p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p;
      return constrain(_transform_js__WEBPACK_IMPORTED_MODULE_7__["identity"].translate(p0[0], p0[1]).scale(t.k).translate(
        typeof x === "function" ? -x.apply(this, arguments) : -x,
        typeof y === "function" ? -y.apply(this, arguments) : -y
      ), e, translateExtent);
    }, p);
  };

  function scale(transform, k) {
    k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
    return k === transform.k ? transform : new _transform_js__WEBPACK_IMPORTED_MODULE_7__["Transform"](k, transform.x, transform.y);
  }

  function translate(transform, p0, p1) {
    var x = p0[0] - p1[0] * transform.k, y = p0[1] - p1[1] * transform.k;
    return x === transform.x && y === transform.y ? transform : new _transform_js__WEBPACK_IMPORTED_MODULE_7__["Transform"](transform.k, x, y);
  }

  function centroid(extent) {
    return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];
  }

  function schedule(transition, transform, point) {
    transition
        .on("start.zoom", function() { gesture(this, arguments).start(); })
        .on("interrupt.zoom end.zoom", function() { gesture(this, arguments).end(); })
        .tween("zoom", function() {
          var that = this,
              args = arguments,
              g = gesture(that, args),
              e = extent.apply(that, args),
              p = point == null ? centroid(e) : typeof point === "function" ? point.apply(that, args) : point,
              w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),
              a = that.__zoom,
              b = typeof transform === "function" ? transform.apply(that, args) : transform,
              i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
          return function(t) {
            if (t === 1) t = b; // Avoid rounding error on end.
            else { var l = i(t), k = w / l[2]; t = new _transform_js__WEBPACK_IMPORTED_MODULE_7__["Transform"](k, p[0] - l[0] * k, p[1] - l[1] * k); }
            g.zoom(null, t);
          };
        });
  }

  function gesture(that, args, clean) {
    return (!clean && that.__zooming) || new Gesture(that, args);
  }

  function Gesture(that, args) {
    this.that = that;
    this.args = args;
    this.active = 0;
    this.extent = extent.apply(that, args);
    this.taps = 0;
  }

  Gesture.prototype = {
    start: function() {
      if (++this.active === 1) {
        this.that.__zooming = this;
        this.emit("start");
      }
      return this;
    },
    zoom: function(key, transform) {
      if (this.mouse && key !== "mouse") this.mouse[1] = transform.invert(this.mouse[0]);
      if (this.touch0 && key !== "touch") this.touch0[1] = transform.invert(this.touch0[0]);
      if (this.touch1 && key !== "touch") this.touch1[1] = transform.invert(this.touch1[0]);
      this.that.__zoom = transform;
      this.emit("zoom");
      return this;
    },
    end: function() {
      if (--this.active === 0) {
        delete this.that.__zooming;
        this.emit("end");
      }
      return this;
    },
    emit: function(type) {
      Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["customEvent"])(new _event_js__WEBPACK_IMPORTED_MODULE_6__["default"](zoom, type, this.that.__zoom), listeners.apply, listeners, [type, this.that, this.args]);
    }
  };

  function wheeled() {
    if (!filter.apply(this, arguments)) return;
    var g = gesture(this, arguments),
        t = this.__zoom,
        k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))),
        p = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["mouse"])(this);

    // If the mouse is in the same location as before, reuse it.
    // If there were recent wheel events, reset the wheel idle timeout.
    if (g.wheel) {
      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
        g.mouse[1] = t.invert(g.mouse[0] = p);
      }
      clearTimeout(g.wheel);
    }

    // If this wheel event won’t trigger a transform change, ignore it.
    else if (t.k === k) return;

    // Otherwise, capture the mouse point and location at the start.
    else {
      g.mouse = [p, t.invert(p)];
      Object(d3_transition__WEBPACK_IMPORTED_MODULE_4__["interrupt"])(this);
      g.start();
    }

    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_8__["default"])();
    g.wheel = setTimeout(wheelidled, wheelDelay);
    g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));

    function wheelidled() {
      g.wheel = null;
      g.end();
    }
  }

  function mousedowned() {
    if (touchending || !filter.apply(this, arguments)) return;
    var g = gesture(this, arguments, true),
        v = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["select"])(d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true),
        p = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["mouse"])(this),
        x0 = d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].clientX,
        y0 = d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].clientY;

    Object(d3_drag__WEBPACK_IMPORTED_MODULE_1__["dragDisable"])(d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].view);
    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_8__["nopropagation"])();
    g.mouse = [p, this.__zoom.invert(p)];
    Object(d3_transition__WEBPACK_IMPORTED_MODULE_4__["interrupt"])(this);
    g.start();

    function mousemoved() {
      Object(_noevent_js__WEBPACK_IMPORTED_MODULE_8__["default"])();
      if (!g.moved) {
        var dx = d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].clientX - x0, dy = d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].clientY - y0;
        g.moved = dx * dx + dy * dy > clickDistance2;
      }
      g.zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["mouse"])(g.that), g.mouse[1]), g.extent, translateExtent));
    }

    function mouseupped() {
      v.on("mousemove.zoom mouseup.zoom", null);
      Object(d3_drag__WEBPACK_IMPORTED_MODULE_1__["dragEnable"])(d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].view, g.moved);
      Object(_noevent_js__WEBPACK_IMPORTED_MODULE_8__["default"])();
      g.end();
    }
  }

  function dblclicked() {
    if (!filter.apply(this, arguments)) return;
    var t0 = this.__zoom,
        p0 = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["mouse"])(this),
        p1 = t0.invert(p0),
        k1 = t0.k * (d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].shiftKey ? 0.5 : 2),
        t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, arguments), translateExtent);

    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_8__["default"])();
    if (duration > 0) Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["select"])(this).transition().duration(duration).call(schedule, t1, p0);
    else Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["select"])(this).call(zoom.transform, t1);
  }

  function touchstarted() {
    if (!filter.apply(this, arguments)) return;
    var touches = d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].touches,
        n = touches.length,
        g = gesture(this, arguments, d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].changedTouches.length === n),
        started, i, t, p;

    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_8__["nopropagation"])();
    for (i = 0; i < n; ++i) {
      t = touches[i], p = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["touch"])(this, touches, t.identifier);
      p = [p, this.__zoom.invert(p), t.identifier];
      if (!g.touch0) g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;
      else if (!g.touch1 && g.touch0[2] !== p[2]) g.touch1 = p, g.taps = 0;
    }

    if (touchstarting) touchstarting = clearTimeout(touchstarting);

    if (started) {
      if (g.taps < 2) touchstarting = setTimeout(function() { touchstarting = null; }, touchDelay);
      Object(d3_transition__WEBPACK_IMPORTED_MODULE_4__["interrupt"])(this);
      g.start();
    }
  }

  function touchmoved() {
    if (!this.__zooming) return;
    var g = gesture(this, arguments),
        touches = d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].changedTouches,
        n = touches.length, i, t, p, l;

    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_8__["default"])();
    if (touchstarting) touchstarting = clearTimeout(touchstarting);
    g.taps = 0;
    for (i = 0; i < n; ++i) {
      t = touches[i], p = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["touch"])(this, touches, t.identifier);
      if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;
      else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
    }
    t = g.that.__zoom;
    if (g.touch1) {
      var p0 = g.touch0[0], l0 = g.touch0[1],
          p1 = g.touch1[0], l1 = g.touch1[1],
          dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,
          dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
      t = scale(t, Math.sqrt(dp / dl));
      p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
    }
    else if (g.touch0) p = g.touch0[0], l = g.touch0[1];
    else return;
    g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
  }

  function touchended() {
    if (!this.__zooming) return;
    var g = gesture(this, arguments),
        touches = d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].changedTouches,
        n = touches.length, i, t;

    Object(_noevent_js__WEBPACK_IMPORTED_MODULE_8__["nopropagation"])();
    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() { touchending = null; }, touchDelay);
    for (i = 0; i < n; ++i) {
      t = touches[i];
      if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;
      else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
    }
    if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
    if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);
    else {
      g.end();
      // If this was a dbltap, reroute to the (optional) dblclick.zoom handler.
      if (g.taps === 2) {
        var p = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["select"])(this).on("dblclick.zoom");
        if (p) p.apply(this, arguments);
      }
    }
  }

  zoom.wheelDelta = function(_) {
    return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_5__["default"])(+_), zoom) : wheelDelta;
  };

  zoom.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_5__["default"])(!!_), zoom) : filter;
  };

  zoom.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_5__["default"])(!!_), zoom) : touchable;
  };

  zoom.extent = function(_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_5__["default"])([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
  };

  zoom.scaleExtent = function(_) {
    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
  };

  zoom.translateExtent = function(_) {
    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  };

  zoom.constrain = function(_) {
    return arguments.length ? (constrain = _, zoom) : constrain;
  };

  zoom.duration = function(_) {
    return arguments.length ? (duration = +_, zoom) : duration;
  };

  zoom.interpolate = function(_) {
    return arguments.length ? (interpolate = _, zoom) : interpolate;
  };

  zoom.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom : value;
  };

  zoom.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
  };

  return zoom;
});


/***/ }),

/***/ "iBRH":
/*!******************************************!*\
  !*** ./node_modules/d3-axis/src/axis.js ***!
  \******************************************/
/*! exports provided: axisTop, axisRight, axisBottom, axisLeft */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "axisTop", function() { return axisTop; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "axisRight", function() { return axisRight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "axisBottom", function() { return axisBottom; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "axisLeft", function() { return axisLeft; });
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array */ "+s1I");
/* harmony import */ var _identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./identity */ "kF1t");



var top = 1,
    right = 2,
    bottom = 3,
    left = 4,
    epsilon = 1e-6;

function translateX(x) {
  return "translate(" + (x + 0.5) + ",0)";
}

function translateY(y) {
  return "translate(0," + (y + 0.5) + ")";
}

function number(scale) {
  return function(d) {
    return +scale(d);
  };
}

function center(scale) {
  var offset = Math.max(0, scale.bandwidth() - 1) / 2; // Adjust for 0.5px offset.
  if (scale.round()) offset = Math.round(offset);
  return function(d) {
    return +scale(d) + offset;
  };
}

function entering() {
  return !this.__axis;
}

function axis(orient, scale) {
  var tickArguments = [],
      tickValues = null,
      tickFormat = null,
      tickSizeInner = 6,
      tickSizeOuter = 6,
      tickPadding = 3,
      k = orient === top || orient === left ? -1 : 1,
      x = orient === left || orient === right ? "x" : "y",
      transform = orient === top || orient === bottom ? translateX : translateY;

  function axis(context) {
    var values = tickValues == null ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain()) : tickValues,
        format = tickFormat == null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : _identity__WEBPACK_IMPORTED_MODULE_1__["default"]) : tickFormat,
        spacing = Math.max(tickSizeInner, 0) + tickPadding,
        range = scale.range(),
        range0 = +range[0] + 0.5,
        range1 = +range[range.length - 1] + 0.5,
        position = (scale.bandwidth ? center : number)(scale.copy()),
        selection = context.selection ? context.selection() : context,
        path = selection.selectAll(".domain").data([null]),
        tick = selection.selectAll(".tick").data(values, scale).order(),
        tickExit = tick.exit(),
        tickEnter = tick.enter().append("g").attr("class", "tick"),
        line = tick.select("line"),
        text = tick.select("text");

    path = path.merge(path.enter().insert("path", ".tick")
        .attr("class", "domain")
        .attr("stroke", "currentColor"));

    tick = tick.merge(tickEnter);

    line = line.merge(tickEnter.append("line")
        .attr("stroke", "currentColor")
        .attr(x + "2", k * tickSizeInner));

    text = text.merge(tickEnter.append("text")
        .attr("fill", "currentColor")
        .attr(x, k * spacing)
        .attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));

    if (context !== selection) {
      path = path.transition(context);
      tick = tick.transition(context);
      line = line.transition(context);
      text = text.transition(context);

      tickExit = tickExit.transition(context)
          .attr("opacity", epsilon)
          .attr("transform", function(d) { return isFinite(d = position(d)) ? transform(d) : this.getAttribute("transform"); });

      tickEnter
          .attr("opacity", epsilon)
          .attr("transform", function(d) { var p = this.parentNode.__axis; return transform(p && isFinite(p = p(d)) ? p : position(d)); });
    }

    tickExit.remove();

    path
        .attr("d", orient === left || orient == right
            ? (tickSizeOuter ? "M" + k * tickSizeOuter + "," + range0 + "H0.5V" + range1 + "H" + k * tickSizeOuter : "M0.5," + range0 + "V" + range1)
            : (tickSizeOuter ? "M" + range0 + "," + k * tickSizeOuter + "V0.5H" + range1 + "V" + k * tickSizeOuter : "M" + range0 + ",0.5H" + range1));

    tick
        .attr("opacity", 1)
        .attr("transform", function(d) { return transform(position(d)); });

    line
        .attr(x + "2", k * tickSizeInner);

    text
        .attr(x, k * spacing)
        .text(format);

    selection.filter(entering)
        .attr("fill", "none")
        .attr("font-size", 10)
        .attr("font-family", "sans-serif")
        .attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");

    selection
        .each(function() { this.__axis = position; });
  }

  axis.scale = function(_) {
    return arguments.length ? (scale = _, axis) : scale;
  };

  axis.ticks = function() {
    return tickArguments = _array__WEBPACK_IMPORTED_MODULE_0__["slice"].call(arguments), axis;
  };

  axis.tickArguments = function(_) {
    return arguments.length ? (tickArguments = _ == null ? [] : _array__WEBPACK_IMPORTED_MODULE_0__["slice"].call(_), axis) : tickArguments.slice();
  };

  axis.tickValues = function(_) {
    return arguments.length ? (tickValues = _ == null ? null : _array__WEBPACK_IMPORTED_MODULE_0__["slice"].call(_), axis) : tickValues && tickValues.slice();
  };

  axis.tickFormat = function(_) {
    return arguments.length ? (tickFormat = _, axis) : tickFormat;
  };

  axis.tickSize = function(_) {
    return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis) : tickSizeInner;
  };

  axis.tickSizeInner = function(_) {
    return arguments.length ? (tickSizeInner = +_, axis) : tickSizeInner;
  };

  axis.tickSizeOuter = function(_) {
    return arguments.length ? (tickSizeOuter = +_, axis) : tickSizeOuter;
  };

  axis.tickPadding = function(_) {
    return arguments.length ? (tickPadding = +_, axis) : tickPadding;
  };

  return axis;
}

function axisTop(scale) {
  return axis(top, scale);
}

function axisRight(scale) {
  return axis(right, scale);
}

function axisBottom(scale) {
  return axis(bottom, scale);
}

function axisLeft(scale) {
  return axis(left, scale);
}


/***/ }),

/***/ "iQ9W":
/*!**********************************************!*\
  !*** ./node_modules/d3-force/src/collide.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant */ "nXVj");
/* harmony import */ var _jiggle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./jiggle */ "QupR");
/* harmony import */ var d3_quadtree__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-quadtree */ "gO8D");




function x(d) {
  return d.x + d.vx;
}

function y(d) {
  return d.y + d.vy;
}

/* harmony default export */ __webpack_exports__["default"] = (function(radius) {
  var nodes,
      radii,
      strength = 1,
      iterations = 1;

  if (typeof radius !== "function") radius = Object(_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(radius == null ? 1 : +radius);

  function force() {
    var i, n = nodes.length,
        tree,
        node,
        xi,
        yi,
        ri,
        ri2;

    for (var k = 0; k < iterations; ++k) {
      tree = Object(d3_quadtree__WEBPACK_IMPORTED_MODULE_2__["quadtree"])(nodes, x, y).visitAfter(prepare);
      for (i = 0; i < n; ++i) {
        node = nodes[i];
        ri = radii[node.index], ri2 = ri * ri;
        xi = node.x + node.vx;
        yi = node.y + node.vy;
        tree.visit(apply);
      }
    }

    function apply(quad, x0, y0, x1, y1) {
      var data = quad.data, rj = quad.r, r = ri + rj;
      if (data) {
        if (data.index > node.index) {
          var x = xi - data.x - data.vx,
              y = yi - data.y - data.vy,
              l = x * x + y * y;
          if (l < r * r) {
            if (x === 0) x = Object(_jiggle__WEBPACK_IMPORTED_MODULE_1__["default"])(), l += x * x;
            if (y === 0) y = Object(_jiggle__WEBPACK_IMPORTED_MODULE_1__["default"])(), l += y * y;
            l = (r - (l = Math.sqrt(l))) / l * strength;
            node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj));
            node.vy += (y *= l) * r;
            data.vx -= x * (r = 1 - r);
            data.vy -= y * r;
          }
        }
        return;
      }
      return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;
    }
  }

  function prepare(quad) {
    if (quad.data) return quad.r = radii[quad.data.index];
    for (var i = quad.r = 0; i < 4; ++i) {
      if (quad[i] && quad[i].r > quad.r) {
        quad.r = quad[i].r;
      }
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length, node;
    radii = new Array(n);
    for (i = 0; i < n; ++i) node = nodes[i], radii[node.index] = +radius(node, i, nodes);
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.iterations = function(_) {
    return arguments.length ? (iterations = +_, force) : iterations;
  };

  force.strength = function(_) {
    return arguments.length ? (strength = +_, force) : strength;
  };

  force.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), initialize(), force) : radius;
  };

  return force;
});


/***/ }),

/***/ "iQWy":
/*!******************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/albers.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _conicEqualArea_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./conicEqualArea.js */ "nVu6");


/* harmony default export */ __webpack_exports__["default"] = (function() {
  return Object(_conicEqualArea_js__WEBPACK_IMPORTED_MODULE_0__["default"])()
      .parallels([29.5, 45.5])
      .scale(1070)
      .translate([480, 250])
      .rotate([96, 0])
      .center([-0.6, 38.7]);
});


/***/ }),

/***/ "ikcO":
/*!*************************************************!*\
  !*** ./node_modules/d3-geo/src/path/context.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PathContext; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "R0y8");
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../noop.js */ "mPOO");



function PathContext(context) {
  this._context = context;
}

PathContext.prototype = {
  _radius: 4.5,
  pointRadius: function(_) {
    return this._radius = _, this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0) this._context.closePath();
    this._point = NaN;
  },
  point: function(x, y) {
    switch (this._point) {
      case 0: {
        this._context.moveTo(x, y);
        this._point = 1;
        break;
      }
      case 1: {
        this._context.lineTo(x, y);
        break;
      }
      default: {
        this._context.moveTo(x + this._radius, y);
        this._context.arc(x, y, this._radius, 0, _math_js__WEBPACK_IMPORTED_MODULE_0__["tau"]);
        break;
      }
    }
  },
  result: _noop_js__WEBPACK_IMPORTED_MODULE_1__["default"]
};


/***/ }),

/***/ "jQWc":
/*!*****************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/ramp.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-interpolate */ "pD2Y");


/* harmony default export */ __webpack_exports__["default"] = (function(scheme) {
  return Object(d3_interpolate__WEBPACK_IMPORTED_MODULE_0__["interpolateRgbBasis"])(scheme[scheme.length - 1]);
});


/***/ }),

/***/ "jTaA":
/*!************************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/sequential-multi/YlOrRd.js ***!
  \************************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors.js */ "ZtE7");
/* harmony import */ var _ramp_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp.js */ "jQWc");



var scheme = new Array(3).concat(
  "ffeda0feb24cf03b20",
  "ffffb2fecc5cfd8d3ce31a1c",
  "ffffb2fecc5cfd8d3cf03b20bd0026",
  "ffffb2fed976feb24cfd8d3cf03b20bd0026",
  "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026",
  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026",
  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026"
).map(_colors_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp_js__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "kF1t":
/*!**********************************************!*\
  !*** ./node_modules/d3-axis/src/identity.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return x;
});


/***/ }),

/***/ "kbsf":
/*!************************************************************************!*\
  !*** ./node_modules/c3/node_modules/d3/node_modules/d3-dsv/src/csv.js ***!
  \************************************************************************/
/*! exports provided: csvParse, csvParseRows, csvFormat, csvFormatBody, csvFormatRows, csvFormatRow, csvFormatValue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "csvParse", function() { return csvParse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "csvParseRows", function() { return csvParseRows; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "csvFormat", function() { return csvFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "csvFormatBody", function() { return csvFormatBody; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "csvFormatRows", function() { return csvFormatRows; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "csvFormatRow", function() { return csvFormatRow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "csvFormatValue", function() { return csvFormatValue; });
/* harmony import */ var _dsv_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dsv.js */ "eha6");


var csv = Object(_dsv_js__WEBPACK_IMPORTED_MODULE_0__["default"])(",");

var csvParse = csv.parse;
var csvParseRows = csv.parseRows;
var csvFormat = csv.format;
var csvFormatBody = csv.formatBody;
var csvFormatRows = csv.formatRows;
var csvFormatRow = csv.formatRow;
var csvFormatValue = csv.formatValue;


/***/ }),

/***/ "kgU0":
/*!*******************************************!*\
  !*** ./node_modules/d3-fetch/src/blob.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function responseBlob(response) {
  if (!response.ok) throw new Error(response.status + " " + response.statusText);
  return response.blob();
}

/* harmony default export */ __webpack_exports__["default"] = (function(input, init) {
  return fetch(input, init).then(responseBlob);
});


/***/ }),

/***/ "kvQR":
/*!*************************************************************!*\
  !*** ./node_modules/c3/node_modules/d3-scale/src/symlog.js ***!
  \*************************************************************/
/*! exports provided: symlogish, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "symlogish", function() { return symlogish; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return symlog; });
/* harmony import */ var _linear__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./linear */ "hdEp");
/* harmony import */ var _continuous__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./continuous */ "A24K");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./init */ "//NX");




function transformSymlog(c) {
  return function(x) {
    return Math.sign(x) * Math.log1p(Math.abs(x / c));
  };
}

function transformSymexp(c) {
  return function(x) {
    return Math.sign(x) * Math.expm1(Math.abs(x)) * c;
  };
}

function symlogish(transform) {
  var c = 1, scale = transform(transformSymlog(c), transformSymexp(c));

  scale.constant = function(_) {
    return arguments.length ? transform(transformSymlog(c = +_), transformSymexp(c)) : c;
  };

  return Object(_linear__WEBPACK_IMPORTED_MODULE_0__["linearish"])(scale);
}

function symlog() {
  var scale = symlogish(Object(_continuous__WEBPACK_IMPORTED_MODULE_1__["transformer"])());

  scale.copy = function() {
    return Object(_continuous__WEBPACK_IMPORTED_MODULE_1__["copy"])(scale, symlog()).constant(scale.constant());
  };

  return _init__WEBPACK_IMPORTED_MODULE_2__["initRange"].apply(scale, arguments);
}


/***/ }),

/***/ "l9nW":
/*!*************************************************!*\
  !*** ./node_modules/d3-voronoi/src/constant.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return function() {
    return x;
  };
});


/***/ }),

/***/ "lExN":
/*!**********************************************!*\
  !*** ./node_modules/d3-zoom/src/constant.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return function() {
    return x;
  };
});


/***/ }),

/***/ "lhfN":
/*!*******************************************!*\
  !*** ./node_modules/d3-zoom/src/event.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ZoomEvent; });
function ZoomEvent(target, type, transform) {
  this.target = target;
  this.type = type;
  this.transform = transform;
}


/***/ }),

/***/ "m7tx":
/*!*******************************************!*\
  !*** ./node_modules/d3-quadtree/src/x.js ***!
  \*******************************************/
/*! exports provided: defaultX, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultX", function() { return defaultX; });
function defaultX(d) {
  return d[0];
}

/* harmony default export */ __webpack_exports__["default"] = (function(_) {
  return arguments.length ? (this._x = _, this) : this._x;
});


/***/ }),

/***/ "mGj8":
/*!**************************************************************!*\
  !*** ./node_modules/c3/node_modules/d3-array/src/shuffle.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(array, i0, i1) {
  var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0),
      t,
      i;

  while (m) {
    i = Math.random() * m-- | 0;
    t = array[m + i0];
    array[m + i0] = array[i + i0];
    array[i + i0] = t;
  }

  return array;
});


/***/ }),

/***/ "mJZf":
/*!*******************************************!*\
  !*** ./node_modules/d3-chord/src/math.js ***!
  \*******************************************/
/*! exports provided: cos, sin, pi, halfPi, tau, max */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cos", function() { return cos; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sin", function() { return sin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pi", function() { return pi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "halfPi", function() { return halfPi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tau", function() { return tau; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "max", function() { return max; });
var cos = Math.cos;
var sin = Math.sin;
var pi = Math.PI;
var halfPi = pi / 2;
var tau = pi * 2;
var max = Math.max;


/***/ }),

/***/ "mLZp":
/*!**********************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/sequential-multi/BuGn.js ***!
  \**********************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors.js */ "ZtE7");
/* harmony import */ var _ramp_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp.js */ "jQWc");



var scheme = new Array(3).concat(
  "e5f5f999d8c92ca25f",
  "edf8fbb2e2e266c2a4238b45",
  "edf8fbb2e2e266c2a42ca25f006d2c",
  "edf8fbccece699d8c966c2a42ca25f006d2c",
  "edf8fbccece699d8c966c2a441ae76238b45005824",
  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824",
  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b"
).map(_colors_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp_js__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "mLep":
/*!************************************************!*\
  !*** ./node_modules/d3-geo/src/path/string.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PathString; });
function PathString() {
  this._string = [];
}

PathString.prototype = {
  _radius: 4.5,
  _circle: circle(4.5),
  pointRadius: function(_) {
    if ((_ = +_) !== this._radius) this._radius = _, this._circle = null;
    return this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0) this._string.push("Z");
    this._point = NaN;
  },
  point: function(x, y) {
    switch (this._point) {
      case 0: {
        this._string.push("M", x, ",", y);
        this._point = 1;
        break;
      }
      case 1: {
        this._string.push("L", x, ",", y);
        break;
      }
      default: {
        if (this._circle == null) this._circle = circle(this._radius);
        this._string.push("M", x, ",", y, this._circle);
        break;
      }
    }
  },
  result: function() {
    if (this._string.length) {
      var result = this._string.join("");
      this._string = [];
      return result;
    } else {
      return null;
    }
  }
};

function circle(radius) {
  return "m0," + radius
      + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius
      + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius
      + "z";
}


/***/ }),

/***/ "mPOO":
/*!*****************************************!*\
  !*** ./node_modules/d3-geo/src/noop.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return noop; });
function noop() {}


/***/ }),

/***/ "mZMl":
/*!************************************************!*\
  !*** ./node_modules/d3-collection/src/nest.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./map */ "+RkR");


/* harmony default export */ __webpack_exports__["default"] = (function() {
  var keys = [],
      sortKeys = [],
      sortValues,
      rollup,
      nest;

  function apply(array, depth, createResult, setResult) {
    if (depth >= keys.length) {
      if (sortValues != null) array.sort(sortValues);
      return rollup != null ? rollup(array) : array;
    }

    var i = -1,
        n = array.length,
        key = keys[depth++],
        keyValue,
        value,
        valuesByKey = Object(_map__WEBPACK_IMPORTED_MODULE_0__["default"])(),
        values,
        result = createResult();

    while (++i < n) {
      if (values = valuesByKey.get(keyValue = key(value = array[i]) + "")) {
        values.push(value);
      } else {
        valuesByKey.set(keyValue, [value]);
      }
    }

    valuesByKey.each(function(values, key) {
      setResult(result, key, apply(values, depth, createResult, setResult));
    });

    return result;
  }

  function entries(map, depth) {
    if (++depth > keys.length) return map;
    var array, sortKey = sortKeys[depth - 1];
    if (rollup != null && depth >= keys.length) array = map.entries();
    else array = [], map.each(function(v, k) { array.push({key: k, values: entries(v, depth)}); });
    return sortKey != null ? array.sort(function(a, b) { return sortKey(a.key, b.key); }) : array;
  }

  return nest = {
    object: function(array) { return apply(array, 0, createObject, setObject); },
    map: function(array) { return apply(array, 0, createMap, setMap); },
    entries: function(array) { return entries(apply(array, 0, createMap, setMap), 0); },
    key: function(d) { keys.push(d); return nest; },
    sortKeys: function(order) { sortKeys[keys.length - 1] = order; return nest; },
    sortValues: function(order) { sortValues = order; return nest; },
    rollup: function(f) { rollup = f; return nest; }
  };
});

function createObject() {
  return {};
}

function setObject(object, key, value) {
  object[key] = value;
}

function createMap() {
  return Object(_map__WEBPACK_IMPORTED_MODULE_0__["default"])();
}

function setMap(map, key, value) {
  map.set(key, value);
}


/***/ }),

/***/ "mcvr":
/*!**********************************************!*\
  !*** ./node_modules/d3-contour/src/array.js ***!
  \**********************************************/
/*! exports provided: slice */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slice", function() { return slice; });
var array = Array.prototype;

var slice = array.slice;


/***/ }),

/***/ "n+Lp":
/*!*********************************************!*\
  !*** ./node_modules/d3-polygon/src/area.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(polygon) {
  var i = -1,
      n = polygon.length,
      a,
      b = polygon[n - 1],
      area = 0;

  while (++i < n) {
    a = b;
    b = polygon[i];
    area += a[1] * b[0] - a[0] * b[1];
  }

  return area / 2;
});


/***/ }),

/***/ "n/bd":
/*!***************************************************************!*\
  !*** ./node_modules/c3/node_modules/d3-scale/src/quantile.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return quantile; });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "sRF9");
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./array */ "d/QP");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./init */ "//NX");




function quantile() {
  var domain = [],
      range = [],
      thresholds = [],
      unknown;

  function rescale() {
    var i = 0, n = Math.max(1, range.length);
    thresholds = new Array(n - 1);
    while (++i < n) thresholds[i - 1] = Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["quantile"])(domain, i / n);
    return scale;
  }

  function scale(x) {
    return isNaN(x = +x) ? unknown : range[Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["bisect"])(thresholds, x)];
  }

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN] : [
      i > 0 ? thresholds[i - 1] : domain[0],
      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
    ];
  };

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [];
    for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);
    domain.sort(d3_array__WEBPACK_IMPORTED_MODULE_0__["ascending"]);
    return rescale();
  };

  scale.range = function(_) {
    return arguments.length ? (range = _array__WEBPACK_IMPORTED_MODULE_1__["slice"].call(_), rescale()) : range.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.quantiles = function() {
    return thresholds.slice();
  };

  scale.copy = function() {
    return quantile()
        .domain(domain)
        .range(range)
        .unknown(unknown);
  };

  return _init__WEBPACK_IMPORTED_MODULE_2__["initRange"].apply(scale, arguments);
}


/***/ }),

/***/ "n1Uk":
/*!**********************************************************!*\
  !*** ./node_modules/c3/node_modules/d3-array/src/max.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      max;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null && value > max) {
            max = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && value > max) {
            max = value;
          }
        }
      }
    }
  }

  return max;
});


/***/ }),

/***/ "n8A4":
/*!******************************************!*\
  !*** ./node_modules/d3-geo/src/index.js ***!
  \******************************************/
/*! exports provided: geoArea, geoBounds, geoCentroid, geoCircle, geoClipAntimeridian, geoClipCircle, geoClipExtent, geoClipRectangle, geoContains, geoDistance, geoGraticule, geoGraticule10, geoInterpolate, geoLength, geoPath, geoAlbers, geoAlbersUsa, geoAzimuthalEqualArea, geoAzimuthalEqualAreaRaw, geoAzimuthalEquidistant, geoAzimuthalEquidistantRaw, geoConicConformal, geoConicConformalRaw, geoConicEqualArea, geoConicEqualAreaRaw, geoConicEquidistant, geoConicEquidistantRaw, geoEqualEarth, geoEqualEarthRaw, geoEquirectangular, geoEquirectangularRaw, geoGnomonic, geoGnomonicRaw, geoIdentity, geoProjection, geoProjectionMutator, geoMercator, geoMercatorRaw, geoNaturalEarth1, geoNaturalEarth1Raw, geoOrthographic, geoOrthographicRaw, geoStereographic, geoStereographicRaw, geoTransverseMercator, geoTransverseMercatorRaw, geoRotation, geoStream, geoTransform */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _area_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./area.js */ "PSPu");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoArea", function() { return _area_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _bounds_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bounds.js */ "fjNz");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoBounds", function() { return _bounds_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _centroid_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./centroid.js */ "p5SD");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoCentroid", function() { return _centroid_js__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _circle_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./circle.js */ "vNJl");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoCircle", function() { return _circle_js__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _clip_antimeridian_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./clip/antimeridian.js */ "9ZWv");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoClipAntimeridian", function() { return _clip_antimeridian_js__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _clip_circle_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./clip/circle.js */ "PQSO");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoClipCircle", function() { return _clip_circle_js__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _clip_extent_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./clip/extent.js */ "5/wc");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoClipExtent", function() { return _clip_extent_js__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _clip_rectangle_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./clip/rectangle.js */ "F2eR");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoClipRectangle", function() { return _clip_rectangle_js__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _contains_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./contains.js */ "Hd9g");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoContains", function() { return _contains_js__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _distance_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./distance.js */ "rgrl");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoDistance", function() { return _distance_js__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _graticule_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./graticule.js */ "rdqn");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGraticule", function() { return _graticule_js__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGraticule10", function() { return _graticule_js__WEBPACK_IMPORTED_MODULE_10__["graticule10"]; });

/* harmony import */ var _interpolate_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./interpolate.js */ "prbS");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoInterpolate", function() { return _interpolate_js__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony import */ var _length_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./length.js */ "zz/+");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoLength", function() { return _length_js__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony import */ var _path_index_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./path/index.js */ "vHEj");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoPath", function() { return _path_index_js__WEBPACK_IMPORTED_MODULE_13__["default"]; });

/* harmony import */ var _projection_albers_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./projection/albers.js */ "iQWy");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAlbers", function() { return _projection_albers_js__WEBPACK_IMPORTED_MODULE_14__["default"]; });

/* harmony import */ var _projection_albersUsa_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./projection/albersUsa.js */ "aj5g");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAlbersUsa", function() { return _projection_albersUsa_js__WEBPACK_IMPORTED_MODULE_15__["default"]; });

/* harmony import */ var _projection_azimuthalEqualArea_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./projection/azimuthalEqualArea.js */ "P6wR");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAzimuthalEqualArea", function() { return _projection_azimuthalEqualArea_js__WEBPACK_IMPORTED_MODULE_16__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAzimuthalEqualAreaRaw", function() { return _projection_azimuthalEqualArea_js__WEBPACK_IMPORTED_MODULE_16__["azimuthalEqualAreaRaw"]; });

/* harmony import */ var _projection_azimuthalEquidistant_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./projection/azimuthalEquidistant.js */ "Cuxv");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAzimuthalEquidistant", function() { return _projection_azimuthalEquidistant_js__WEBPACK_IMPORTED_MODULE_17__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAzimuthalEquidistantRaw", function() { return _projection_azimuthalEquidistant_js__WEBPACK_IMPORTED_MODULE_17__["azimuthalEquidistantRaw"]; });

/* harmony import */ var _projection_conicConformal_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./projection/conicConformal.js */ "4jfb");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoConicConformal", function() { return _projection_conicConformal_js__WEBPACK_IMPORTED_MODULE_18__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoConicConformalRaw", function() { return _projection_conicConformal_js__WEBPACK_IMPORTED_MODULE_18__["conicConformalRaw"]; });

/* harmony import */ var _projection_conicEqualArea_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./projection/conicEqualArea.js */ "nVu6");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoConicEqualArea", function() { return _projection_conicEqualArea_js__WEBPACK_IMPORTED_MODULE_19__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoConicEqualAreaRaw", function() { return _projection_conicEqualArea_js__WEBPACK_IMPORTED_MODULE_19__["conicEqualAreaRaw"]; });

/* harmony import */ var _projection_conicEquidistant_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./projection/conicEquidistant.js */ "yWPb");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoConicEquidistant", function() { return _projection_conicEquidistant_js__WEBPACK_IMPORTED_MODULE_20__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoConicEquidistantRaw", function() { return _projection_conicEquidistant_js__WEBPACK_IMPORTED_MODULE_20__["conicEquidistantRaw"]; });

/* harmony import */ var _projection_equalEarth_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./projection/equalEarth.js */ "+WWN");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEqualEarth", function() { return _projection_equalEarth_js__WEBPACK_IMPORTED_MODULE_21__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEqualEarthRaw", function() { return _projection_equalEarth_js__WEBPACK_IMPORTED_MODULE_21__["equalEarthRaw"]; });

/* harmony import */ var _projection_equirectangular_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./projection/equirectangular.js */ "VXJj");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEquirectangular", function() { return _projection_equirectangular_js__WEBPACK_IMPORTED_MODULE_22__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEquirectangularRaw", function() { return _projection_equirectangular_js__WEBPACK_IMPORTED_MODULE_22__["equirectangularRaw"]; });

/* harmony import */ var _projection_gnomonic_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./projection/gnomonic.js */ "wKaL");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGnomonic", function() { return _projection_gnomonic_js__WEBPACK_IMPORTED_MODULE_23__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGnomonicRaw", function() { return _projection_gnomonic_js__WEBPACK_IMPORTED_MODULE_23__["gnomonicRaw"]; });

/* harmony import */ var _projection_identity_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./projection/identity.js */ "bUA0");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoIdentity", function() { return _projection_identity_js__WEBPACK_IMPORTED_MODULE_24__["default"]; });

/* harmony import */ var _projection_index_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./projection/index.js */ "1ibS");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoProjection", function() { return _projection_index_js__WEBPACK_IMPORTED_MODULE_25__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoProjectionMutator", function() { return _projection_index_js__WEBPACK_IMPORTED_MODULE_25__["projectionMutator"]; });

/* harmony import */ var _projection_mercator_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./projection/mercator.js */ "LZ5Q");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoMercator", function() { return _projection_mercator_js__WEBPACK_IMPORTED_MODULE_26__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoMercatorRaw", function() { return _projection_mercator_js__WEBPACK_IMPORTED_MODULE_26__["mercatorRaw"]; });

/* harmony import */ var _projection_naturalEarth1_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./projection/naturalEarth1.js */ "8nOX");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoNaturalEarth1", function() { return _projection_naturalEarth1_js__WEBPACK_IMPORTED_MODULE_27__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoNaturalEarth1Raw", function() { return _projection_naturalEarth1_js__WEBPACK_IMPORTED_MODULE_27__["naturalEarth1Raw"]; });

/* harmony import */ var _projection_orthographic_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./projection/orthographic.js */ "LP84");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoOrthographic", function() { return _projection_orthographic_js__WEBPACK_IMPORTED_MODULE_28__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoOrthographicRaw", function() { return _projection_orthographic_js__WEBPACK_IMPORTED_MODULE_28__["orthographicRaw"]; });

/* harmony import */ var _projection_stereographic_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./projection/stereographic.js */ "aR9J");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoStereographic", function() { return _projection_stereographic_js__WEBPACK_IMPORTED_MODULE_29__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoStereographicRaw", function() { return _projection_stereographic_js__WEBPACK_IMPORTED_MODULE_29__["stereographicRaw"]; });

/* harmony import */ var _projection_transverseMercator_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./projection/transverseMercator.js */ "Y4Tn");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoTransverseMercator", function() { return _projection_transverseMercator_js__WEBPACK_IMPORTED_MODULE_30__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoTransverseMercatorRaw", function() { return _projection_transverseMercator_js__WEBPACK_IMPORTED_MODULE_30__["transverseMercatorRaw"]; });

/* harmony import */ var _rotation_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./rotation.js */ "cwsO");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoRotation", function() { return _rotation_js__WEBPACK_IMPORTED_MODULE_31__["default"]; });

/* harmony import */ var _stream_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./stream.js */ "tepu");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoStream", function() { return _stream_js__WEBPACK_IMPORTED_MODULE_32__["default"]; });

/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./transform.js */ "t9E6");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoTransform", function() { return _transform_js__WEBPACK_IMPORTED_MODULE_33__["default"]; });







 // DEPRECATED! Use d3.geoIdentity().clipExtent(…).





























/***/ }),

/***/ "nVu6":
/*!**************************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/conicEqualArea.js ***!
  \**************************************************************/
/*! exports provided: conicEqualAreaRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conicEqualAreaRaw", function() { return conicEqualAreaRaw; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "R0y8");
/* harmony import */ var _conic_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./conic.js */ "bN2o");
/* harmony import */ var _cylindricalEqualArea_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cylindricalEqualArea.js */ "vAb3");




function conicEqualAreaRaw(y0, y1) {
  var sy0 = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sin"])(y0), n = (sy0 + Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sin"])(y1)) / 2;

  // Are the parallels symmetrical around the Equator?
  if (Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["abs"])(n) < _math_js__WEBPACK_IMPORTED_MODULE_0__["epsilon"]) return Object(_cylindricalEqualArea_js__WEBPACK_IMPORTED_MODULE_2__["cylindricalEqualAreaRaw"])(y0);

  var c = 1 + sy0 * (2 * n - sy0), r0 = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(c) / n;

  function project(x, y) {
    var r = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(c - 2 * n * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sin"])(y)) / n;
    return [r * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sin"])(x *= n), r0 - r * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["cos"])(x)];
  }

  project.invert = function(x, y) {
    var r0y = r0 - y,
        l = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["atan2"])(x, Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["abs"])(r0y)) * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sign"])(r0y);
    if (r0y * n < 0)
      l -= _math_js__WEBPACK_IMPORTED_MODULE_0__["pi"] * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sign"])(x) * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sign"])(r0y);
    return [l / n, Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["asin"])((c - (x * x + r0y * r0y) * n * n) / (2 * n))];
  };

  return project;
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  return Object(_conic_js__WEBPACK_IMPORTED_MODULE_1__["conicProjection"])(conicEqualAreaRaw)
      .scale(155.424)
      .center([0, 33.6442]);
});


/***/ }),

/***/ "nWpo":
/*!*******************************************!*\
  !*** ./node_modules/d3-fetch/src/json.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function responseJson(response) {
  if (!response.ok) throw new Error(response.status + " " + response.statusText);
  if (response.status === 204 || response.status === 205) return;
  return response.json();
}

/* harmony default export */ __webpack_exports__["default"] = (function(input, init) {
  return fetch(input, init).then(responseJson);
});


/***/ }),

/***/ "nXVj":
/*!***********************************************!*\
  !*** ./node_modules/d3-force/src/constant.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return function() {
    return x;
  };
});


/***/ }),

/***/ "nz0m":
/*!****************************************************************!*\
  !*** ./node_modules/c3/node_modules/d3-array/src/ascending.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
});


/***/ }),

/***/ "o3Dy":
/*!***************************************************************!*\
  !*** ./node_modules/c3/node_modules/d3-array/src/bisector.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ascending__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ascending */ "nz0m");


/* harmony default export */ __webpack_exports__["default"] = (function(compare) {
  if (compare.length === 1) compare = ascendingComparator(compare);
  return {
    left: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) < 0) lo = mid + 1;
        else hi = mid;
      }
      return lo;
    },
    right: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) > 0) hi = mid;
        else lo = mid + 1;
      }
      return lo;
    }
  };
});

function ascendingComparator(f) {
  return function(d, x) {
    return Object(_ascending__WEBPACK_IMPORTED_MODULE_0__["default"])(f(d), x);
  };
}


/***/ }),

/***/ "oORo":
/*!*************************************************************!*\
  !*** ./node_modules/c3/node_modules/d3-array/src/extent.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min,
      max;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  }

  return [min, max];
});


/***/ }),

/***/ "oetV":
/*!******************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/index.js ***!
  \******************************************************/
/*! exports provided: schemeCategory10, schemeAccent, schemeDark2, schemePaired, schemePastel1, schemePastel2, schemeSet1, schemeSet2, schemeSet3, schemeTableau10, interpolateBrBG, schemeBrBG, interpolatePRGn, schemePRGn, interpolatePiYG, schemePiYG, interpolatePuOr, schemePuOr, interpolateRdBu, schemeRdBu, interpolateRdGy, schemeRdGy, interpolateRdYlBu, schemeRdYlBu, interpolateRdYlGn, schemeRdYlGn, interpolateSpectral, schemeSpectral, interpolateBuGn, schemeBuGn, interpolateBuPu, schemeBuPu, interpolateGnBu, schemeGnBu, interpolateOrRd, schemeOrRd, interpolatePuBuGn, schemePuBuGn, interpolatePuBu, schemePuBu, interpolatePuRd, schemePuRd, interpolateRdPu, schemeRdPu, interpolateYlGnBu, schemeYlGnBu, interpolateYlGn, schemeYlGn, interpolateYlOrBr, schemeYlOrBr, interpolateYlOrRd, schemeYlOrRd, interpolateBlues, schemeBlues, interpolateGreens, schemeGreens, interpolateGreys, schemeGreys, interpolatePurples, schemePurples, interpolateReds, schemeReds, interpolateOranges, schemeOranges, interpolateCividis, interpolateCubehelixDefault, interpolateRainbow, interpolateWarm, interpolateCool, interpolateSinebow, interpolateTurbo, interpolateViridis, interpolateMagma, interpolateInferno, interpolatePlasma */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _categorical_category10_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./categorical/category10.js */ "qWhX");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeCategory10", function() { return _categorical_category10_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _categorical_Accent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./categorical/Accent.js */ "h2xr");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeAccent", function() { return _categorical_Accent_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _categorical_Dark2_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./categorical/Dark2.js */ "JMsZ");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeDark2", function() { return _categorical_Dark2_js__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _categorical_Paired_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./categorical/Paired.js */ "w5vR");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemePaired", function() { return _categorical_Paired_js__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _categorical_Pastel1_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./categorical/Pastel1.js */ "qyUX");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemePastel1", function() { return _categorical_Pastel1_js__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _categorical_Pastel2_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./categorical/Pastel2.js */ "skVX");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemePastel2", function() { return _categorical_Pastel2_js__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _categorical_Set1_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./categorical/Set1.js */ "1jur");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeSet1", function() { return _categorical_Set1_js__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _categorical_Set2_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./categorical/Set2.js */ "gbBL");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeSet2", function() { return _categorical_Set2_js__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _categorical_Set3_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./categorical/Set3.js */ "C33F");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeSet3", function() { return _categorical_Set3_js__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _categorical_Tableau10_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./categorical/Tableau10.js */ "xkTb");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeTableau10", function() { return _categorical_Tableau10_js__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _diverging_BrBG_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./diverging/BrBG.js */ "SxqP");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateBrBG", function() { return _diverging_BrBG_js__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeBrBG", function() { return _diverging_BrBG_js__WEBPACK_IMPORTED_MODULE_10__["scheme"]; });

/* harmony import */ var _diverging_PRGn_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./diverging/PRGn.js */ "sn8G");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolatePRGn", function() { return _diverging_PRGn_js__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemePRGn", function() { return _diverging_PRGn_js__WEBPACK_IMPORTED_MODULE_11__["scheme"]; });

/* harmony import */ var _diverging_PiYG_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./diverging/PiYG.js */ "VMG8");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolatePiYG", function() { return _diverging_PiYG_js__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemePiYG", function() { return _diverging_PiYG_js__WEBPACK_IMPORTED_MODULE_12__["scheme"]; });

/* harmony import */ var _diverging_PuOr_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./diverging/PuOr.js */ "AHz+");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolatePuOr", function() { return _diverging_PuOr_js__WEBPACK_IMPORTED_MODULE_13__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemePuOr", function() { return _diverging_PuOr_js__WEBPACK_IMPORTED_MODULE_13__["scheme"]; });

/* harmony import */ var _diverging_RdBu_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./diverging/RdBu.js */ "Yn3m");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRdBu", function() { return _diverging_RdBu_js__WEBPACK_IMPORTED_MODULE_14__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeRdBu", function() { return _diverging_RdBu_js__WEBPACK_IMPORTED_MODULE_14__["scheme"]; });

/* harmony import */ var _diverging_RdGy_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./diverging/RdGy.js */ "LSUK");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRdGy", function() { return _diverging_RdGy_js__WEBPACK_IMPORTED_MODULE_15__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeRdGy", function() { return _diverging_RdGy_js__WEBPACK_IMPORTED_MODULE_15__["scheme"]; });

/* harmony import */ var _diverging_RdYlBu_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./diverging/RdYlBu.js */ "w6Z2");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRdYlBu", function() { return _diverging_RdYlBu_js__WEBPACK_IMPORTED_MODULE_16__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeRdYlBu", function() { return _diverging_RdYlBu_js__WEBPACK_IMPORTED_MODULE_16__["scheme"]; });

/* harmony import */ var _diverging_RdYlGn_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./diverging/RdYlGn.js */ "sore");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRdYlGn", function() { return _diverging_RdYlGn_js__WEBPACK_IMPORTED_MODULE_17__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeRdYlGn", function() { return _diverging_RdYlGn_js__WEBPACK_IMPORTED_MODULE_17__["scheme"]; });

/* harmony import */ var _diverging_Spectral_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./diverging/Spectral.js */ "CKiT");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateSpectral", function() { return _diverging_Spectral_js__WEBPACK_IMPORTED_MODULE_18__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeSpectral", function() { return _diverging_Spectral_js__WEBPACK_IMPORTED_MODULE_18__["scheme"]; });

/* harmony import */ var _sequential_multi_BuGn_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./sequential-multi/BuGn.js */ "mLZp");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateBuGn", function() { return _sequential_multi_BuGn_js__WEBPACK_IMPORTED_MODULE_19__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeBuGn", function() { return _sequential_multi_BuGn_js__WEBPACK_IMPORTED_MODULE_19__["scheme"]; });

/* harmony import */ var _sequential_multi_BuPu_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./sequential-multi/BuPu.js */ "Y3EW");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateBuPu", function() { return _sequential_multi_BuPu_js__WEBPACK_IMPORTED_MODULE_20__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeBuPu", function() { return _sequential_multi_BuPu_js__WEBPACK_IMPORTED_MODULE_20__["scheme"]; });

/* harmony import */ var _sequential_multi_GnBu_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./sequential-multi/GnBu.js */ "8F7Y");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateGnBu", function() { return _sequential_multi_GnBu_js__WEBPACK_IMPORTED_MODULE_21__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeGnBu", function() { return _sequential_multi_GnBu_js__WEBPACK_IMPORTED_MODULE_21__["scheme"]; });

/* harmony import */ var _sequential_multi_OrRd_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./sequential-multi/OrRd.js */ "yUst");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateOrRd", function() { return _sequential_multi_OrRd_js__WEBPACK_IMPORTED_MODULE_22__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeOrRd", function() { return _sequential_multi_OrRd_js__WEBPACK_IMPORTED_MODULE_22__["scheme"]; });

/* harmony import */ var _sequential_multi_PuBuGn_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./sequential-multi/PuBuGn.js */ "DHg+");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolatePuBuGn", function() { return _sequential_multi_PuBuGn_js__WEBPACK_IMPORTED_MODULE_23__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemePuBuGn", function() { return _sequential_multi_PuBuGn_js__WEBPACK_IMPORTED_MODULE_23__["scheme"]; });

/* harmony import */ var _sequential_multi_PuBu_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./sequential-multi/PuBu.js */ "uQ0a");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolatePuBu", function() { return _sequential_multi_PuBu_js__WEBPACK_IMPORTED_MODULE_24__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemePuBu", function() { return _sequential_multi_PuBu_js__WEBPACK_IMPORTED_MODULE_24__["scheme"]; });

/* harmony import */ var _sequential_multi_PuRd_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./sequential-multi/PuRd.js */ "eW2m");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolatePuRd", function() { return _sequential_multi_PuRd_js__WEBPACK_IMPORTED_MODULE_25__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemePuRd", function() { return _sequential_multi_PuRd_js__WEBPACK_IMPORTED_MODULE_25__["scheme"]; });

/* harmony import */ var _sequential_multi_RdPu_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./sequential-multi/RdPu.js */ "Yij6");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRdPu", function() { return _sequential_multi_RdPu_js__WEBPACK_IMPORTED_MODULE_26__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeRdPu", function() { return _sequential_multi_RdPu_js__WEBPACK_IMPORTED_MODULE_26__["scheme"]; });

/* harmony import */ var _sequential_multi_YlGnBu_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./sequential-multi/YlGnBu.js */ "E//B");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateYlGnBu", function() { return _sequential_multi_YlGnBu_js__WEBPACK_IMPORTED_MODULE_27__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeYlGnBu", function() { return _sequential_multi_YlGnBu_js__WEBPACK_IMPORTED_MODULE_27__["scheme"]; });

/* harmony import */ var _sequential_multi_YlGn_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./sequential-multi/YlGn.js */ "2YwT");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateYlGn", function() { return _sequential_multi_YlGn_js__WEBPACK_IMPORTED_MODULE_28__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeYlGn", function() { return _sequential_multi_YlGn_js__WEBPACK_IMPORTED_MODULE_28__["scheme"]; });

/* harmony import */ var _sequential_multi_YlOrBr_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./sequential-multi/YlOrBr.js */ "2kEi");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateYlOrBr", function() { return _sequential_multi_YlOrBr_js__WEBPACK_IMPORTED_MODULE_29__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeYlOrBr", function() { return _sequential_multi_YlOrBr_js__WEBPACK_IMPORTED_MODULE_29__["scheme"]; });

/* harmony import */ var _sequential_multi_YlOrRd_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./sequential-multi/YlOrRd.js */ "jTaA");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateYlOrRd", function() { return _sequential_multi_YlOrRd_js__WEBPACK_IMPORTED_MODULE_30__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeYlOrRd", function() { return _sequential_multi_YlOrRd_js__WEBPACK_IMPORTED_MODULE_30__["scheme"]; });

/* harmony import */ var _sequential_single_Blues_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./sequential-single/Blues.js */ "h9r8");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateBlues", function() { return _sequential_single_Blues_js__WEBPACK_IMPORTED_MODULE_31__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeBlues", function() { return _sequential_single_Blues_js__WEBPACK_IMPORTED_MODULE_31__["scheme"]; });

/* harmony import */ var _sequential_single_Greens_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./sequential-single/Greens.js */ "vL4l");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateGreens", function() { return _sequential_single_Greens_js__WEBPACK_IMPORTED_MODULE_32__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeGreens", function() { return _sequential_single_Greens_js__WEBPACK_IMPORTED_MODULE_32__["scheme"]; });

/* harmony import */ var _sequential_single_Greys_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./sequential-single/Greys.js */ "qKhr");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateGreys", function() { return _sequential_single_Greys_js__WEBPACK_IMPORTED_MODULE_33__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeGreys", function() { return _sequential_single_Greys_js__WEBPACK_IMPORTED_MODULE_33__["scheme"]; });

/* harmony import */ var _sequential_single_Purples_js__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./sequential-single/Purples.js */ "RBWq");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolatePurples", function() { return _sequential_single_Purples_js__WEBPACK_IMPORTED_MODULE_34__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemePurples", function() { return _sequential_single_Purples_js__WEBPACK_IMPORTED_MODULE_34__["scheme"]; });

/* harmony import */ var _sequential_single_Reds_js__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./sequential-single/Reds.js */ "50A1");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateReds", function() { return _sequential_single_Reds_js__WEBPACK_IMPORTED_MODULE_35__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeReds", function() { return _sequential_single_Reds_js__WEBPACK_IMPORTED_MODULE_35__["scheme"]; });

/* harmony import */ var _sequential_single_Oranges_js__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./sequential-single/Oranges.js */ "rO+Z");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateOranges", function() { return _sequential_single_Oranges_js__WEBPACK_IMPORTED_MODULE_36__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemeOranges", function() { return _sequential_single_Oranges_js__WEBPACK_IMPORTED_MODULE_36__["scheme"]; });

/* harmony import */ var _sequential_multi_cividis_js__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./sequential-multi/cividis.js */ "XTjh");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateCividis", function() { return _sequential_multi_cividis_js__WEBPACK_IMPORTED_MODULE_37__["default"]; });

/* harmony import */ var _sequential_multi_cubehelix_js__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./sequential-multi/cubehelix.js */ "XfOf");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateCubehelixDefault", function() { return _sequential_multi_cubehelix_js__WEBPACK_IMPORTED_MODULE_38__["default"]; });

/* harmony import */ var _sequential_multi_rainbow_js__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./sequential-multi/rainbow.js */ "X7xT");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRainbow", function() { return _sequential_multi_rainbow_js__WEBPACK_IMPORTED_MODULE_39__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateWarm", function() { return _sequential_multi_rainbow_js__WEBPACK_IMPORTED_MODULE_39__["warm"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateCool", function() { return _sequential_multi_rainbow_js__WEBPACK_IMPORTED_MODULE_39__["cool"]; });

/* harmony import */ var _sequential_multi_sinebow_js__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./sequential-multi/sinebow.js */ "BvdE");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateSinebow", function() { return _sequential_multi_sinebow_js__WEBPACK_IMPORTED_MODULE_40__["default"]; });

/* harmony import */ var _sequential_multi_turbo_js__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./sequential-multi/turbo.js */ "wQ3i");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateTurbo", function() { return _sequential_multi_turbo_js__WEBPACK_IMPORTED_MODULE_41__["default"]; });

/* harmony import */ var _sequential_multi_viridis_js__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./sequential-multi/viridis.js */ "Spa3");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateViridis", function() { return _sequential_multi_viridis_js__WEBPACK_IMPORTED_MODULE_42__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateMagma", function() { return _sequential_multi_viridis_js__WEBPACK_IMPORTED_MODULE_42__["magma"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateInferno", function() { return _sequential_multi_viridis_js__WEBPACK_IMPORTED_MODULE_42__["inferno"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolatePlasma", function() { return _sequential_multi_viridis_js__WEBPACK_IMPORTED_MODULE_42__["plasma"]; });














































/***/ }),

/***/ "otsO":
/*!*************************************************************!*\
  !*** ./node_modules/c3/node_modules/d3-array/src/bisect.js ***!
  \*************************************************************/
/*! exports provided: bisectRight, bisectLeft, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bisectRight", function() { return bisectRight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bisectLeft", function() { return bisectLeft; });
/* harmony import */ var _ascending__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ascending */ "nz0m");
/* harmony import */ var _bisector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bisector */ "o3Dy");



var ascendingBisect = Object(_bisector__WEBPACK_IMPORTED_MODULE_1__["default"])(_ascending__WEBPACK_IMPORTED_MODULE_0__["default"]);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
/* harmony default export */ __webpack_exports__["default"] = (bisectRight);


/***/ }),

/***/ "p/7N":
/*!**********************************************!*\
  !*** ./node_modules/d3-quadtree/src/quad.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(node, x0, y0, x1, y1) {
  this.node = node;
  this.x0 = x0;
  this.y0 = y0;
  this.x1 = x1;
  this.y1 = y1;
});


/***/ }),

/***/ "p5SD":
/*!*********************************************!*\
  !*** ./node_modules/d3-geo/src/centroid.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "R0y8");
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./noop.js */ "mPOO");
/* harmony import */ var _stream_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stream.js */ "tepu");




var W0, W1,
    X0, Y0, Z0,
    X1, Y1, Z1,
    X2, Y2, Z2,
    lambda00, phi00, // first point
    x0, y0, z0; // previous point

var centroidStream = {
  sphere: _noop_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function() {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function() {
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  }
};

// Arithmetic mean of Cartesian vectors.
function centroidPoint(lambda, phi) {
  lambda *= _math_js__WEBPACK_IMPORTED_MODULE_0__["radians"], phi *= _math_js__WEBPACK_IMPORTED_MODULE_0__["radians"];
  var cosPhi = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["cos"])(phi);
  centroidPointCartesian(cosPhi * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["cos"])(lambda), cosPhi * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sin"])(lambda), Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sin"])(phi));
}

function centroidPointCartesian(x, y, z) {
  ++W0;
  X0 += (x - X0) / W0;
  Y0 += (y - Y0) / W0;
  Z0 += (z - Z0) / W0;
}

function centroidLineStart() {
  centroidStream.point = centroidLinePointFirst;
}

function centroidLinePointFirst(lambda, phi) {
  lambda *= _math_js__WEBPACK_IMPORTED_MODULE_0__["radians"], phi *= _math_js__WEBPACK_IMPORTED_MODULE_0__["radians"];
  var cosPhi = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["cos"])(phi);
  x0 = cosPhi * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["cos"])(lambda);
  y0 = cosPhi * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sin"])(lambda);
  z0 = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sin"])(phi);
  centroidStream.point = centroidLinePoint;
  centroidPointCartesian(x0, y0, z0);
}

function centroidLinePoint(lambda, phi) {
  lambda *= _math_js__WEBPACK_IMPORTED_MODULE_0__["radians"], phi *= _math_js__WEBPACK_IMPORTED_MODULE_0__["radians"];
  var cosPhi = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["cos"])(phi),
      x = cosPhi * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["cos"])(lambda),
      y = cosPhi * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sin"])(lambda),
      z = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sin"])(phi),
      w = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["atan2"])(Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sqrt"])((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
  W1 += w;
  X1 += w * (x0 + (x0 = x));
  Y1 += w * (y0 + (y0 = y));
  Z1 += w * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}

function centroidLineEnd() {
  centroidStream.point = centroidPoint;
}

// See J. E. Brock, The Inertia Tensor for a Spherical Triangle,
// J. Applied Mechanics 42, 239 (1975).
function centroidRingStart() {
  centroidStream.point = centroidRingPointFirst;
}

function centroidRingEnd() {
  centroidRingPoint(lambda00, phi00);
  centroidStream.point = centroidPoint;
}

function centroidRingPointFirst(lambda, phi) {
  lambda00 = lambda, phi00 = phi;
  lambda *= _math_js__WEBPACK_IMPORTED_MODULE_0__["radians"], phi *= _math_js__WEBPACK_IMPORTED_MODULE_0__["radians"];
  centroidStream.point = centroidRingPoint;
  var cosPhi = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["cos"])(phi);
  x0 = cosPhi * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["cos"])(lambda);
  y0 = cosPhi * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sin"])(lambda);
  z0 = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sin"])(phi);
  centroidPointCartesian(x0, y0, z0);
}

function centroidRingPoint(lambda, phi) {
  lambda *= _math_js__WEBPACK_IMPORTED_MODULE_0__["radians"], phi *= _math_js__WEBPACK_IMPORTED_MODULE_0__["radians"];
  var cosPhi = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["cos"])(phi),
      x = cosPhi * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["cos"])(lambda),
      y = cosPhi * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sin"])(lambda),
      z = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sin"])(phi),
      cx = y0 * z - z0 * y,
      cy = z0 * x - x0 * z,
      cz = x0 * y - y0 * x,
      m = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(cx * cx + cy * cy + cz * cz),
      w = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["asin"])(m), // line weight = angle
      v = m && -w / m; // area weight multiplier
  X2 += v * cx;
  Y2 += v * cy;
  Z2 += v * cz;
  W1 += w;
  X1 += w * (x0 + (x0 = x));
  Y1 += w * (y0 + (y0 = y));
  Z1 += w * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}

/* harmony default export */ __webpack_exports__["default"] = (function(object) {
  W0 = W1 =
  X0 = Y0 = Z0 =
  X1 = Y1 = Z1 =
  X2 = Y2 = Z2 = 0;
  Object(_stream_js__WEBPACK_IMPORTED_MODULE_2__["default"])(object, centroidStream);

  var x = X2,
      y = Y2,
      z = Z2,
      m = x * x + y * y + z * z;

  // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.
  if (m < _math_js__WEBPACK_IMPORTED_MODULE_0__["epsilon2"]) {
    x = X1, y = Y1, z = Z1;
    // If the feature has zero length, fall back to arithmetic mean of point vectors.
    if (W1 < _math_js__WEBPACK_IMPORTED_MODULE_0__["epsilon"]) x = X0, y = Y0, z = Z0;
    m = x * x + y * y + z * z;
    // If the feature still has an undefined ccentroid, then return.
    if (m < _math_js__WEBPACK_IMPORTED_MODULE_0__["epsilon2"]) return [NaN, NaN];
  }

  return [Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["atan2"])(y, x) * _math_js__WEBPACK_IMPORTED_MODULE_0__["degrees"], Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["asin"])(z / Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(m)) * _math_js__WEBPACK_IMPORTED_MODULE_0__["degrees"]];
});


/***/ }),

/***/ "pVVs":
/*!***************************************************************!*\
  !*** ./node_modules/c3/node_modules/d3-array/src/quantile.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./number */ "1Fr+");


/* harmony default export */ __webpack_exports__["default"] = (function(values, p, valueof) {
  if (valueof == null) valueof = _number__WEBPACK_IMPORTED_MODULE_0__["default"];
  if (!(n = values.length)) return;
  if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
  if (p >= 1) return +valueof(values[n - 1], n - 1, values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = +valueof(values[i0], i0, values),
      value1 = +valueof(values[i0 + 1], i0 + 1, values);
  return value0 + (value1 - value0) * (i - i0);
});


/***/ }),

/***/ "pb3N":
/*!***********************************************!*\
  !*** ./node_modules/d3-geo/src/clip/index.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _buffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./buffer.js */ "ODVu");
/* harmony import */ var _rejoin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rejoin.js */ "5xK/");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math.js */ "R0y8");
/* harmony import */ var _polygonContains_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../polygonContains.js */ "7FHc");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-array */ "sRF9");






/* harmony default export */ __webpack_exports__["default"] = (function(pointVisible, clipLine, interpolate, start) {
  return function(sink) {
    var line = clipLine(sink),
        ringBuffer = Object(_buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"])(),
        ringSink = clipLine(ringBuffer),
        polygonStarted = false,
        polygon,
        segments,
        ring;

    var clip = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function() {
        clip.point = pointRing;
        clip.lineStart = ringStart;
        clip.lineEnd = ringEnd;
        segments = [];
        polygon = [];
      },
      polygonEnd: function() {
        clip.point = point;
        clip.lineStart = lineStart;
        clip.lineEnd = lineEnd;
        segments = Object(d3_array__WEBPACK_IMPORTED_MODULE_4__["merge"])(segments);
        var startInside = Object(_polygonContains_js__WEBPACK_IMPORTED_MODULE_3__["default"])(polygon, start);
        if (segments.length) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          Object(_rejoin_js__WEBPACK_IMPORTED_MODULE_1__["default"])(segments, compareIntersection, startInside, interpolate, sink);
        } else if (startInside) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          interpolate(null, null, 1, sink);
          sink.lineEnd();
        }
        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
        segments = polygon = null;
      },
      sphere: function() {
        sink.polygonStart();
        sink.lineStart();
        interpolate(null, null, 1, sink);
        sink.lineEnd();
        sink.polygonEnd();
      }
    };

    function point(lambda, phi) {
      if (pointVisible(lambda, phi)) sink.point(lambda, phi);
    }

    function pointLine(lambda, phi) {
      line.point(lambda, phi);
    }

    function lineStart() {
      clip.point = pointLine;
      line.lineStart();
    }

    function lineEnd() {
      clip.point = point;
      line.lineEnd();
    }

    function pointRing(lambda, phi) {
      ring.push([lambda, phi]);
      ringSink.point(lambda, phi);
    }

    function ringStart() {
      ringSink.lineStart();
      ring = [];
    }

    function ringEnd() {
      pointRing(ring[0][0], ring[0][1]);
      ringSink.lineEnd();

      var clean = ringSink.clean(),
          ringSegments = ringBuffer.result(),
          i, n = ringSegments.length, m,
          segment,
          point;

      ring.pop();
      polygon.push(ring);
      ring = null;

      if (!n) return;

      // No intersections.
      if (clean & 1) {
        segment = ringSegments[0];
        if ((m = segment.length - 1) > 0) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);
          sink.lineEnd();
        }
        return;
      }

      // Rejoin connected segments.
      // TODO reuse ringBuffer.rejoin()?
      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));

      segments.push(ringSegments.filter(validSegment));
    }

    return clip;
  };
});

function validSegment(segment) {
  return segment.length > 1;
}

// Intersections are sorted along the clip edge. For both antimeridian cutting
// and circle clipping, the same comparison is used.
function compareIntersection(a, b) {
  return ((a = a.x)[0] < 0 ? a[1] - _math_js__WEBPACK_IMPORTED_MODULE_2__["halfPi"] - _math_js__WEBPACK_IMPORTED_MODULE_2__["epsilon"] : _math_js__WEBPACK_IMPORTED_MODULE_2__["halfPi"] - a[1])
       - ((b = b.x)[0] < 0 ? b[1] - _math_js__WEBPACK_IMPORTED_MODULE_2__["halfPi"] - _math_js__WEBPACK_IMPORTED_MODULE_2__["epsilon"] : _math_js__WEBPACK_IMPORTED_MODULE_2__["halfPi"] - b[1]);
}


/***/ }),

/***/ "pbho":
/*!********************************************!*\
  !*** ./node_modules/d3-geo/src/compose.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {

  function compose(x, y) {
    return x = a(x, y), b(x[0], x[1]);
  }

  if (a.invert && b.invert) compose.invert = function(x, y) {
    return x = b.invert(x, y), x && a.invert(x[0], x[1]);
  };

  return compose;
});


/***/ }),

/***/ "prbS":
/*!************************************************!*\
  !*** ./node_modules/d3-geo/src/interpolate.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "R0y8");


/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  var x0 = a[0] * _math_js__WEBPACK_IMPORTED_MODULE_0__["radians"],
      y0 = a[1] * _math_js__WEBPACK_IMPORTED_MODULE_0__["radians"],
      x1 = b[0] * _math_js__WEBPACK_IMPORTED_MODULE_0__["radians"],
      y1 = b[1] * _math_js__WEBPACK_IMPORTED_MODULE_0__["radians"],
      cy0 = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["cos"])(y0),
      sy0 = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sin"])(y0),
      cy1 = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["cos"])(y1),
      sy1 = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sin"])(y1),
      kx0 = cy0 * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["cos"])(x0),
      ky0 = cy0 * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sin"])(x0),
      kx1 = cy1 * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["cos"])(x1),
      ky1 = cy1 * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sin"])(x1),
      d = 2 * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["asin"])(Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["haversin"])(y1 - y0) + cy0 * cy1 * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["haversin"])(x1 - x0))),
      k = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sin"])(d);

  var interpolate = d ? function(t) {
    var B = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sin"])(t *= d) / k,
        A = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sin"])(d - t) / k,
        x = A * kx0 + B * kx1,
        y = A * ky0 + B * ky1,
        z = A * sy0 + B * sy1;
    return [
      Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["atan2"])(y, x) * _math_js__WEBPACK_IMPORTED_MODULE_0__["degrees"],
      Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["atan2"])(z, Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(x * x + y * y)) * _math_js__WEBPACK_IMPORTED_MODULE_0__["degrees"]
    ];
  } : function() {
    return [x0 * _math_js__WEBPACK_IMPORTED_MODULE_0__["degrees"], y0 * _math_js__WEBPACK_IMPORTED_MODULE_0__["degrees"]];
  };

  interpolate.distance = d;

  return interpolate;
});


/***/ }),

/***/ "ptze":
/*!**********************************************!*\
  !*** ./node_modules/d3-random/src/normal.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _defaultSource__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./defaultSource */ "0RZX");


/* harmony default export */ __webpack_exports__["default"] = ((function sourceRandomNormal(source) {
  function randomNormal(mu, sigma) {
    var x, r;
    mu = mu == null ? 0 : +mu;
    sigma = sigma == null ? 1 : +sigma;
    return function() {
      var y;

      // If available, use the second previously-generated uniform random.
      if (x != null) y = x, x = null;

      // Otherwise, generate a new x and y.
      else do {
        x = source() * 2 - 1;
        y = source() * 2 - 1;
        r = x * x + y * y;
      } while (!r || r > 1);

      return mu + sigma * y * Math.sqrt(-2 * Math.log(r) / r);
    };
  }

  randomNormal.source = sourceRandomNormal;

  return randomNormal;
})(_defaultSource__WEBPACK_IMPORTED_MODULE_0__["default"]));


/***/ }),

/***/ "qKBD":
/*!************************************************************!*\
  !*** ./node_modules/c3/node_modules/d3-array/src/range.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

  var i = -1,
      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
      range = new Array(n);

  while (++i < n) {
    range[i] = start + i * step;
  }

  return range;
});


/***/ }),

/***/ "qKhr":
/*!************************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/sequential-single/Greys.js ***!
  \************************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors.js */ "ZtE7");
/* harmony import */ var _ramp_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp.js */ "jQWc");



var scheme = new Array(3).concat(
  "f0f0f0bdbdbd636363",
  "f7f7f7cccccc969696525252",
  "f7f7f7cccccc969696636363252525",
  "f7f7f7d9d9d9bdbdbd969696636363252525",
  "f7f7f7d9d9d9bdbdbd969696737373525252252525",
  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525",
  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000"
).map(_colors_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp_js__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "qWhX":
/*!***********************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/categorical/category10.js ***!
  \***********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors.js */ "ZtE7");


/* harmony default export */ __webpack_exports__["default"] = (Object(_colors_js__WEBPACK_IMPORTED_MODULE_0__["default"])("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf"));


/***/ }),

/***/ "qyUX":
/*!********************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/categorical/Pastel1.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors.js */ "ZtE7");


/* harmony default export */ __webpack_exports__["default"] = (Object(_colors_js__WEBPACK_IMPORTED_MODULE_0__["default"])("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2"));


/***/ }),

/***/ "r9oD":
/*!*************************************************************!*\
  !*** ./node_modules/c3/node_modules/d3-array/src/median.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ascending__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ascending */ "nz0m");
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./number */ "1Fr+");
/* harmony import */ var _quantile__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./quantile */ "pVVs");




/* harmony default export */ __webpack_exports__["default"] = (function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      numbers = [];

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = Object(_number__WEBPACK_IMPORTED_MODULE_1__["default"])(values[i]))) {
        numbers.push(value);
      }
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = Object(_number__WEBPACK_IMPORTED_MODULE_1__["default"])(valueof(values[i], i, values)))) {
        numbers.push(value);
      }
    }
  }

  return Object(_quantile__WEBPACK_IMPORTED_MODULE_2__["default"])(numbers.sort(_ascending__WEBPACK_IMPORTED_MODULE_0__["default"]), 0.5);
});


/***/ }),

/***/ "rBOd":
/*!**********************************************!*\
  !*** ./node_modules/d3-geo/src/path/area.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _adder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../adder.js */ "uCr6");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math.js */ "R0y8");
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../noop.js */ "mPOO");




var areaSum = Object(_adder_js__WEBPACK_IMPORTED_MODULE_0__["default"])(),
    areaRingSum = Object(_adder_js__WEBPACK_IMPORTED_MODULE_0__["default"])(),
    x00,
    y00,
    x0,
    y0;

var areaStream = {
  point: _noop_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  lineStart: _noop_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  lineEnd: _noop_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  polygonStart: function() {
    areaStream.lineStart = areaRingStart;
    areaStream.lineEnd = areaRingEnd;
  },
  polygonEnd: function() {
    areaStream.lineStart = areaStream.lineEnd = areaStream.point = _noop_js__WEBPACK_IMPORTED_MODULE_2__["default"];
    areaSum.add(Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["abs"])(areaRingSum));
    areaRingSum.reset();
  },
  result: function() {
    var area = areaSum / 2;
    areaSum.reset();
    return area;
  }
};

function areaRingStart() {
  areaStream.point = areaPointFirst;
}

function areaPointFirst(x, y) {
  areaStream.point = areaPoint;
  x00 = x0 = x, y00 = y0 = y;
}

function areaPoint(x, y) {
  areaRingSum.add(y0 * x - x0 * y);
  x0 = x, y0 = y;
}

function areaRingEnd() {
  areaPoint(x00, y00);
}

/* harmony default export */ __webpack_exports__["default"] = (areaStream);


/***/ }),

/***/ "rO+Z":
/*!**************************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/sequential-single/Oranges.js ***!
  \**************************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors.js */ "ZtE7");
/* harmony import */ var _ramp_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp.js */ "jQWc");



var scheme = new Array(3).concat(
  "fee6cefdae6be6550d",
  "feeddefdbe85fd8d3cd94701",
  "feeddefdbe85fd8d3ce6550da63603",
  "feeddefdd0a2fdae6bfd8d3ce6550da63603",
  "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04",
  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04",
  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704"
).map(_colors_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp_js__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "rdqn":
/*!**********************************************!*\
  !*** ./node_modules/d3-geo/src/graticule.js ***!
  \**********************************************/
/*! exports provided: default, graticule10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return graticule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "graticule10", function() { return graticule10; });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "sRF9");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ "R0y8");



function graticuleX(y0, y1, dy) {
  var y = Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["range"])(y0, y1 - _math_js__WEBPACK_IMPORTED_MODULE_1__["epsilon"], dy).concat(y1);
  return function(x) { return y.map(function(y) { return [x, y]; }); };
}

function graticuleY(x0, x1, dx) {
  var x = Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["range"])(x0, x1 - _math_js__WEBPACK_IMPORTED_MODULE_1__["epsilon"], dx).concat(x1);
  return function(y) { return x.map(function(x) { return [x, y]; }); };
}

function graticule() {
  var x1, x0, X1, X0,
      y1, y0, Y1, Y0,
      dx = 10, dy = dx, DX = 90, DY = 360,
      x, y, X, Y,
      precision = 2.5;

  function graticule() {
    return {type: "MultiLineString", coordinates: lines()};
  }

  function lines() {
    return Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["range"])(Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["ceil"])(X0 / DX) * DX, X1, DX).map(X)
        .concat(Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["range"])(Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["ceil"])(Y0 / DY) * DY, Y1, DY).map(Y))
        .concat(Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["range"])(Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["ceil"])(x0 / dx) * dx, x1, dx).filter(function(x) { return Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["abs"])(x % DX) > _math_js__WEBPACK_IMPORTED_MODULE_1__["epsilon"]; }).map(x))
        .concat(Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["range"])(Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["ceil"])(y0 / dy) * dy, y1, dy).filter(function(y) { return Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["abs"])(y % DY) > _math_js__WEBPACK_IMPORTED_MODULE_1__["epsilon"]; }).map(y));
  }

  graticule.lines = function() {
    return lines().map(function(coordinates) { return {type: "LineString", coordinates: coordinates}; });
  };

  graticule.outline = function() {
    return {
      type: "Polygon",
      coordinates: [
        X(X0).concat(
        Y(Y1).slice(1),
        X(X1).reverse().slice(1),
        Y(Y0).reverse().slice(1))
      ]
    };
  };

  graticule.extent = function(_) {
    if (!arguments.length) return graticule.extentMinor();
    return graticule.extentMajor(_).extentMinor(_);
  };

  graticule.extentMajor = function(_) {
    if (!arguments.length) return [[X0, Y0], [X1, Y1]];
    X0 = +_[0][0], X1 = +_[1][0];
    Y0 = +_[0][1], Y1 = +_[1][1];
    if (X0 > X1) _ = X0, X0 = X1, X1 = _;
    if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
    return graticule.precision(precision);
  };

  graticule.extentMinor = function(_) {
    if (!arguments.length) return [[x0, y0], [x1, y1]];
    x0 = +_[0][0], x1 = +_[1][0];
    y0 = +_[0][1], y1 = +_[1][1];
    if (x0 > x1) _ = x0, x0 = x1, x1 = _;
    if (y0 > y1) _ = y0, y0 = y1, y1 = _;
    return graticule.precision(precision);
  };

  graticule.step = function(_) {
    if (!arguments.length) return graticule.stepMinor();
    return graticule.stepMajor(_).stepMinor(_);
  };

  graticule.stepMajor = function(_) {
    if (!arguments.length) return [DX, DY];
    DX = +_[0], DY = +_[1];
    return graticule;
  };

  graticule.stepMinor = function(_) {
    if (!arguments.length) return [dx, dy];
    dx = +_[0], dy = +_[1];
    return graticule;
  };

  graticule.precision = function(_) {
    if (!arguments.length) return precision;
    precision = +_;
    x = graticuleX(y0, y1, 90);
    y = graticuleY(x0, x1, precision);
    X = graticuleX(Y0, Y1, 90);
    Y = graticuleY(X0, X1, precision);
    return graticule;
  };

  return graticule
      .extentMajor([[-180, -90 + _math_js__WEBPACK_IMPORTED_MODULE_1__["epsilon"]], [180, 90 - _math_js__WEBPACK_IMPORTED_MODULE_1__["epsilon"]]])
      .extentMinor([[-180, -80 - _math_js__WEBPACK_IMPORTED_MODULE_1__["epsilon"]], [180, 80 + _math_js__WEBPACK_IMPORTED_MODULE_1__["epsilon"]]]);
}

function graticule10() {
  return graticule()();
}


/***/ }),

/***/ "rgrl":
/*!*********************************************!*\
  !*** ./node_modules/d3-geo/src/distance.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _length_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./length.js */ "zz/+");


var coordinates = [null, null],
    object = {type: "LineString", coordinates: coordinates};

/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  coordinates[0] = a;
  coordinates[1] = b;
  return Object(_length_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object);
});


/***/ }),

/***/ "rnr1":
/*!***********************************************************!*\
  !*** ./node_modules/c3/node_modules/d3-array/src/scan.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ascending__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ascending */ "nz0m");


/* harmony default export */ __webpack_exports__["default"] = (function(values, compare) {
  if (!(n = values.length)) return;
  var n,
      i = 0,
      j = 0,
      xi,
      xj = values[j];

  if (compare == null) compare = _ascending__WEBPACK_IMPORTED_MODULE_0__["default"];

  while (++i < n) {
    if (compare(xi = values[i], xj) < 0 || compare(xj, xj) !== 0) {
      xj = xi, j = i;
    }
  }

  if (compare(xj, xj) === 0) return j;
});


/***/ }),

/***/ "s3OU":
/*!*****************************************************************************!*\
  !*** ./node_modules/c3/node_modules/d3/node_modules/d3-dsv/src/autoType.js ***!
  \*****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return autoType; });
function autoType(object) {
  for (var key in object) {
    var value = object[key].trim(), number, m;
    if (!value) value = null;
    else if (value === "true") value = true;
    else if (value === "false") value = false;
    else if (value === "NaN") value = NaN;
    else if (!isNaN(number = +value)) value = number;
    else if (m = value.match(/^([-+]\d{2})?\d{4}(-\d{2}(-\d{2})?)?(T\d{2}:\d{2}(:\d{2}(\.\d{3})?)?(Z|[-+]\d{2}:\d{2})?)?$/)) {
      if (fixtz && !!m[4] && !m[7]) value = value.replace(/-/g, "/").replace(/T/, " ");
      value = new Date(value);
    }
    else continue;
    object[key] = value;
  }
  return object;
}

// https://github.com/d3/d3-dsv/issues/45
var fixtz = new Date("2019-01-01T00:00").getHours() || new Date("2019-07-01T00:00").getHours();

/***/ }),

/***/ "sRF9":
/*!************************************************************!*\
  !*** ./node_modules/c3/node_modules/d3-array/src/index.js ***!
  \************************************************************/
/*! exports provided: bisect, bisectRight, bisectLeft, ascending, bisector, cross, descending, deviation, extent, histogram, thresholdFreedmanDiaconis, thresholdScott, thresholdSturges, max, mean, median, merge, min, pairs, permute, quantile, range, scan, shuffle, sum, ticks, tickIncrement, tickStep, transpose, variance, zip */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _bisect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bisect */ "otsO");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bisect", function() { return _bisect__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bisectRight", function() { return _bisect__WEBPACK_IMPORTED_MODULE_0__["bisectRight"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bisectLeft", function() { return _bisect__WEBPACK_IMPORTED_MODULE_0__["bisectLeft"]; });

/* harmony import */ var _ascending__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ascending */ "nz0m");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ascending", function() { return _ascending__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _bisector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bisector */ "o3Dy");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bisector", function() { return _bisector__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _cross__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cross */ "C9Ig");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cross", function() { return _cross__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _descending__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./descending */ "xpgS");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "descending", function() { return _descending__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _deviation__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./deviation */ "amxm");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "deviation", function() { return _deviation__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _extent__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./extent */ "oORo");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extent", function() { return _extent__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _histogram__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./histogram */ "8+1p");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "histogram", function() { return _histogram__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _threshold_freedmanDiaconis__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./threshold/freedmanDiaconis */ "MrsS");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "thresholdFreedmanDiaconis", function() { return _threshold_freedmanDiaconis__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _threshold_scott__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./threshold/scott */ "96UZ");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "thresholdScott", function() { return _threshold_scott__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _threshold_sturges__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./threshold/sturges */ "NvdV");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "thresholdSturges", function() { return _threshold_sturges__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _max__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./max */ "n1Uk");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "max", function() { return _max__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony import */ var _mean__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./mean */ "Wcxc");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mean", function() { return _mean__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony import */ var _median__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./median */ "r9oD");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "median", function() { return _median__WEBPACK_IMPORTED_MODULE_13__["default"]; });

/* harmony import */ var _merge__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./merge */ "eYML");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "merge", function() { return _merge__WEBPACK_IMPORTED_MODULE_14__["default"]; });

/* harmony import */ var _min__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./min */ "BuHV");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "min", function() { return _min__WEBPACK_IMPORTED_MODULE_15__["default"]; });

/* harmony import */ var _pairs__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./pairs */ "0VgA");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pairs", function() { return _pairs__WEBPACK_IMPORTED_MODULE_16__["default"]; });

/* harmony import */ var _permute__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./permute */ "vW5+");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "permute", function() { return _permute__WEBPACK_IMPORTED_MODULE_17__["default"]; });

/* harmony import */ var _quantile__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./quantile */ "pVVs");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "quantile", function() { return _quantile__WEBPACK_IMPORTED_MODULE_18__["default"]; });

/* harmony import */ var _range__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./range */ "qKBD");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "range", function() { return _range__WEBPACK_IMPORTED_MODULE_19__["default"]; });

/* harmony import */ var _scan__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./scan */ "rnr1");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scan", function() { return _scan__WEBPACK_IMPORTED_MODULE_20__["default"]; });

/* harmony import */ var _shuffle__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./shuffle */ "mGj8");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "shuffle", function() { return _shuffle__WEBPACK_IMPORTED_MODULE_21__["default"]; });

/* harmony import */ var _sum__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./sum */ "/Cr3");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sum", function() { return _sum__WEBPACK_IMPORTED_MODULE_22__["default"]; });

/* harmony import */ var _ticks__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./ticks */ "5bIW");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ticks", function() { return _ticks__WEBPACK_IMPORTED_MODULE_23__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tickIncrement", function() { return _ticks__WEBPACK_IMPORTED_MODULE_23__["tickIncrement"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tickStep", function() { return _ticks__WEBPACK_IMPORTED_MODULE_23__["tickStep"]; });

/* harmony import */ var _transpose__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./transpose */ "TQ5W");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "transpose", function() { return _transpose__WEBPACK_IMPORTED_MODULE_24__["default"]; });

/* harmony import */ var _variance__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./variance */ "w5my");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "variance", function() { return _variance__WEBPACK_IMPORTED_MODULE_25__["default"]; });

/* harmony import */ var _zip__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./zip */ "1oRR");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zip", function() { return _zip__WEBPACK_IMPORTED_MODULE_26__["default"]; });






























/***/ }),

/***/ "skVX":
/*!********************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/categorical/Pastel2.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors.js */ "ZtE7");


/* harmony default export */ __webpack_exports__["default"] = (Object(_colors_js__WEBPACK_IMPORTED_MODULE_0__["default"])("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc"));


/***/ }),

/***/ "sn8G":
/*!***************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/diverging/PRGn.js ***!
  \***************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors.js */ "ZtE7");
/* harmony import */ var _ramp_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp.js */ "jQWc");



var scheme = new Array(3).concat(
  "af8dc3f7f7f77fbf7b",
  "7b3294c2a5cfa6dba0008837",
  "7b3294c2a5cff7f7f7a6dba0008837",
  "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837",
  "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837",
  "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837",
  "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837",
  "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b",
  "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b"
).map(_colors_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp_js__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "sore":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/diverging/RdYlGn.js ***!
  \*****************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors.js */ "ZtE7");
/* harmony import */ var _ramp_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp.js */ "jQWc");



var scheme = new Array(3).concat(
  "fc8d59ffffbf91cf60",
  "d7191cfdae61a6d96a1a9641",
  "d7191cfdae61ffffbfa6d96a1a9641",
  "d73027fc8d59fee08bd9ef8b91cf601a9850",
  "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850",
  "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850",
  "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850",
  "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837",
  "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837"
).map(_colors_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp_js__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "sukG":
/*!********************************************!*\
  !*** ./node_modules/d3-fetch/src/index.js ***!
  \********************************************/
/*! exports provided: blob, buffer, dsv, csv, tsv, image, json, text, xml, html, svg */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _blob_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./blob.js */ "kgU0");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "blob", function() { return _blob_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _buffer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./buffer.js */ "XO33");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "buffer", function() { return _buffer_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _dsv_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dsv.js */ "8cru");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dsv", function() { return _dsv_js__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "csv", function() { return _dsv_js__WEBPACK_IMPORTED_MODULE_2__["csv"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tsv", function() { return _dsv_js__WEBPACK_IMPORTED_MODULE_2__["tsv"]; });

/* harmony import */ var _image_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./image.js */ "HN8k");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "image", function() { return _image_js__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _json_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./json.js */ "nWpo");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "json", function() { return _json_js__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _text_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./text.js */ "7NYn");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "text", function() { return _text_js__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _xml_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./xml.js */ "8moF");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "xml", function() { return _xml_js__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "html", function() { return _xml_js__WEBPACK_IMPORTED_MODULE_6__["html"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "svg", function() { return _xml_js__WEBPACK_IMPORTED_MODULE_6__["svg"]; });










/***/ }),

/***/ "t9E6":
/*!**********************************************!*\
  !*** ./node_modules/d3-geo/src/transform.js ***!
  \**********************************************/
/*! exports provided: default, transformer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformer", function() { return transformer; });
/* harmony default export */ __webpack_exports__["default"] = (function(methods) {
  return {
    stream: transformer(methods)
  };
});

function transformer(methods) {
  return function(stream) {
    var s = new TransformStream;
    for (var key in methods) s[key] = methods[key];
    s.stream = stream;
    return s;
  };
}

function TransformStream() {}

TransformStream.prototype = {
  constructor: TransformStream,
  point: function(x, y) { this.stream.point(x, y); },
  sphere: function() { this.stream.sphere(); },
  lineStart: function() { this.stream.lineStart(); },
  lineEnd: function() { this.stream.lineEnd(); },
  polygonStart: function() { this.stream.polygonStart(); },
  polygonEnd: function() { this.stream.polygonEnd(); }
};


/***/ }),

/***/ "tOsU":
/*!**************************************************!*\
  !*** ./node_modules/d3-contour/src/ascending.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  return a - b;
});


/***/ }),

/***/ "tSfe":
/*!****************************************************!*\
  !*** ./node_modules/d3-quadtree/src/visitAfter.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _quad_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./quad.js */ "p/7N");


/* harmony default export */ __webpack_exports__["default"] = (function(callback) {
  var quads = [], next = [], q;
  if (this._root) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](this._root, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    var node = q.node;
    if (node.length) {
      var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[0]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, x0, y0, xm, ym));
      if (child = node[1]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, xm, y0, x1, ym));
      if (child = node[2]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, x0, ym, xm, y1));
      if (child = node[3]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, xm, ym, x1, y1));
    }
    next.push(q);
  }
  while (q = next.pop()) {
    callback(q.node, q.x0, q.y0, q.x1, q.y1);
  }
  return this;
});


/***/ }),

/***/ "tUiF":
/*!**********************************************!*\
  !*** ./node_modules/d3-polygon/src/index.js ***!
  \**********************************************/
/*! exports provided: polygonArea, polygonCentroid, polygonHull, polygonContains, polygonLength */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _area_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./area.js */ "n+Lp");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "polygonArea", function() { return _area_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _centroid_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./centroid.js */ "H39o");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "polygonCentroid", function() { return _centroid_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _hull_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hull.js */ "ezys");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "polygonHull", function() { return _hull_js__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _contains_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./contains.js */ "uV4M");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "polygonContains", function() { return _contains_js__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _length_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./length.js */ "INn1");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "polygonLength", function() { return _length_js__WEBPACK_IMPORTED_MODULE_4__["default"]; });








/***/ }),

/***/ "tepu":
/*!*******************************************!*\
  !*** ./node_modules/d3-geo/src/stream.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function streamGeometry(geometry, stream) {
  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
    streamGeometryType[geometry.type](geometry, stream);
  }
}

var streamObjectType = {
  Feature: function(object, stream) {
    streamGeometry(object.geometry, stream);
  },
  FeatureCollection: function(object, stream) {
    var features = object.features, i = -1, n = features.length;
    while (++i < n) streamGeometry(features[i].geometry, stream);
  }
};

var streamGeometryType = {
  Sphere: function(object, stream) {
    stream.sphere();
  },
  Point: function(object, stream) {
    object = object.coordinates;
    stream.point(object[0], object[1], object[2]);
  },
  MultiPoint: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);
  },
  LineString: function(object, stream) {
    streamLine(object.coordinates, stream, 0);
  },
  MultiLineString: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) streamLine(coordinates[i], stream, 0);
  },
  Polygon: function(object, stream) {
    streamPolygon(object.coordinates, stream);
  },
  MultiPolygon: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) streamPolygon(coordinates[i], stream);
  },
  GeometryCollection: function(object, stream) {
    var geometries = object.geometries, i = -1, n = geometries.length;
    while (++i < n) streamGeometry(geometries[i], stream);
  }
};

function streamLine(coordinates, stream, closed) {
  var i = -1, n = coordinates.length - closed, coordinate;
  stream.lineStart();
  while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
  stream.lineEnd();
}

function streamPolygon(coordinates, stream) {
  var i = -1, n = coordinates.length;
  stream.polygonStart();
  while (++i < n) streamLine(coordinates[i], stream, 1);
  stream.polygonEnd();
}

/* harmony default export */ __webpack_exports__["default"] = (function(object, stream) {
  if (object && streamObjectType.hasOwnProperty(object.type)) {
    streamObjectType[object.type](object, stream);
  } else {
    streamGeometry(object, stream);
  }
});


/***/ }),

/***/ "toJ+":
/*!*************************************************************************!*\
  !*** ./node_modules/c3/node_modules/d3-scale/src/sequentialQuantile.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return sequentialQuantile; });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "sRF9");
/* harmony import */ var _continuous__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./continuous */ "A24K");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./init */ "//NX");




function sequentialQuantile() {
  var domain = [],
      interpolator = _continuous__WEBPACK_IMPORTED_MODULE_1__["identity"];

  function scale(x) {
    if (!isNaN(x = +x)) return interpolator((Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["bisect"])(domain, x) - 1) / (domain.length - 1));
  }

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [];
    for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);
    domain.sort(d3_array__WEBPACK_IMPORTED_MODULE_0__["ascending"]);
    return scale;
  };

  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };

  scale.copy = function() {
    return sequentialQuantile(interpolator).domain(domain);
  };

  return _init__WEBPACK_IMPORTED_MODULE_2__["initInterpolator"].apply(scale, arguments);
}


/***/ }),

/***/ "uCr6":
/*!******************************************!*\
  !*** ./node_modules/d3-geo/src/adder.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Adds floating point numbers with twice the normal precision.
// Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and
// Fast Robust Geometric Predicates, Discrete & Computational Geometry 18(3)
// 305–363 (1997).
// Code adapted from GeographicLib by Charles F. F. Karney,
// http://geographiclib.sourceforge.net/

/* harmony default export */ __webpack_exports__["default"] = (function() {
  return new Adder;
});

function Adder() {
  this.reset();
}

Adder.prototype = {
  constructor: Adder,
  reset: function() {
    this.s = // rounded value
    this.t = 0; // exact error
  },
  add: function(y) {
    add(temp, y, this.t);
    add(this, temp.s, this.s);
    if (this.s) this.t += temp.t;
    else this.s = temp.t;
  },
  valueOf: function() {
    return this.s;
  }
};

var temp = new Adder;

function add(adder, a, b) {
  var x = adder.s = a + b,
      bv = x - a,
      av = x - bv;
  adder.t = (a - av) + (b - bv);
}


/***/ }),

/***/ "uD/i":
/*!*********************************************!*\
  !*** ./node_modules/d3-geo/src/constant.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return function() {
    return x;
  };
});


/***/ }),

/***/ "uQ0a":
/*!**********************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/sequential-multi/PuBu.js ***!
  \**********************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors.js */ "ZtE7");
/* harmony import */ var _ramp_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp.js */ "jQWc");



var scheme = new Array(3).concat(
  "ece7f2a6bddb2b8cbe",
  "f1eef6bdc9e174a9cf0570b0",
  "f1eef6bdc9e174a9cf2b8cbe045a8d",
  "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d",
  "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b",
  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b",
  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858"
).map(_colors_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp_js__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "uV4M":
/*!*************************************************!*\
  !*** ./node_modules/d3-polygon/src/contains.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(polygon, point) {
  var n = polygon.length,
      p = polygon[n - 1],
      x = point[0], y = point[1],
      x0 = p[0], y0 = p[1],
      x1, y1,
      inside = false;

  for (var i = 0; i < n; ++i) {
    p = polygon[i], x1 = p[0], y1 = p[1];
    if (((y1 > y) !== (y0 > y)) && (x < (x0 - x1) * (y - y1) / (y0 - y1) + x1)) inside = !inside;
    x0 = x1, y0 = y1;
  }

  return inside;
});


/***/ }),

/***/ "vAb3":
/*!********************************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/cylindricalEqualArea.js ***!
  \********************************************************************/
/*! exports provided: cylindricalEqualAreaRaw */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cylindricalEqualAreaRaw", function() { return cylindricalEqualAreaRaw; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "R0y8");


function cylindricalEqualAreaRaw(phi0) {
  var cosPhi0 = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["cos"])(phi0);

  function forward(lambda, phi) {
    return [lambda * cosPhi0, Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sin"])(phi) / cosPhi0];
  }

  forward.invert = function(x, y) {
    return [x / cosPhi0, Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["asin"])(y * cosPhi0)];
  };

  return forward;
}


/***/ }),

/***/ "vHEj":
/*!***********************************************!*\
  !*** ./node_modules/d3-geo/src/path/index.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../identity.js */ "IYKK");
/* harmony import */ var _stream_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../stream.js */ "tepu");
/* harmony import */ var _area_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./area.js */ "rBOd");
/* harmony import */ var _bounds_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./bounds.js */ "SMTj");
/* harmony import */ var _centroid_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./centroid.js */ "5D8y");
/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./context.js */ "ikcO");
/* harmony import */ var _measure_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./measure.js */ "EyUX");
/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./string.js */ "mLep");









/* harmony default export */ __webpack_exports__["default"] = (function(projection, context) {
  var pointRadius = 4.5,
      projectionStream,
      contextStream;

  function path(object) {
    if (object) {
      if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
      Object(_stream_js__WEBPACK_IMPORTED_MODULE_1__["default"])(object, projectionStream(contextStream));
    }
    return contextStream.result();
  }

  path.area = function(object) {
    Object(_stream_js__WEBPACK_IMPORTED_MODULE_1__["default"])(object, projectionStream(_area_js__WEBPACK_IMPORTED_MODULE_2__["default"]));
    return _area_js__WEBPACK_IMPORTED_MODULE_2__["default"].result();
  };

  path.measure = function(object) {
    Object(_stream_js__WEBPACK_IMPORTED_MODULE_1__["default"])(object, projectionStream(_measure_js__WEBPACK_IMPORTED_MODULE_6__["default"]));
    return _measure_js__WEBPACK_IMPORTED_MODULE_6__["default"].result();
  };

  path.bounds = function(object) {
    Object(_stream_js__WEBPACK_IMPORTED_MODULE_1__["default"])(object, projectionStream(_bounds_js__WEBPACK_IMPORTED_MODULE_3__["default"]));
    return _bounds_js__WEBPACK_IMPORTED_MODULE_3__["default"].result();
  };

  path.centroid = function(object) {
    Object(_stream_js__WEBPACK_IMPORTED_MODULE_1__["default"])(object, projectionStream(_centroid_js__WEBPACK_IMPORTED_MODULE_4__["default"]));
    return _centroid_js__WEBPACK_IMPORTED_MODULE_4__["default"].result();
  };

  path.projection = function(_) {
    return arguments.length ? (projectionStream = _ == null ? (projection = null, _identity_js__WEBPACK_IMPORTED_MODULE_0__["default"]) : (projection = _).stream, path) : projection;
  };

  path.context = function(_) {
    if (!arguments.length) return context;
    contextStream = _ == null ? (context = null, new _string_js__WEBPACK_IMPORTED_MODULE_7__["default"]) : new _context_js__WEBPACK_IMPORTED_MODULE_5__["default"](context = _);
    if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
    return path;
  };

  path.pointRadius = function(_) {
    if (!arguments.length) return pointRadius;
    pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
    return path;
  };

  return path.projection(projection).context(context);
});


/***/ }),

/***/ "vL4l":
/*!*************************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/sequential-single/Greens.js ***!
  \*************************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors.js */ "ZtE7");
/* harmony import */ var _ramp_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp.js */ "jQWc");



var scheme = new Array(3).concat(
  "e5f5e0a1d99b31a354",
  "edf8e9bae4b374c476238b45",
  "edf8e9bae4b374c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b"
).map(_colors_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp_js__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "vNJl":
/*!*******************************************!*\
  !*** ./node_modules/d3-geo/src/circle.js ***!
  \*******************************************/
/*! exports provided: circleStream, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "circleStream", function() { return circleStream; });
/* harmony import */ var _cartesian_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cartesian.js */ "YzSS");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constant.js */ "uD/i");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math.js */ "R0y8");
/* harmony import */ var _rotation_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rotation.js */ "cwsO");





// Generates a circle centered at [0°, 0°], with a given radius and precision.
function circleStream(stream, radius, delta, direction, t0, t1) {
  if (!delta) return;
  var cosRadius = Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["cos"])(radius),
      sinRadius = Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["sin"])(radius),
      step = direction * delta;
  if (t0 == null) {
    t0 = radius + direction * _math_js__WEBPACK_IMPORTED_MODULE_2__["tau"];
    t1 = radius - step / 2;
  } else {
    t0 = circleRadius(cosRadius, t0);
    t1 = circleRadius(cosRadius, t1);
    if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * _math_js__WEBPACK_IMPORTED_MODULE_2__["tau"];
  }
  for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
    point = Object(_cartesian_js__WEBPACK_IMPORTED_MODULE_0__["spherical"])([cosRadius, -sinRadius * Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["cos"])(t), -sinRadius * Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["sin"])(t)]);
    stream.point(point[0], point[1]);
  }
}

// Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].
function circleRadius(cosRadius, point) {
  point = Object(_cartesian_js__WEBPACK_IMPORTED_MODULE_0__["cartesian"])(point), point[0] -= cosRadius;
  Object(_cartesian_js__WEBPACK_IMPORTED_MODULE_0__["cartesianNormalizeInPlace"])(point);
  var radius = Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["acos"])(-point[1]);
  return ((-point[2] < 0 ? -radius : radius) + _math_js__WEBPACK_IMPORTED_MODULE_2__["tau"] - _math_js__WEBPACK_IMPORTED_MODULE_2__["epsilon"]) % _math_js__WEBPACK_IMPORTED_MODULE_2__["tau"];
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  var center = Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])([0, 0]),
      radius = Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(90),
      precision = Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(6),
      ring,
      rotate,
      stream = {point: point};

  function point(x, y) {
    ring.push(x = rotate(x, y));
    x[0] *= _math_js__WEBPACK_IMPORTED_MODULE_2__["degrees"], x[1] *= _math_js__WEBPACK_IMPORTED_MODULE_2__["degrees"];
  }

  function circle() {
    var c = center.apply(this, arguments),
        r = radius.apply(this, arguments) * _math_js__WEBPACK_IMPORTED_MODULE_2__["radians"],
        p = precision.apply(this, arguments) * _math_js__WEBPACK_IMPORTED_MODULE_2__["radians"];
    ring = [];
    rotate = Object(_rotation_js__WEBPACK_IMPORTED_MODULE_3__["rotateRadians"])(-c[0] * _math_js__WEBPACK_IMPORTED_MODULE_2__["radians"], -c[1] * _math_js__WEBPACK_IMPORTED_MODULE_2__["radians"], 0).invert;
    circleStream(stream, r, p, 1);
    c = {type: "Polygon", coordinates: [ring]};
    ring = rotate = null;
    return c;
  }

  circle.center = function(_) {
    return arguments.length ? (center = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])([+_[0], +_[1]]), circle) : center;
  };

  circle.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), circle) : radius;
  };

  circle.precision = function(_) {
    return arguments.length ? (precision = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), circle) : precision;
  };

  return circle;
});


/***/ }),

/***/ "vW5+":
/*!**************************************************************!*\
  !*** ./node_modules/c3/node_modules/d3-array/src/permute.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(array, indexes) {
  var i = indexes.length, permutes = new Array(i);
  while (i--) permutes[i] = array[indexes[i]];
  return permutes;
});


/***/ }),

/***/ "w5my":
/*!***************************************************************!*\
  !*** ./node_modules/c3/node_modules/d3-array/src/variance.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./number */ "1Fr+");


/* harmony default export */ __webpack_exports__["default"] = (function(values, valueof) {
  var n = values.length,
      m = 0,
      i = -1,
      mean = 0,
      value,
      delta,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = Object(_number__WEBPACK_IMPORTED_MODULE_0__["default"])(values[i]))) {
        delta = value - mean;
        mean += delta / ++m;
        sum += delta * (value - mean);
      }
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = Object(_number__WEBPACK_IMPORTED_MODULE_0__["default"])(valueof(values[i], i, values)))) {
        delta = value - mean;
        mean += delta / ++m;
        sum += delta * (value - mean);
      }
    }
  }

  if (m > 1) return sum / (m - 1);
});


/***/ }),

/***/ "w5vR":
/*!*******************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/categorical/Paired.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors.js */ "ZtE7");


/* harmony default export */ __webpack_exports__["default"] = (Object(_colors_js__WEBPACK_IMPORTED_MODULE_0__["default"])("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928"));


/***/ }),

/***/ "w6Z2":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/diverging/RdYlBu.js ***!
  \*****************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors.js */ "ZtE7");
/* harmony import */ var _ramp_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp.js */ "jQWc");



var scheme = new Array(3).concat(
  "fc8d59ffffbf91bfdb",
  "d7191cfdae61abd9e92c7bb6",
  "d7191cfdae61ffffbfabd9e92c7bb6",
  "d73027fc8d59fee090e0f3f891bfdb4575b4",
  "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4",
  "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4",
  "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4",
  "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695",
  "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695"
).map(_colors_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp_js__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "wKaL":
/*!********************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/gnomonic.js ***!
  \********************************************************/
/*! exports provided: gnomonicRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gnomonicRaw", function() { return gnomonicRaw; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "R0y8");
/* harmony import */ var _azimuthal_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./azimuthal.js */ "dg0l");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.js */ "1ibS");




function gnomonicRaw(x, y) {
  var cy = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["cos"])(y), k = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["cos"])(x) * cy;
  return [cy * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sin"])(x) / k, Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sin"])(y) / k];
}

gnomonicRaw.invert = Object(_azimuthal_js__WEBPACK_IMPORTED_MODULE_1__["azimuthalInvert"])(_math_js__WEBPACK_IMPORTED_MODULE_0__["atan"]);

/* harmony default export */ __webpack_exports__["default"] = (function() {
  return Object(_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(gnomonicRaw)
      .scale(144.049)
      .clipAngle(60);
});


/***/ }),

/***/ "wQ3i":
/*!***********************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/sequential-multi/turbo.js ***!
  \***********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(t) {
  t = Math.max(0, Math.min(1, t));
  return "rgb("
      + Math.max(0, Math.min(255, Math.round(34.61 + t * (1172.33 - t * (10793.56 - t * (33300.12 - t * (38394.49 - t * 14825.05))))))) + ", "
      + Math.max(0, Math.min(255, Math.round(23.31 + t * (557.33 + t * (1225.33 - t * (3574.96 - t * (1073.77 + t * 707.56))))))) + ", "
      + Math.max(0, Math.min(255, Math.round(27.2 + t * (3211.1 - t * (15327.97 - t * (27814 - t * (22569.18 - t * 6838.66)))))))
      + ")";
});


/***/ }),

/***/ "wvSV":
/*!**********************************************!*\
  !*** ./node_modules/d3-quadtree/src/size.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function() {
  var size = 0;
  this.visit(function(node) {
    if (!node.length) do ++size; while (node = node.next)
  });
  return size;
});


/***/ }),

/***/ "xP+1":
/*!*********************************************!*\
  !*** ./node_modules/d3-contour/src/area.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(ring) {
  var i = 0, n = ring.length, area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];
  while (++i < n) area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];
  return area;
});


/***/ }),

/***/ "xkTb":
/*!**********************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/categorical/Tableau10.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors.js */ "ZtE7");


/* harmony default export */ __webpack_exports__["default"] = (Object(_colors_js__WEBPACK_IMPORTED_MODULE_0__["default"])("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab"));


/***/ }),

/***/ "xpgS":
/*!*****************************************************************!*\
  !*** ./node_modules/c3/node_modules/d3-array/src/descending.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
});


/***/ }),

/***/ "yUst":
/*!**********************************************************************!*\
  !*** ./node_modules/d3-scale-chromatic/src/sequential-multi/OrRd.js ***!
  \**********************************************************************/
/*! exports provided: scheme, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheme", function() { return scheme; });
/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors.js */ "ZtE7");
/* harmony import */ var _ramp_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ramp.js */ "jQWc");



var scheme = new Array(3).concat(
  "fee8c8fdbb84e34a33",
  "fef0d9fdcc8afc8d59d7301f",
  "fef0d9fdcc8afc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
).map(_colors_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Object(_ramp_js__WEBPACK_IMPORTED_MODULE_1__["default"])(scheme));


/***/ }),

/***/ "yWPb":
/*!****************************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/conicEquidistant.js ***!
  \****************************************************************/
/*! exports provided: conicEquidistantRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conicEquidistantRaw", function() { return conicEquidistantRaw; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "R0y8");
/* harmony import */ var _conic_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./conic.js */ "bN2o");
/* harmony import */ var _equirectangular_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./equirectangular.js */ "VXJj");




function conicEquidistantRaw(y0, y1) {
  var cy0 = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["cos"])(y0),
      n = y0 === y1 ? Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sin"])(y0) : (cy0 - Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["cos"])(y1)) / (y1 - y0),
      g = cy0 / n + y0;

  if (Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["abs"])(n) < _math_js__WEBPACK_IMPORTED_MODULE_0__["epsilon"]) return _equirectangular_js__WEBPACK_IMPORTED_MODULE_2__["equirectangularRaw"];

  function project(x, y) {
    var gy = g - y, nx = n * x;
    return [gy * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sin"])(nx), g - gy * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["cos"])(nx)];
  }

  project.invert = function(x, y) {
    var gy = g - y,
        l = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["atan2"])(x, Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["abs"])(gy)) * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sign"])(gy);
    if (gy * n < 0)
      l -= _math_js__WEBPACK_IMPORTED_MODULE_0__["pi"] * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sign"])(x) * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sign"])(gy);
    return [l / n, g - Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sign"])(n) * Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(x * x + gy * gy)];
  };

  return project;
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  return Object(_conic_js__WEBPACK_IMPORTED_MODULE_1__["conicProjection"])(conicEquidistantRaw)
      .scale(131.154)
      .center([0, 13.9389]);
});


/***/ }),

/***/ "yhNL":
/*!************************************************************!*\
  !*** ./node_modules/c3/node_modules/d3-array/src/array.js ***!
  \************************************************************/
/*! exports provided: slice, map */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slice", function() { return slice; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "map", function() { return map; });
var array = Array.prototype;

var slice = array.slice;
var map = array.map;


/***/ }),

/***/ "z6FA":
/*!**************************************************!*\
  !*** ./node_modules/d3-quadtree/src/quadtree.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return quadtree; });
/* harmony import */ var _add_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./add.js */ "9l1u");
/* harmony import */ var _cover_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cover.js */ "9ABZ");
/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./data.js */ "LMxf");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./extent.js */ "H7P7");
/* harmony import */ var _find_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./find.js */ "HZff");
/* harmony import */ var _remove_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./remove.js */ "G0FW");
/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./root.js */ "RQVR");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./size.js */ "wvSV");
/* harmony import */ var _visit_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./visit.js */ "EVP4");
/* harmony import */ var _visitAfter_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./visitAfter.js */ "tSfe");
/* harmony import */ var _x_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./x.js */ "m7tx");
/* harmony import */ var _y_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./y.js */ "Nv8T");













function quadtree(nodes, x, y) {
  var tree = new Quadtree(x == null ? _x_js__WEBPACK_IMPORTED_MODULE_10__["defaultX"] : x, y == null ? _y_js__WEBPACK_IMPORTED_MODULE_11__["defaultY"] : y, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}

function Quadtree(x, y, x0, y0, x1, y1) {
  this._x = x;
  this._y = y;
  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  this._root = undefined;
}

function leaf_copy(leaf) {
  var copy = {data: leaf.data}, next = copy;
  while (leaf = leaf.next) next = next.next = {data: leaf.data};
  return copy;
}

var treeProto = quadtree.prototype = Quadtree.prototype;

treeProto.copy = function() {
  var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
      node = this._root,
      nodes,
      child;

  if (!node) return copy;

  if (!node.length) return copy._root = leaf_copy(node), copy;

  nodes = [{source: node, target: copy._root = new Array(4)}];
  while (node = nodes.pop()) {
    for (var i = 0; i < 4; ++i) {
      if (child = node.source[i]) {
        if (child.length) nodes.push({source: child, target: node.target[i] = new Array(4)});
        else node.target[i] = leaf_copy(child);
      }
    }
  }

  return copy;
};

treeProto.add = _add_js__WEBPACK_IMPORTED_MODULE_0__["default"];
treeProto.addAll = _add_js__WEBPACK_IMPORTED_MODULE_0__["addAll"];
treeProto.cover = _cover_js__WEBPACK_IMPORTED_MODULE_1__["default"];
treeProto.data = _data_js__WEBPACK_IMPORTED_MODULE_2__["default"];
treeProto.extent = _extent_js__WEBPACK_IMPORTED_MODULE_3__["default"];
treeProto.find = _find_js__WEBPACK_IMPORTED_MODULE_4__["default"];
treeProto.remove = _remove_js__WEBPACK_IMPORTED_MODULE_5__["default"];
treeProto.removeAll = _remove_js__WEBPACK_IMPORTED_MODULE_5__["removeAll"];
treeProto.root = _root_js__WEBPACK_IMPORTED_MODULE_6__["default"];
treeProto.size = _size_js__WEBPACK_IMPORTED_MODULE_7__["default"];
treeProto.visit = _visit_js__WEBPACK_IMPORTED_MODULE_8__["default"];
treeProto.visitAfter = _visitAfter_js__WEBPACK_IMPORTED_MODULE_9__["default"];
treeProto.x = _x_js__WEBPACK_IMPORTED_MODULE_10__["default"];
treeProto.y = _y_js__WEBPACK_IMPORTED_MODULE_11__["default"];


/***/ }),

/***/ "zCPI":
/*!*****************************************************************!*\
  !*** ./node_modules/c3/node_modules/d3-scale/src/tickFormat.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "sRF9");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-format */ "rWgG");



/* harmony default export */ __webpack_exports__["default"] = (function(start, stop, count, specifier) {
  var step = Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["tickStep"])(start, stop, count),
      precision;
  specifier = Object(d3_format__WEBPACK_IMPORTED_MODULE_1__["formatSpecifier"])(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = Object(d3_format__WEBPACK_IMPORTED_MODULE_1__["precisionPrefix"])(step, value))) specifier.precision = precision;
      return Object(d3_format__WEBPACK_IMPORTED_MODULE_1__["formatPrefix"])(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = Object(d3_format__WEBPACK_IMPORTED_MODULE_1__["precisionRound"])(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = Object(d3_format__WEBPACK_IMPORTED_MODULE_1__["precisionFixed"])(step))) specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return Object(d3_format__WEBPACK_IMPORTED_MODULE_1__["format"])(specifier);
});


/***/ }),

/***/ "zMfI":
/*!**********************************************!*\
  !*** ./node_modules/d3-contour/src/index.js ***!
  \**********************************************/
/*! exports provided: contours, contourDensity */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _contours__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./contours */ "gy+j");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "contours", function() { return _contours__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _density__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./density */ "Sf2A");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "contourDensity", function() { return _density__WEBPACK_IMPORTED_MODULE_1__["default"]; });





/***/ }),

/***/ "zz/+":
/*!*******************************************!*\
  !*** ./node_modules/d3-geo/src/length.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _adder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./adder.js */ "uCr6");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ "R0y8");
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./noop.js */ "mPOO");
/* harmony import */ var _stream_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stream.js */ "tepu");





var lengthSum = Object(_adder_js__WEBPACK_IMPORTED_MODULE_0__["default"])(),
    lambda0,
    sinPhi0,
    cosPhi0;

var lengthStream = {
  sphere: _noop_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  point: _noop_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  lineStart: lengthLineStart,
  lineEnd: _noop_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  polygonStart: _noop_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  polygonEnd: _noop_js__WEBPACK_IMPORTED_MODULE_2__["default"]
};

function lengthLineStart() {
  lengthStream.point = lengthPointFirst;
  lengthStream.lineEnd = lengthLineEnd;
}

function lengthLineEnd() {
  lengthStream.point = lengthStream.lineEnd = _noop_js__WEBPACK_IMPORTED_MODULE_2__["default"];
}

function lengthPointFirst(lambda, phi) {
  lambda *= _math_js__WEBPACK_IMPORTED_MODULE_1__["radians"], phi *= _math_js__WEBPACK_IMPORTED_MODULE_1__["radians"];
  lambda0 = lambda, sinPhi0 = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi), cosPhi0 = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi);
  lengthStream.point = lengthPoint;
}

function lengthPoint(lambda, phi) {
  lambda *= _math_js__WEBPACK_IMPORTED_MODULE_1__["radians"], phi *= _math_js__WEBPACK_IMPORTED_MODULE_1__["radians"];
  var sinPhi = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi),
      cosPhi = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi),
      delta = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["abs"])(lambda - lambda0),
      cosDelta = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["cos"])(delta),
      sinDelta = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["sin"])(delta),
      x = cosPhi * sinDelta,
      y = cosPhi0 * sinPhi - sinPhi0 * cosPhi * cosDelta,
      z = sinPhi0 * sinPhi + cosPhi0 * cosPhi * cosDelta;
  lengthSum.add(Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["atan2"])(Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(x * x + y * y), z));
  lambda0 = lambda, sinPhi0 = sinPhi, cosPhi0 = cosPhi;
}

/* harmony default export */ __webpack_exports__["default"] = (function(object) {
  lengthSum.reset();
  Object(_stream_js__WEBPACK_IMPORTED_MODULE_3__["default"])(object, lengthStream);
  return +lengthSum;
});


/***/ })

}]);
//# sourceMappingURL=src-app-pages-dashboard-dashboard-module.js.map